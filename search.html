<!DOCTYPE html>
<html>

<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- syntax.css 추가-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- 웹폰트(나눔 고딕) 추가 -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"> -->

    <!-- font awesome 추가 -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
        integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

    <style>
        .hljs {
            background: none;
        }

        /* web font 추가 */
        @font-face {
            font-family: 'MaruBuri-Regular';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-10-21@1.0/MaruBuri-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
    </style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="배움을 기록합니다" />
    <link rel="shortcut icon" href="https://ohoraming.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ohoraming.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="예비 개발자의 노트" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="배움을 기록합니다" />
    <meta property="og:url" content="https://ohoraming.github.io/search" />
    <meta property="og:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="배움을 기록합니다" />
    <meta name="twitter:url" content="https://ohoraming.github.io/" />
    <meta name="twitter:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="예비 개발자의 노트" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "예비 개발자의 노트",
        "logo": "https://ohoraming.github.io/"
    },
    "url": "https://ohoraming.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://ohoraming.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ohoraming.github.io/search"
    },
    "description": "배움을 기록합니다"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>

<body
    class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
        
        <a class="site-nav-logo" href="https://ohoraming.github.io/">예비 개발자의 노트</a>
        
        
        
        <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!-- About: blog에 대한 기본적인 소개-->
    <!-- C:\myblog\about\index.md에서 세부설정 -->
    <!-- href: C:\myblog\_data\authors\tags.yml에서 설정한 tag명 tag/다음에 넣음 -->
    <li class="nav-about" role="menuitem"><a href="/about/">Portfolio</a></li>

    <li class="nav-archive" role="menuitem"><a href="/tag/JAVA/">JAVA</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/JavaScript/">JavaScript</a></li>
    <li class="nav-archive" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-archive" role="menuitem"><a href="/author_archive.html">All Tags</a></li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
        <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>
    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "javascript-operator": {
        "title": "JavaScript(3) - operator",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator1. String concatenationconsole.log('my' + ' cat');console.log('1' + 2);console.log(`string literals: 1 + 2 = ${1 + 2}`);console.log(`string literals: '''''3 + 4 = ${3 + 4}`);  Console  my cat  12  string literals: 1 + 2 = 3  string literals:  ’’’’’  3 + 4 = 7  string literals의 경우, `(backtick)을 사용해 줄 바꿈과 ' (single qoutation mark) 입력이 쉬움2. Logical operators:  ||(or), &amp;&amp;(and), !(not)      ||(or)  → 여러 조건 중 하나라도 true이면 true  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → true인 조건을 만나면 이후의 조건은 더 이상 읽지 않음        &amp;&amp;(and)  → 여러 조건 중 하나라도 false이면 false  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → false인 조건을 만나면 이후의 조건은 더 이상 읽지 않음  → null check할 때 유용하게 쓰임  3. Equalityconst stringFive = '5';const numberFive = 5;// == loose equality, with type conversionconsole.log(stringFive == numberFive); // trueconsole.log(stringFive != numberFive); // false// === strick equality, no type conversionconsole.log(stringFive === numberFive); // falseconsole.log(stringFive !== numberFive); // true  Console  true  false  false  true// object equality by referenceconst minji1 = { myname: 'minji'};const minji2 = { myname: 'minji'};const minji3 = minji1;console.log(minji1 == minji2); // falseconsole.log(minji1 === minji2); // falseconsole.log(minji1 === minji3); // true  Console  false  false  true→ object에는 object를 가리키는 reference를 저장함// equalityconsole.log(0 == false); // trueconsole.log(0 === false); // falseconsole.log('' == false); // trueconsole.log('' === false); // falseconsole.log(null == undefined); // trueconsole.log(null === undefined); // false⇒ 0, null, undefined, NaN, ‘’ 은 false로 간주함⇒ 0은 boolean type이 아니라서 strict equality를 적용하게 되면 0은 false가 아님⇒ null은 undefined로 간주되지만, null과 undefined는 다른 type4. Ternary operator  삼항연산자  condition?value1:value2;  조건이 간단한 경우에만 씀  조건이 복잡해질 경우에는 if나 switch를 사용하는 것이 좋음Switch statement  if, else if를 반복하게 된다면 switch를 쓰는 것이 더 나음  enum-like value check시 사용const browser = 'IE';switch (browser) {    case 'IE':        console.log('go away!');        break;    case 'Chrome':    case 'Firefox':        console.log('love you!'); // 'Chrome'과 'Firefox'의 결과 값이 같으므로 한번에 적어줌!        break;    default:        console.log('same all!');        break;}※ 같은 결과 값을 요구한다면, case를 이어서 적어주면 됨Loopsnested loopsfor (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        console.log(`i:${i}, j:${j}`);    }}⇒ O(n^2)이므로 CPU에 좋지 않으므로 피하는 것이 좋음!continue/break// Q1. iterate from 0 to 10 and print only even numbers (use continue)for (let i = 0; i &lt; 11; i++) {    if (i % 2 !== 0) {        continue;    }    console.log(`q1. ${i}`);}// Q2. iterate from 0 to 10 and print numbers until reaching 8 (use break)for (let i = 0; i &lt; 11; i++) {    if (i &gt; 8) {        break;    }    console.log(`q2. ${i}`);}※ label은 다른 방식으로 코드를 바꿔 사용이 가능해 현업에서는 쓰지 않으니 참고!  출처: “자바스크립트 4. 코딩의 기본 operator, if, for loop 코드리뷰 팁 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 20:14, 게시자 “드림코딩 by 엘리,” 2020년 4월 15일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-operator"
    }
    , 
    
    "javascript-variable": {
        "title": "JavaScript(2) - strict mode, variable",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator1. Strict Mode  ES(ECMAScript) 5부터 추가됨  Valina JS 문서가 시작될 때, 'use strict'; 를 쓰면 strict mode로 시작  보다 상식적인 범위 내에서 코딩이 이루어 질 수 있도록 엄격한 잣대로 코드를 실행  JS engine이 보다 효율적으로 구동됨Strict mode - JavaScript | MDN2. Variable      Data types                  primitive, single item→ 더 이상 작게 쪼갤 수 없는 한 가지 아이템→ number, string, boolean, null, undefined, symbol→ 값(value) 자체가 메모리에 저장됨                    object, box container→ single item들을 묶어서 관리하는 것→ object를 가리키는 reference가 메모리에 저장됨                    function※ first-class function  → variable에 할당 가능  → 다른 함수의 parameter로 전달이 가능  → return 값으로 지정 가능                  Immutable/Mutable data types                  Immutable data types→ data 자체 변경 불가→ primitive types, frozen objects (i.e. object.freeze())                    Mutable data types→ data 변경 가능→ all objects by default are mutable in JS            let→ ES6에서 추가됨  → var는 이제 사용하지 말 것!  var hoisting변수의 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림→ var는 block scope가 적용되지 않음  → block 안에 있는 변수를 block 바깥에서도 부를 수 있는 상황이 발생함※참고:  Variable hoisting - JavaScript | MDN  {    age = 4;    var age;  }  console.log(age);  Console  4global variable vs. local variable  global variable → 함수의 바깥에 선언한 변수→ 문서 전체에서 사용 가능함  local variable → 함수의 안에 선언한 변수→ 함수 안에서만 사용 가능함 (block scope)※참고:  Variable scope - JavaScript | MDNnumber  JS에서는 숫자의 data type과 상관없이 number type으로 할당됨      const count = 17; // integer  const size = 17.1; // decimal number  console.log(`value: ${count}, type: ${typeof count}`);  console.log(`value: ${size}, type: ${typeof size}`);              Console      value: 17, type: number      value: 17.1, type: number        양수를 0으로 나누면 infinity음수를 0으로 나누면 negative infinity숫자가 아닌 것을 숫자로 나누면 NaN(not a number)string  글자는 수에 상관 없이 모두 string으로 할당됨  +기호를 사용해 다른 변수와 붙일 수 있음  const brendan = \"brendan\";  const greeting = \"hello \" + brendan;  console.log(`value: ${greeting}, type: ${typeof greeting}`);  Console  value: hello brendan, type: string      template literals (string literals)→ `(backtick)을 이용해 string과 ${variable} 을 써주면 결과 값이 붙여져 나옴→ ‘ ‘(quotes)와 +를 쓰는 것보다 편리함    const helloBob = `hi ${brendan}!`; // template literals (template string)console.log(`value: ${helloBob}, type: ${typeof helloBob}`);console.log(\"value: \" + helloBob + \", type: \" + typeof helloBob);              consol      value: hi brendan!, type: string      value: hi brendan!, type: string      boolean  false: 0, null, undefined, NaN, ‘ ‘      true: any other value    const canRead = true;const test = 3 &lt; 1; // falseconsole.log(`value: ${canRead}, type: ${typeof canRead}`);console.log(`value: ${test}, type: ${typeof test}`);        consol  value: true, type: boolean  value: false, type: booleannull / undefined  null로 할당하면 아무런 값도 없다는 것을 명시하는 것  undefined로 지정하거나 아무 것도 지정하지 않으면, 선언은 되었지만 값이 정해지지 않은 상황// nulllet nothing = null;console.log(`value: ${nothing}, type: ${typeof nothing}`);// undefinedlet x = undefined; // let x; 도 같은 뜻console.log(`value: ${x}, type: ${typeof x}`);  consol  value: null, type: object  value: undefined, type: undefinedsymbol// symbol, create unique identifiers for objectsconst symbol1 = Symbol(\"id\");const symbol2 = Symbol(\"id\");console.log(symbol1 === symbol2);const gSymbol1 = Symbol.for(\"id\");const gSymbol2 = Symbol.for(\"id\");console.log(gSymbol1 === gSymbol2); // true  consol  false  true※ .description을 이용해 string으로 변환한 뒤, 출력해야 함!console.log(`value: ${symbol1}, type: ${typeof symbol1}`); // error!console.log(`value: ${symbol1.description}, type: ${typeof symbol1}`);  console  Uncaught TypeError: Cannot convert a Symbol value to a string at ~  value: id, type: symbolobjectobject 문서 연결하기!3. Constantconst  가능하면 const로 선언하는 것이 좋음  block scope (like let)let은 mutable(변경 가능), const는 immutable(변경 불가) data type  reassignment(재할당)로 값이 바뀌거나, redeclare(재선언) 불가  장점          보안상 좋음      다양한 threads의 동시 접속으로 변수 값 변경이 일어나는 것을 방지      코드 변경시 실수를 줄여줌      4. Dynamic typing  JS = dynamically typed language→ run time 동안 할당된 값에 따라 data type 변화됨  C, JAVA = statically typed language→ 변수 선언시 data type 명시 필요    let text = \"hello\";console.log(text.charAt(0)); // hconsole.log(`value: ${text}, type: ${typeof text}`);text = 1;console.log(`value: ${text}, type: ${typeof text}`);text = \"7\" + 5;console.log(`value: ${text}, type: ${typeof text}`);text = \"8\" / \"2\";console.log(`value: ${text}, type: ${typeof text}`);console.log(text.charAt(0));              console      h      value: hello, type: string      value: 1, type: number      value: 75, type: string      value: 4, type: number      Uncaught TypeError: text.charAt is not a function at ~        → string과 숫자가 합쳐지면 string이 되고,숫자로 이루어진 string끼리의 연산이 이루어지면 number가 되는 오류 발생  (→ TS(typescript)가 나오게 되는 계기)    출처: “자바스크립트 3. 데이터타입, data types, let vs var, hoisting 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 27:58, 게시자 “드림코딩 by 엘리,” 2020년 4월 11일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-variable"
    }
    , 
    
    "javascript-asyncdefer": {
        "title": "JavaScript(1) - async vs. defer",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator1. &lt;head&gt;tag내에서 &lt;script src=”main.js”&gt;&lt;/script&gt; 선언할 때  parsing HTML : HTML 문서를 한 줄 씩 읽어 내려가다가  &lt;script&gt; tag를 만나면 parsing을 멈추고, fetching js, executing js : js파일을 다운 받아서 실행함.  2번이 끝나면, 다시 parsing HTML을 이어서 마무리 함⇒ 단점: 사용자가 웹사이트를 보기까지 시간이 많이 걸림2. &lt;body&gt;tag 가장 아랫 부분에 &lt;script&gt;tag를 넣는 경우⇒ 장점: 사용자가 HTML 컨텐츠를 빠르게 볼 수 있음⇒ 단점: js의 영향력이 큰 페이지라면 사용자가 온전한 페이지를 접하기까지 오래 걸림3. &lt;head&gt;tag 내에 &lt;script async src=”main.js”&gt;를 선언하는 경우  HTML parsing을 하다가 async를 만나면 js문서의 다운로드를 병렬로 진행하다가  js의 다운로드가 끝나면, parsing을 멈추고 다운로드 된 js를 실행시킴  실행이 끝나면 나머지 HTML을 parsing함⇒ 장점: js의 다운로드 시간을 절약할 수 있음⇒ 단점: js가 적용되는 HTML문서의 parsing에 따른 시간 차이로 인해 오류가 생길 수 있으며, 여전히 온전한 페이지 로딩에 시간이 많이 걸림4. &lt;head&gt;tag내에 &lt;script defer src=”main.js”&gt;를 선언하는 경우★★★★★  HTML parsing 하다가 defer를 만나면 js문서의 다운로드를 병렬로 진행하다가  HTML parsing이 끝나면 사용자에게 페이지를 보여줌  다운로드 된 js를 실행시킴5. async vs. deferasync의 경우,여러 개의 js문서가 적용 순서와 상관없이 fetching이 완료된 순서로 실행이 됨→ 실행 순서가 중요하다면 오류가 생길 수 있음defer의 경우,parsing하는 동안 js가 모두 다운로드 되므로 순서대로 실행이 됨※ 그러므로, &lt;head&gt;tag 내에 &lt;script defer src=”main.js”&gt;&lt;/script&gt;로 선언하는 것이 가장 효율적이며, 안전함!  “자바스크립트 2. 콘솔에 출력, script async 와 defer의 차이점 및 앞으로 자바스크립트 공부 방향 | 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 17:43, 게시자 “드림코딩 by 엘리,” 2020년 4월 7일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-asyncDefer"
    }
    , 
    
    "java-simpledateformatclass": {
        "title": "JAVA - SimpleDateFormat, Calendar 클래스",
            "author": "ohoraming",
                "category": "",
                    "content": "      SimpleDateFormat class  import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatTest {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\tSimpleDateFormat dateForm1 = new SimpleDateFormat(\"yyyy년 MM월 dd일 hh시 mm분 ss초\");\t\tSimpleDateFormat dateForm2 = new SimpleDateFormat(\"E요일\");\t\t\t\tSystem.out.println(today);\t\tSystem.out.println(dateForm1.format(today));\t\tSystem.out.println(dateForm2.format(today));\t}}  ConsoleFri Jun 18 16:59:44 KST 20212021년 06월 18일 04시 59분 44초금요일c.f.) 변화되는 시간/날짜는 시스템에서 시간 정보를 얻어오는 Calendar 클래스를 이용함      Calendar class    시스템에서 시간 정보를 얻어 오기 때문에, 반드시 getInstance() 메서드로 생성하기!!  import java.util.Calendar;public class CalendarTest {\tpublic static void main(String[] args) {\t\tCalendar now = Calendar.getInstance(); // 반드시 getInstance() 메서드로 생성!!\t\t\t\tint hour = now.get(Calendar.HOUR);\t\tint min = now.get(Calendar.MINUTE);\t\tint year = now.get(Calendar.YEAR);\t\tint month = now.get(Calendar.MONTH);\t\tint date = now.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"현재 시간은 \" + hour + \"시 \" + min + \"분입니다.\");\t\tSystem.out.println(\"오늘은 \" + year + \"년 \" + month + \"월\" + date + \"일입니다.\");\t\t\t}}  Console현재 시간은 5시 6분입니다.오늘은 2021년 5월18일입니다.  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-simpleDateFormatClass"
    }
    , 
    
    "java-overloadingoverriding": {
        "title": "JAVA - Overloading/Overriding",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding      Overloading    : C언어와는 다르게 JAVA의 경우, 인수의 개수나 종류가 다르면, 같은 이름의 메서드를 정의할 수 있음      public class OverloadTest {      \tpublic static int max(int x, int y)  \t{  \t\tif(x &gt; y) {  \t\t\treturn x;  \t\t} else {  \t\t\treturn y;  \t\t}  \t}    \t  \tpublic static double max(double x, double y)  \t{  \t\tif(x &gt; y) {  \t\t\treturn x;  \t\t} else {  \t\t\treturn y;  \t\t}  \t}      \tpublic static void main(String[] args)   \t{  \t\tint a = 10;  \t\tint b = 20;  \t\tSystem.out.println(max(a, b));    \t\t  \t\tdouble c = 10.5;  \t\tdouble d = 20.5;  \t\tSystem.out.println(max(c, d));  \t}  }        Console2020.5      Overriding    : 참고자료                  Overriding in Java - GeeksforGeeks                    Overloading in Java - GeeksforGeeks              : 다형성(Polymorphism) 의 한 종류 - 클래스로 객체를 생성할 때 호출될 메서드가 결정됨    : 객체 지향 기법의 3요소: 클래스, 상속, 다형성    : 메서드 이름, 매개 변수 동일 (overloading의 경우 매개 변수가 다름)    “Overriding in Java.” GeeksforGeeks. 2021년 6월 28일 수정, 2021년 7월 19일 접속, https://www.geeksforgeeks.org/overriding-in-java/.  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-overloadingOverriding"
    }
    , 
    
    "java-recursivemethodcall": {
        "title": "JAVA - Recursive Method Call [재귀적 메서드 호출]",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overridingpublic class RecursiveCall {\tpublic static int power(int x, int y)\t{\t\tif(y&lt;=0) {\t\t\treturn 1;\t\t} else {\t\t\treturn x * power(x, y-1);\t\t}\t}\t\tpublic static void main(String[] args) \t{\t\tSystem.out.println(\"power(2,1) : \" + power(2,1));\t\tSystem.out.println(\"power(2,2) : \" + power(2,2));\t\tSystem.out.println(\"power(2,3) : \" + power(2,3));\t\tSystem.out.println(\"power(2,4) : \" + power(2,4));\t\tSystem.out.println(\"power(2,5) : \" + power(2,5));\t}}  Consolepower(2,1) : 2power(2,2) : 4power(2,3) : 8power(2,4) : 16power(2,5) : 32      재귀적 메서드 호출(Recursive Call) 은메모리 요구가 크고, 수행 시간이 오래 걸림    예를 들어, 100개의 int형 배열을 포함한 메서드가 자기 자신을 100번 부른다면    int형 4byte * 100개 * 100번 = 40,000byte 의 메모리가 필요함.        이를 반복문(Loop Call) 으로 바꾼다면,    int형 4byte * 100개 = 400byte의 메모리가 필요함      public class LoopCall   {  \tpublic static int power (int x, int y)  \t{  \t\tint sum = 1;    \t\t  \t\twhile(y &gt; 0)  \t\t{  \t\t\tsum *= x;  \t\t\ty--;  \t\t}  \t\treturn sum;  \t}    \t  \tpublic static void main(String[] args)   \t{  \t\tSystem.out.println(\"power(2,1) : \" + power(2,1));  \t\tSystem.out.println(\"power(2,2) : \" + power(2,2));  \t\tSystem.out.println(\"power(2,3) : \" + power(2,3));  \t\tSystem.out.println(\"power(2,4) : \" + power(2,4));  \t\tSystem.out.println(\"power(2,5) : \" + power(2,5));  \t}  }        Consolepower(2,1) : 2power(2,2) : 4power(2,3) : 8power(2,4) : 16power(2,5) : 32  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-recursiveMethodCall"
    }
    , 
    
    "java-callbyvalue": {
        "title": "JAVA - Call by Value",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding인수(argument)로 매개 변수(parameter)를 전달하는 두 가지 방식  인수가 기본 데이터형(primitive type)일 경우 → Call by Value          주어진 값을 복사하여 처리하는 방식      메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않음        Class의 객체(Object)의 경우 → Call by Reference          매게 변수의 원래 주소에 값을 저장하는 방식      메서드의 실행에 따라 인수로 전달한 변수의 값이 영항을 받음⇒ Side effect : 다른 메서드에서 현재 메서드 내의 변수 값을 바꾸는 현상메서드 간 값 전달은 쉽지만, 값이 변화할 경우 심각한 문제 유발 가능성 큼(위험)⇒ 클래스 객체를 인수로 전달하는 경우에만 사용함      public class CallByValueTest {\tpublic static void swap(int x, int y) //x와 y의 값을 바꾸는 메서드\t{\t\tint temp = x;\t\tx = y;\t\ty = temp;\t\tSystem.out.println(\"swap() 메서드 내의 x = \" + x + \", y = \" + y);\t}\tpublic static void main(String[] args)\t{\t\tint a = 10;\t\tint b = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + a + \", \" + b);\t\tswap(a, b);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + a + \", \" + b);\t}}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 내의 x = 20, y = 10swap() 메서드 호출 후: 10, 20  main() 메서드의 a와 b는 swap() 메서드 내의 x와 y에 각각 값이 복사되고, x와 y의 값을 바꿈.하지만 main() 메서드의 a와 b에는 아무 영향을 미치지 않음.  main() 메서드의 a와 b의 값을 바꾸고 싶다면Call by Reference를 사용하거나, a와 b를 전역변수로 선언하여 사용하면 됨public class CallByValueTest2{\tstatic int a; //전역변수로 선언된 a와 b\tstatic int b;\tpublic static void swap() //x와 y의 값을 바꾸는 메서드\t{\t\tint temp = a;\t\ta = b;\t\tb = temp;\t\tSystem.out.println(\"swap() 메서드 내의 x = \" + a+ \", y = \" + b);\t}\tpublic static void main(String[] args)\t{\t\ta = 10;\t\tb = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + a + \", \" + b);\t\tswap();\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + a + \", \" + b);\t}}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 내의 x = 20, y = 10swap() 메서드 호출 후: 20, 10  swap(a, b); 이 아닌 swap(); 으로 호출했기에 값의 전달은 일어나지 않으며, swap() 메서드에서도 인수를 받지 않음하지만, 전역변수로 값을 바로 저장하기 때문에, 전역변수 a와 b를 사용하는 모든 메서드에 영향을 미치게 됨  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-callByValue"
    }
    , 
    
    "java-callbyreference": {
        "title": "JAVA - Call by Reference",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding인수(argument)로 매개 변수(parameter)를 전달하는 두 가지 방식  인수가 기본 데이터형(primitive type)일 경우 → Call by Value          주어진 값을 복사하여 처리하는 방식      메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않음        Class의 객체(Object)의 경우 → Call by Reference          매게 변수의 원래 주소에 값을 저장하는 방식      메서드의 실행에 따라 인수로 전달한 변수의 값이 영항을 받음⇒ Side effect : 다른 메서드에서 현재 메서드 내의 변수 값을 바꾸는 현상메서드 간 값 전달은 쉽지만, 값이 변화할 경우 심각한 문제 유발 가능성 큼(위험)⇒ 클래스 객체를 인수로 전달하는 경우에만 사용함      public class CallByReferenceTest {\tpublic static void swap(Number z)\t{\t\tint temp = z.x;\t\tz.x = z.y;\t\tz.y = temp;\t}\tpublic static void main(String[] args)\t{\t\tNumber n = new Number();\t\tn.x = 10;\t\tn.y = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + n.x + \", \" + n.y);\t\tswap(n);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + n.x + \", \" + n.y);\t}}class Number{\tpublic int x;\tpublic int y;}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 호출 후: 20, 10⇒ 여기서 class Number 는 독립적인 클래스!!⇒ 또는, 하위 클래스로 설정하되, static으로 class Number를 정의하면 됨public class CallByReferenceTest {\tpublic static void swap(Number z)\t{\t\tint temp = z.x;\t\tz.x = z.y;\t\tz.y = temp;\t}\tpublic static void main(String[] args)\t{\t\tNumber n = new Number();\t\tn.x = 13;\t\tn.y = 42;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + n.x + \", \" + n.y);\t\tswap(n);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + n.x + \", \" + n.y);\t}\tstatic class Number\t{\t\tpublic int x;\t\tpublic int y;\t}}  Consoleswap() 메서드 호출 전: 13, 42swap() 메서드 호출 후: 42, 13  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-callByReference"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ohoraming.github.io/">예비 개발자의 노트</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a>
                </section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">예비 개발자의 노트</h1>
            <p class="subscribe-overlay-description">게시글 검색</p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm" />
    <input class="location" type="hidden" name="location" />
    <input class="referrer" type="hidden" name="referrer" />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"
            placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if (event.code == 'Enter') {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function () {
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });
        });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
        </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
    <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>

</html>