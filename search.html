<!DOCTYPE html>
<html>

<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- syntax.css 추가-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- 웹폰트(나눔 고딕) 추가 -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"> -->

    <!-- font awesome 추가 -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
        integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

    <style>
        .hljs {
            background: none;
        }

        /* web font 추가 */
        @font-face {
            font-family: 'MaruBuri-Regular';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-10-21@1.0/MaruBuri-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
    </style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="배움을 기록합니다" />
    <link rel="shortcut icon" href="https://ohoraming.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ohoraming.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="백엔드 개발자의 노트" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="배움을 기록합니다" />
    <meta property="og:url" content="https://ohoraming.github.io/search" />
    <meta property="og:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="배움을 기록합니다" />
    <meta name="twitter:url" content="https://ohoraming.github.io/" />
    <meta name="twitter:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="백엔드 개발자의 노트" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "백엔드 개발자의 노트",
        "logo": "https://ohoraming.github.io/"
    },
    "url": "https://ohoraming.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://ohoraming.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ohoraming.github.io/search"
    },
    "description": "배움을 기록합니다"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />
    <meta name="google-site-verification" content="hZiBNkaKWa99TzuLHfeW-oh-GCAQ4Pienu5nXr3yVF8" />
</head>

<body
    class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
        
        <a class="site-nav-logo" href="https://ohoraming.github.io/">백엔드 개발자의 노트</a>
        
        
        
        <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!-- href: C:\myblog\_data\authors\tags.yml에서 설정한 tag명 tag/다음에 넣음 -->
    <!-- <li class="nav-about" role="menuitem"><a href="https://ohoraming.github.io/my_resume/" target="_blank">Portfolio</a></li> -->
    <!-- <li class="nav-archive" role="menuitem"><a href="/tag/spring/">Spring</a></li> -->
    <li class="nav-archive" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/javascript/">JavaScript</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/os/">OS</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/devops/">DevOps</a></li>
    <li class="nav-archive" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-archive" role="menuitem"><a href="/author_archive.html">All Tags</a></li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
        <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>
    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "algorithm-rotatearr": {
        "title": "배열 회전시키기",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 프로그래머스의 배열 회전시키기의 풀이를 정리한 것입니다.문제 설명정수가 담긴 배열 numbers와 문자열 direction가 매개변수로 주어집니다. 배열 numbers의 원소를 direction방향으로 한 칸씩 회전시킨 배열을 return하도록 solution 함수를 완성해주세요.제한사항  3 ≤ numbers의 길이 ≤ 20  direction은 “left” 와 “right” 둘 중 하나입니다.입출력 예            numbers      direction      result                  [1, 2, 3]      “right”      [3, 1, 2]              [4, 455, 6, 4, -1, 45, 6]      “left”      [455, 6, 4, -1, 45, 6, 4]      입출력 예 설명입출력 예 #1  numbers 가 [1, 2, 3]이고 direction이 “right” 이므로 오른쪽으로 한 칸씩 회전시킨 [3, 1, 2]를 return합니다.입출력 예 #2  numbers 가 [4, 455, 6, 4, -1, 45, 6]이고 direction이 “left” 이므로 왼쪽으로 한 칸씩 회전시킨 [455, 6, 4, -1, 45, 6, 4]를 return합니다.나의 풀이  오른쪽으로 회전한다면,          기존 배열의 마지막 칸을 제외한 나머지를 새 배열에 배치 후      새 배열의 첫 칸에 기존 배열의 마지막 요소를 넣음        왼쪽으로 회전한다면,          기존 배열의 첫 칸을 제외한 나머지를 새 배열에 배치 후      새 배열의 마지막 칸에 기존 배열의 첫 요소를 넣음      class Solution {    public int[] solution(int[] numbers, String direction) {        int[] answer = new int[numbers.length];                // 1.        if (direction.equals(\"right\")) {            for (int i = numbers.length - 2; i &gt;= 0; i--) {                // 기존 배열의 마지막 칸을 제외하고 새 배열에 배치                answer[i + 1] = numbers[i];            }            // 새 배열의 첫 칸 채우기            answer[0] = numbers[numbers.length-1];                // 2.        } else {            for (int i = 0; i &lt; numbers.length -1; i++) {                // 기존 배열의 첫 칸을 제외하고 새 배열에 배치                answer[i] = numbers[i + 1];            }            // 새 배열의 마지막 칸 채우기            answer[numbers.length -1] = numbers[0];        }        return answer;    }}",
        "url": "/algorithm-rotateArr"
    }
    , 
    
    "algorithm-math": {
        "title": "Math 클래스",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 알고리즘 문제를 풀면서 Math와 관련한 메서드를 정리한 것입니다.제곱근      Math.sqrt(): double 타입의 인수를 전달하면 제곱근을 반환      double sqrt(double a)            예시      System.out.println(Math.sqrt(3)); // 1.7320508075688772  System.out.println(Math.sqrt(9)); // 3.0  System.out.println(Math.sqrt(0)); // 0.0  System.out.println(Math.sqrt(-9)); // NaN(Not A Number): 음수 입력시 잘못된 입력임을 나타냄               result          1.7320508075688772  3.0  0.0  NaN      올림/반올림/내림  Math.ceil(): 주어진 값을 올림하여  반환  Math.round(): 소수 첫째 자리에서 반올림한 long 타입의 정수값을 반환      Math.floor(): 주어진 값을 내림하여 반환      double ceil(double a)  long round(double a)  double floor(double a)            예시      double d = 1.234567;  double d2 = 9.8765432;      System.out.println(Math.ceil(d)); // 2.0  System.out.println(Math.ceil(d2)); // 10.0      System.out.println(Math.round(d)); // 1  System.out.println(Math.round(d2)); // 10      System.out.println(Math.floor(d)); // 1.0  System.out.println(Math.floor(d2)); // 9.0              result          2.0  10.0  1  10  1.0  9.0      난수      Math.random(): 0.0 ≤ x &lt;1.0 범위의 double 타입 난수를 반환      double random()        예시: 1≤ x &lt; 3 범위의 난수를 생성                  Math.random() 범위         0.0 &lt;= Math.random() &lt; 1.0                            각 변에 3을 곱함         0.0 * 3 &lt;= Math.random() * 3 &lt; 1.0 * 3                            int로 형변환         (int)0.0 &lt;= (int)(Math.random() * 3) &lt; (int)3.0                            각 변에 1을 더함         1 &lt;= (int)(Math.random() * 3) + 1 &lt; 4                          예시      // 1 &lt;= x &lt; 10 사이 난수  System.out.println((int)(Math.random()*10) + 1); // 9      // 1 &lt;= x &lt; 3 사이 난수  System.out.println((int)(Math.random()*3) + 1); // 1              result          9  1      최댓값/최솟값      Math.max(): 주어진 두 값을 비교하여 큰 쪽을 반환      int max(int a, int b)  double max(double a, double b)  float max(float a, float b)  long max(long a, long b)            Math.min(): 주어진 두 값을 비교하여 작은 쪽을 반환      int min(int a, int b)  double min(double a, double b)  float min(float a, float b)  long min(long a, long b)            예시      // 최댓값  System.out.println(Math.max(7, 2)); // 7  System.out.println(Math.max(-5.2, 3.14)); // 3.14  System.out.println(Math.max(1.4f, 3.14f)); // 3.14  System.out.println(Math.max(123, 100L)); // 123      // 최솟값  System.out.println(Math.min(3, 8)); // 3  System.out.println(Math.min(-1.05, 4.8)); // -1.05  System.out.println(Math.min(2.56f, -2.84f)); // -2.84  System.out.println(Math.min(398L, 077)); // 63              result          7  3.14  3.14  123      3  -1.05  -2.84  63      ",
        "url": "/algorithm-math"
    }
    , 
    
    "algorithm-perfectsquarenumber": {
        "title": "제곱수 판별하기",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 프로그래머스의 제곱수 판별하기의 풀이를 정리한 것입니다.문제 설명어떤 자연수를 제곱했을 때 나오는 정수를 제곱수라고 합니다. 정수 n이 매개변수로 주어질 때, n이 제곱수라면 1을 아니라면 2를 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ n ≤ 1,000,000입출력 예            n      result                  144      1              976      2      입출력 예 설명입출력 예 #1  144는 12의 제곱이므로 제곱수입니다. 따라서 1을 return합니다.입출력 예 #2  976은 제곱수가 아닙니다. 따라서 2를 return합니다.나의 풀이(1)  Math.sqrt(double a): double 값의 양의 제곱근 반환  Math.floor(double a): double 값보다 작거나 같은 정수(내림값) 반환  제곱근과 제곱근의 내림값이 같으면 즉, 제곱근이 양의 정수이면 제곱수임          예시          // 256은 제곱수임  // 256은 제곱근인 16을 제곱한 수  System.out.println(Math.sqrt(256));               // 16.0  System.out.println(Math.floor(Math.sqrt(256)));   // 16.0      // 6은 제곱수가 아님  // 6의 제곱근은 정수가 아님  System.out.println(Math.sqrt(6));                 // 2.449489742783178  System.out.println(Math.floor(Math.sqrt(6)));     // 2.0              result          16.0  16.0  2.449489742783178  2.0      class Solution {    public int solution(int n) {        int answer = 0;                // 제곱근과 제곱근의 내림값이 같으면 제곱수임        if (Math.sqrt(n) == Math.floor(Math.sqrt(n))) answer = 1;        else answer = 2;                return answer;    }}나의 풀이(2)  i값이 1부터 1씩 증가하며, i를 제곱한 값이 n보다 작은  for문  i로 나누어 떨어지고, i로 나눈 몫이 i 인 값을 찾으면 answer를 1로 반환class Solution {    public int solution(int n) {        int answer = 2;                // 1.        for (int i = 1; i*i &lt;= n; i++) {                    // 2.            if ((n % i == 0) &amp;&amp; (n / i == i)) answer = 1;        }                return answer;    }}나의 풀이(3)  제곱근으로 나누어 떨어지는 수인지 판별class Solution {    public int solution(int n) {        int answer = 0;                // 제곱근으로 나누어 떨어지는 수는 제곱수        if (n % Math.sqrt(n) == 0) answer = 1;        else answer = 2;                return answer;    }}",
        "url": "/algorithm-perfectSquareNumber"
    }
    , 
    
    "algorithm-changeindex": {
        "title": "인덱스 바꾸기",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 프로그래머스의 인덱스 바꾸기의 풀이를 정리한 것입니다.문제 설명문자열 my_string과 정수 num1, num2가 매개변수로 주어질 때, my_string에서 인덱스 num1과 인덱스 num2에 해당하는 문자를 바꾼 문자열을 return 하도록 solution 함수를 완성해보세요.제한사항  1 &lt; my_string의 길이 &lt; 100  0 ≤ num1, num2 &lt; my_string의 길이  my_string은 소문자로 이루어져 있습니다.  num1 ≠ num2입출력 예            my_string      num1      num2      result                  “hello”      1      2      “hlelo”              “I love you”      3      6      “I l veoyou”      입출력 예 설명입출력 예 #1  “hello”의 1번째 인덱스인 “e”와 2번째 인덱스인 “l”을 바꾸면 “hlelo”입니다.입출력 예 #2  “I love you”의 3번째 인덱스 “o”와 “ “(공백)을 바꾸면 “I l veoyou”입니다.나의 풀이(1)  StringBuilder 사용  setCharAt(int index, char ch): index의 문자를 ch 문자로 변경  toString(): StringBuilder 출력class Solution {    public String solution(String my_string, int num1, int num2) {        String answer = \"\";                StringBuilder sb = new StringBuilder(my_string);        sb.setCharAt(num1, my_string.charAt(num2));        sb.setCharAt(num2, my_string.charAt(num1));                answer = sb.toString();                return answer;    }}나의 풀이(2)  문자열.split(): 문자열 자르기  tmp 변수를 사용해 num1과 num2 인덱스의 문자 교환      String.join(CharSequence delimiter, CharSequence... elements):  배열을 문자열로 전환      class Solution {      public String solution(String my_string, int num1, int num2) {          String answer = \"\";                      String[] arr = my_string.split(\"\");          String tmp = arr[num1];          arr[num1] = arr[num2];          arr[num2] = tmp;              answer = String.join(\"\", arr);                      return answer;      }  }      나의 풀이(3)      substring(int beginIndex, int endIndex): beginIndex부터 endIndex-1 까지의 문자를 반환      class Solution {      public String solution(String my_string, int num1, int num2) {          String answer = \"\";                      answer = my_string.substring(0, num1) + my_string.charAt(num2)                  + my_string.substring(num1 + 1, num2) + my_string.charAt(num1)                  + my_string.substring(num2 + 1);                      return answer;      }  }      ",
        "url": "/algorithm-changeIndex"
    }
    , 
    
    "algorithm-sortingstring": {
        "title": "문자열 정렬하기",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 프로그래머스의 문자열 정렬하기 (2)의 풀이를 정리한 것입니다.문제 설명영어 대소문자로 이루어진 문자열 my_string이 매개변수로 주어질 때, my_string을 모두 소문자로 바꾸고 알파벳 순서대로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요.제한사항  0 &lt; my_string 길이 &lt; 100입출력 예            my_string      result                  “Bcad”      “abcd”              “heLLo”      “ehllo”              “Python”      “hnopty”      입출력 예 설명입출력 예 #1  “Bcad”를 모두 소문자로 바꾸면 “bcad”이고 이를 알파벳 순으로 정렬하면 “abcd”입니다.입출력 예 #2  “heLLo”를 모두 소문자로 바꾸면 “hello”이고 이를 알파벳 순으로 정렬하면 “ehllo”입니다.입출력 예 #3  “Python”를 모두 소문자로 바꾸면 “python”이고 이를 알파벳 순으로 정렬하면 “hnopty”입니다.나의 풀이  문자열.toLowerCase(): 문자열(String)을 소문자로 변환  문자열.toCharArray(): 문자열(String)을 문자 배열(char[]) 로 변환  Arrays.sort(): 문자 배열(char[]) 오름 차순 정렬  String.valueOf(): 문자 배열(char[])을 문자열로 변환import java.util.Arrays;class Solution {    public int solution(String my_string) {        String answer = \"\";\t// 1.        answer = my_string.toLowerCase();\t// 2.        char[] ch = answer.toCharArray();\t// 3.        Arrays.sort(ch);\t// 4.        answer = String.valueOf(ch);                    return answer;    }}",
        "url": "/algorithm-sortingString"
    }
    , 
    
    "spring-none": {
        "title": "restTemplate",
            "author": "ohoraming",
                "category": "",
                    "content": "Spring 관련 포스팅              이 글은 를 정리한 것입니다.&lt; 출처 &gt;  ‘Amazon RDS | Deploy Spring Boot + MySQL CRUD Application into Elastic Beanstalk | JavaTechie,’ 유튜브 비디오, 14:39, 게시자 ‘Java Techie,’ 2020년07월19일, https://youtu.be/Tbf7F42tcBw  ‘Spring Boot AWS Deployment - Full Course,’ 유튜브 비디오, 1:03:19, 게시자 ‘Java Guides,’ 2021년05월01일, https://youtu.be/D1yOALZcMHs",
        "url": "/spring-none"
    }
    , 
    
    "algorithm-string": {
        "title": "String",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 알고리즘 문제를 풀면서 String과 관련한 메서드를 정리한 것입니다.역순 출력  for 문 구조 for (변수 초기값; 변수 조건문; 변수의 증감식)  기존에 익숙했던 패턴인 for (int i = 0; i &lt; 배열.length; i++)을 수정      for (int i = my_string.length() - 1; i &gt;= 0; i--)    → i 초기 값은 my_string.length() - 1로 시작하며, i가 0 보다 클 때, i 값은 1씩 감소함    charAt(index)으로 문자열의 index에 해당하는 문자 반환      예시      String my_string = \"bread\";  String result = \"\";      // for문 구조 수정  for (int i = my_string.length() - 1; i &gt;= 0; i--) {   \t\tresult += my_string.charAt(i);  }      System.out.println(result);              result          daerb      배수 번째의 문자 출력  for문 구조를 이용해 if문의 조건을 대신함      code 번째를 나타내는 조건문 if (i % code == 0)를    for문으로  for (int i = code; i &lt;= cipher.length(); i += code) 바꾸어 나타내면 간략해짐    → i 초기 값은 code로 시작하며, 문자열의 길이만큼 반복문을 돌며, i 값은 code만큼 더해짐    예시: 문자열(cipher)의 배수(code) 번째 문자만 골라서 출력하는 코드          for문 구조 변경 전 코드          String cipher = \"dfjardstddetckdaccccdegk\";  int code = 4;  String result = \"\";      for (int i = 1; i &lt; cipher.length() + 1; i++) { // for문 구조 변경 전      if (i % code == 0) {                        // if문 필요          result += cipher.charAt(i - 1);      }  }  System.out.println(\"result = \" + result);                  result          result = attack                  for문 구조 변경 후 코드          String cipher = \"dfjardstddetckdaccccdegk\";  int code = 4;  String result = \"\";      for (int i = code; i &lt;= cipher.length(); i += code) { // for문 구조 변경 후      result += cipher.charAt(i - 1);                   // if문 불필요   }  System.out.println(\"result = \" + result);              result          result = attack      변수 타입 확인  객체의 경우, getClass().getSimpleName()으로 타입을 확인  primitive type의 경우, Object로 형변환을 한 뒤 getClass().getSimpleName()으로 타입을 확인      예시      int num = 29183;  String str = \"cake\";  int[] numArr = {8, 7, 6, 5};  String[] numStrArr = {\"Apple\", \"Banana\", \"Car\"};      System.out.println(((Object)num).getClass().getSimpleName()); // Integer  System.out.println(str.getClass().getSimpleName());           // String  System.out.println(numArr.getClass().getSimpleName());        // int[]  System.out.println(numStrArr.getClass().getSimpleName());     // String[]                  result          Integer  String  int[]  String[]      char[]을 String으로 변환      String 생성자 이용    : char[]를 인자로 받아 내부적으로 String.valueOf()를 호출함                  예시          char[] ch = {'m', 'i', 'n', 'g'};  String str = new String(ch);          System.out.println(str);                          result                  ming                      String.valueOf()          예시         char[] ch = {'c', 'h', 'e', 'r', 'r', 'y'}; String str = String.valueOf(ch);     System.out.println(str);              result         cherry        StringBuilder 인스턴스 생성 후 append() 메서드 사용          예시         char[] ch = {'b', 'l', 'o', 's', 's', 'o', 'm'}; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; ch.length; i++) {     sb.append(ch[i]); }     System.out.println(sb);              result         blossom      String[]을 String으로 변환  String.join(구분자, 배열)      예시      String[] str_arr = {\"apple\", \"banana\", \"cherry\"};      String str_result = String.join(\"-\", str_arr);      System.out.println(str_result); // apple-banana-cherry              result          apple-banana-cherry      기본형을 String으로 변환  String.valueOf()을 이용해 boolean, char, int, long, float, double을 String으로 변환  getClass().getSimpleName() 으로 타입 확인      예시      boolean bool = true;  char ch = 'c';  int in = 101;  long l = 100L;  float f = 3.14f;  double d = 1.23;      String bool_str = String.valueOf(bool); // String  String ch_str = String.valueOf(ch); // String  String in_str = String.valueOf(in); // String  String l_str = String.valueOf(l); // String  String f_str = String.valueOf(f); // String  String d_str = String.valueOf(d); // String      System.out.println(bool_str.getClass().getSimpleName()); // String              result          String      String을 char[]로 변환  문자열.toCharArray()      예시      String str = \"Spring\";      char[] chArr = str.toCharArray(); // String -&gt; char[]      System.out.println(Arrays.toString(chArr));              result          [S, p, r, i, n, g]      대/소문자 변환  toUpperCase(), toLowerCase()      예시      String my_string = \"abCdEfghIJ\";      System.out.println(my_string.toUpperCase()); // ABCDEFGHIJ  System.out.println(my_string.toLowerCase()); // abcdefghij              result          ABCDEFGHIJ  abcdefghij      문자 위치 찾기      문자열.indexOf(): 문자열에서 해당 문자의 첫 등장 위치 반환      int indexOf(String str) // str: 찾을 문자열  int indexOf(String str, int fromIndex) // str: 찾을 문자열, fromIndex: 시작 인덱스             예시: 처음 등장하는 문자만 반환하기      String my_string = \"We are the world\";  String answer = \"\";      for (int i = 0; i &lt; my_string.length(); i++) {      if (my_string.indexOf(my_string.charAt(i)) == i) answer += my_string.charAt(i);  }  System.out.println(answer);              result          We arthwold      문자 포함 여부      주어진 문자열.contains(찾는 문자열): 주어진 문자열에서 특정 문자열의 포함 여부(true/false)를 반환      boolean contains(CharSequence s) // s: 찾을 문자열            예시      String str1 = \"ab6CDE443fgh22iJKlmn1o\";  String str2 = \"6CD\";      System.out.println(str1.contains(str2)); // true      String str3 = \"ppprrrogrammers\";  String str2 = \"pppp\";      System.out.println(str3.contains(str4)); // false              result          true  false      문자 치환      문자열.replaceAll(타겟의 정규식, 교체될 문자열): 반환      String replaceAll(String regex, String replacement)            예시-1) 문자열 \"one\", \"six\", \"seven\"을 \"1\", \"6\", \"7\" 로 교체하기      String numbers = \"onefourzerosixseven\";  answer = numbers.replaceAll(\"one\", \"1\")                  .replaceAll(\"six\", \"6\")                  .replace(\"seven\", \"7\");      System.out.println(answer);              result          1fourzero67            예시-2) 주어진 문자열에서 모음 'a', 'i', 'u', 'e', 'o'  제거하기      String my_string = \"nice to meet you\";  String answer = \"\";      answer = my_string.replaceAll(\"[aiueo]\", \"\");  System.out.println(answer);              result          nc t mt y      ",
        "url": "/algorithm-string"
    }
    , 
    
    "algorithm-numofk": {
        "title": "k의 개수 구하기",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 프로그래머스의 k의 개수 문제의 풀이를 정리한 것입니다.문제 설명1부터 13까지의 수에서, 1은 1, 10, 11, 12, 13 이렇게 총 6번 등장합니다. 정수 i, j, k가 매개변수로 주어질 때, i부터 j까지 k가 몇 번 등장하는지 return 하도록 solution 함수를 완성해주세요.제한사항  1 ≤ i &lt; j ≤ 100,000  0 ≤ k ≤ 9입출력 예            i      j      k      result                  1      13      1      6              10      50      5      5              3      10      2      0      입출력 예 설명입출력 예 #1  본문과 동일합니다.입출력 예 #2  10부터 50까지 5는 15, 25, 35, 45, 50 총 5번 등장합니다. 따라서 5를 return 합니다.입출력 예 #3  3부터 10까지 2는 한 번도 등장하지 않으므로 0을 return 합니다.나의 풀이(1)  주어진 숫자를 하나씩 돌면서 비교  주어진 숫자를 tmp변수에 넣고      tmp를 10으로 나눈 나머지가 k이면 answer를 1증가시킴    → 이는 tmp의 일의 자리 숫자에 있는 k를 가리킴        tmp의 일의 자리 숫자 비교가 끝났으니 다음 자리(십의 자리) 숫자를 비교함    → 다음 자리 숫자가 없으면 10으로 나눈 몫은 0이 됨        다음 자리 숫자가 있을 때까지 비교    → 다음 자리 숫자가 있으면 10으로 나눈 몫이 0이 아님  class Solution {    public int solution(int i, int j, int k) {        int answer = 0;        // 1.        for (int num = i; num &lt;= j ; num++) {\t// 2.            int tmp = num;\t// 5.            while(tmp != 0) {\t\t// 3.                if (tmp % 10 == k) answer++;                \t\t// 4.                tmp /= 10;            }        }                    return answer;    }}나의 풀이(2)  주어진 숫자를 하나씩 돌면서 비교  해당 숫자(int)를 String으로 변환      변환한 문자열을 한 글자씩 돌면서 비교    3-1. int인 k를 char(k_char)로 형변환    3-2. 해당 문자열에 k_char가 존재하는 수만큼 answer 증가  class Solution {    public int solution(int i, int j, int k) {        int answer = 0;        \t// 1.        for (int a = i; a &lt;= j; a++) {\t    // 2.            String num = String.valueOf(a);            \t// 3.            for (int b = 0; b &lt; num.length(); b++) {\t\t// 3-1.                char k_char = (char)(k + '0');                \t\t// 3-2.                if (num.charAt(b) == k_char) answer++;            }        }}",
        "url": "/algorithm-numOfK"
    }
    , 
    
    "algorithm-mode": {
        "title": "최빈값 구하기",
            "author": "ohoraming",
                "category": "",
                    "content": "Algorithm 관련 포스팅    최빈값 구하기    k의 개수 구하기    String    문자열 정렬하기    인덱스 바꾸기    제곱수 판별하기    Math    배열 회전시키기          이 글은 프로그래머스의 최빈값 문제의 풀이를 정리한 것입니다.문제 설명최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다.제한사항  0 &lt; array의 길이 &lt; 100  0 ≤ array의 원소 &lt; 1000입출력 예            array      result                  [1, 2, 3, 3, 3, 4]      3              [1, 1, 2, 2]      -1              [1]      1      입출력 예 설명입출력 예 #1  [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다.입출력 예 #2  [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다.입출력 예 #3  [1]에는 1만 있으므로 최빈값은 1입니다.나의 풀이  배열(array) 내 최댓값 구하기: array_max      최댓값 + 1 크기의 배열 생성: frq    → 배열(array)의 원소는 0부터 시작하기 때문에 +1을 해주어야 함        배열(array)을 돌면서 frq배열에 빈도를 1씩 더하며 기록     // 처음에 주어진 배열: array int[] array = {1, 2, 3, 3, 3, 4}      // 빈도를 기록한 배열: frq // 순서대로 0, 1, 2, 3, 4의 빈도를 나타냄 int[] frq = {0, 1, 1, 3, 1}        빈도를 기록한 배열(frq)에서 최댓값(frq_max)을 구해 해당 index(i)를 최빈값(answer)으로 반환      문제에서 최빈값이 여러 개이면, -1을 반환하라는 조건이 있음    5-1.  frq배열에서 최댓값(frq_max)과 같은 원소가  몇 개 있는지 확인    5-2. 둘 이상이면 최빈값이 여러 개이므로 answer을 -1로 반환  class Solution {    public int solution(int[] array) {        int answer = 0;         int array_max = 0; // 입력받은 배열의 최대값        int frq_max = 0; // 빈도담은 배열의 최대값        int frq_max_cnt = 0; // 최빈값의 개수\t// 1.        for (int i = 0; i &lt; array.length; i++) {            if (array[i] &gt; array_max) array_max = array[i];        }        // 2.        int[] frq = new int[array_max + 1];\t// 3.        for (int i = 0; i &lt; array.length; i++) {            frq[array[i]] += 1;        }\t// 4.        for (int i = 0; i &lt; frq.length; i++) {            if(frq[i] &gt; frq_max) {                frq_max = frq[i];                answer = i;            }        }\t// 5-1.        for (int i = 0; i &lt; frq.length; i++) {            if (frq[i] == frq_max) frq_max_cnt ++;        }\t// 5-2.        if (frq_max_cnt &gt; 1) answer = -1;                    return answer;    }}",
        "url": "/algorithm-mode"
    }
    , 
    
    "docker-basic": {
        "title": "Docker - 설치 및 실행",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          이 글은 https://www.youtube.com/playlist?list=PL93mKxaRDidGMzIllhYKx1d6aMg6_5wW3 영상을 정리한 것입니다.0. 개요      커널 부분을 확대해 보면, host 운영체제인 windows의 cmd창으로 명령어를 입력하면 docker server가 container에 명령을 하는 형식으로 작동        container: image가 실행되어(=메모리에 올라감) instance 가 된 상태를 이름    1. Docker 데스크탑 버전 설치(windows)      https://www.docker.com/products/docker-desktop/ 접속                바탕화면에서 Docker Desktop 실행         명령어 복사 후 cmd에서 실행              현재 실행 중인 컨테이너 확인         브라우저에 localhost 입력해 첫 화면 확인          docker images 명령어로 이미지 확인         회원 가입 및 로그인   2. Docker image 다운로드      docker hub에서 다운 받을 image 검색         최신 버전을 받으려면 바로 보이는 명령어를 복사해 입력하고, 특정 버전을 다운로드하려면 Tags를 클릭                    cmd에서 명령어 입력                              cmd에서 명령어 입력                다운받은 image 확인     $ docker images            image 삭제     # image 이름으로 삭제 $ docker rmi ubuntu\t # image ID(앞부분만 입력해도 됨)로 삭제 $ docker rmi b89f          3. Daemon process로 실행      docker pull openjdk 실행으로 openjdk 이미지 다운로드 후 docker run 으로 실행하면 실행 중인 컨테이너(docker ps)에 없음               openjdk는 daemon이 아니므로 container가 실행 후 바로 종료됨            -d 옵션으로 백그라운드 실행    4. 포트 포워딩(port forwarding)      Host OS(Windows)에 nginx와 apache를 포트포워딩한 형태        Host OS(Windows)에 nginx(Linux)와 apache(Linux)를 포트포워딩한 형태→ 여러 운영체제를 이용하는 형태        docker pull httpd 실행으로 httpd이미지 다운로드          httpd의 d는 daemon process의 d를 의미함                    docker run -d httpd으로 httpd 이미지 실행     브라우저에서 localhost:8080 으로 접속 불가              docker container는 host os와 다른 네트워크 구성을 가지므로 포트포워딩의 과정이 필요함              image를 실행(run)할 때 -p 옵션을 부여해줌           브라우저에서 localhost:8080 으로 접속 가능       5. docker run  docker run명령어로 이미지 다운로드(pull)와 실행(run)을 동시에 진행          이미지 다운로드(pull)와 실행(run)을 동시에 실행 가능      다운 받지 않은 이미지를 실행하려고 하면 docker hub에서 찾아 실행해줌    → 8080포트는 httpd가 사용 중이므로 8081포트로 포트 포워딩 해줌                  브라우저에서 localhost:8081 실행 가능                            -dit, -name 옵션 사용               -d: 백그라운드에서 실행      -i: interactive, -t: Pseudo-tty : bash를 통해 입출력      --name: container 이름 지정      bash프로그램을 ubuntu 내에 설치한 상태의 이미지를 실행하므로 컨테이너가 실행된 상태를 유지할 수 있음 (bash, sh, zsh, Power Shell 등 여러 종류가 존재함)            docker run -d ubuntu 로 실행시 컨테이너가 바로 종료됨           운영 체제만 있는 상태에서 어떤 프로그램도 설치되어있지 않은 이미지를 실행시키면 컨테이너는 바로 종료됨      이전에 httpd는 운영체제 안에 apache가 설치된 이미지였기때문에 컨테이너가 실행된 상태로 유지될 수 있었음        docker attach 로 컨테이너 접속   Docker를 공부하는 과정에서 작성한 포스트입니다.이제 막 Docker를 접하시는 분들에게 도움이 되었으면 좋겠습니다!&lt; 출처 &gt;  ‘도커입문 1강~9강,’ 유튜브 비디오, 게시자 ‘메타코딩,’ 2023년01월24일~2023년02월12일, https://youtube.com/playlist?list=PL93mKxaRDidGMzIllhYKx1d6aMg6_5wW3  ‘왕초보도 따라하는 도커 기초 강의 7 도커의 유용한 명령어,’ 유튜브 비디오, 13:05, 게시자 ‘재즐보프,’ 2020년01월31일, https://youtu.be/QLhpCbnoQkc",
        "url": "/docker-basic"
    }
    , 
    
    "aws-deploy-elastic-beanstalk": {
        "title": "AWS 배포하기(2) - Elastic Beanstalk",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          이 시리즈의1편에서는, RDS로 MySQL DB를 등록하고2편에서는, Elastic Beanstalk으로 JAR 파일을 배포하는 과정을 기록했습니다.전체 소스 코드는 https://github.com/ohoraming/springboot-aws-deployment 이곳을 참고하시기 바랍니다.2. Elastick Beanstalk      Elastic beanstalk 선택         Create Application 선택         웹 앱 생성(Create a web app) 폼 작성 3-1. [애플리케이션 정보] - 애플리케이션 이름(Application name) 작성     3-2. [플랫폼(Platform)] - Java 선택     3-3. [애플리케이션 코드(Application code)] - 코드 업로드(Upload your code) 선택     3-4. [소스 코드 오리진(Source code origin)] - 파일 선택(Choose file) 선택     3-5. 이전에 생성한 JAR 파일 선택           프로젝트 경로에서 target 디렉터리에 있음                추가 옵션 구성(Configure more options) 선택     4-1. [데이터베이스(Database)] - 편집(Edit) 선택     4-2. [데이터베이스 설정] - 사용자 이름(Username)과 암호(Password) 입력 후 저장         앱 생성(Create app) 선택           앱 생성 중      필자의 경우, 이 과정이 10분 이상 걸렸다. 충분한 여유를 가지고 진행하는 것이 좋다.             앱 생성 완료 및 링크 클릭           정상적으로 첫 페이지가 로드됨             구현한 GET/POST/PUT/DELETE 작동 확인하기 7-1. Postman으로 확인     7-2. MySQL에서 Data 확인          MySQL Workbench를 이용하는 것이 편하다면 편한 방법을 이용하면 된다.          mysql&gt; select * from users;  +----+----------------+------------+-----------+  | id | email          | first_name | last_name |  +----+----------------+------------+-----------+  |  1 | ming@gmail.com | Ming       | Kim       |  +----+----------------+------------+-----------+  1 row in set (0.15 sec)                      7-3. Browser에서 확인          연결된 주소에 이어서 get mapping 주소를 적어서 확인      필자는 /api/users로 get mapping을 구성했음                  소스코드 일부 참고          @RestController  @RequestMapping(\"/api/users\")  public class UserController {      @Autowired      private UserRepository userRepository;      // get all users      @GetMapping      public List&lt;User&gt; getAllUsers() {              return this.userRepository.findAll();      }  }                      7-4. 같은 방법으로 PUT과 DELETE 요청을 추가로 확인하면 됨    두 편으로 구성된 AWS 배포 과정이 마무리되었습니다. 간단해 보이지만 AWS 설정 항목에 익숙하지 않아 생기는 실수로 몇 번의 시행착오를 겪었습니다.과정을 꼼꼼하게 남기며 쉽게 기술하도록 노력했습니다.같은 과정을 검색하시는 분들에게 미약하게나마 저의 글이 도움이 되었으면 좋겠습니다!&lt; 출처 &gt;  ‘Amazon RDS | Deploy Spring Boot + MySQL CRUD Application into Elastic Beanstalk | JavaTechie,’ 유튜브 비디오, 14:39, 게시자 ‘Java Techie,’ 2020년07월19일, https://youtu.be/Tbf7F42tcBw  ‘Spring Boot AWS Deployment - Full Course,’ 유튜브 비디오, 1:03:19, 게시자 ‘Java Guides,’ 2021년05월01일, https://youtu.be/D1yOALZcMHs",
        "url": "/aws-deploy-elastic-beanstalk"
    }
    , 
    
    "aws-deploy-rds": {
        "title": "AWS 배포하기(1) - RDS (MySQL)",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          이 시리즈의1편에서는, RDS로 MySQL DB를 등록하고2편에서는, Elastic Beanstalk으로 JAR 파일을 배포하는 과정을 기록했습니다.전체 소스 코드는 https://github.com/ohoraming/springboot-aws-deployment 이곳을 참고하시기 바랍니다.1. RDS      RDS 선택         데이터베이스 생성(Create database) 선택          데이터베이스 생성 3-1. [데이터베이스 생성 방식 선택(Choose a database creation method)] - 표준 생성(Standard create) 선택    3-2. [엔진 옵션(Engine options)] - 엔진 유형(Engine type): MySQL 선택      3-3. [템플릿(Templates)] - 프리 티어(Free tier) 선택          학습용으로 비용이 발생하지 않음         3-4. [설정(Settings)]          DB 인스턴스 식별자, DB 마스터 이름, 마스터 암호 입력         3-5. [인스턴스 구성(DB instance class)]          db.t2.micro 선택         3-6. [스토리지(Storage)]          기본 설정으로 두기       스토리지 자동 조정 활성화 체크 해제 했음        3-7. [연결(Connectivity)]          기본 설정으로 진행      퍼블릭 액세스(Public access): Yes 선택         3-8. [추가 구성(Additional configuration)]          초기 데이터베이스 이름(Initial database name) 입력         3-9. 데이터베이스 생성(Create database) 선택                   데이터베이스 생성 중                     데이터베이스 생성 성공                   보안 그룹 인바운드 규칙 수정    4-1. DB 식별자(DB identifier) 선택     4-2. VPC 보안 그룹(VPC security groups) 선택     4-3. 보안 그룹 ID(Security group ID) 선택     4-4. 인바운드 규칙 편집(Edit inbound rules) 선택     4-5. 규칙 추가(Add rule) 선택     4-6. MYSQL/Aurora 선택, Anywhere-IPv4 선택 후 규칙 저장(Save rules) 선택             MySQL 연결하기    5-1. 엔드포인트(Endpoint)를 복사     5-2. command line에 입력          windows 사용자의 경우,          winpty mysql -h [엔드포인트] -P 3306 -u [마스터 사용자] -p                ※ 참고 ※ 다음 링크에 MySQL Workbench를 사용하는 방법도 있으니 편한 방법으로 연결하면 된다. MySQL 명령줄 클라이언트에서 연결            mysql&gt; 프롬프트가 정상적으로 출력된다면 성공!         5-3. application.properties 파일 수정          spring.datasource.url 의 localhost 부분을 엔드포인트(Endpoint)로 교체         spring.datasource.url = jdbc:mysql://[엔드포인트]:3306/[DB이름]?useSSL=false                    server.port 속성 추가         server.port = 5000                      DB생성                  create database [DB 이름];          mysql&gt; create database usersDB;  Query OK, 1 row affected (0.05 sec)  mysql&gt; show databases;  +--------------------+  | Database           |  +--------------------+  | information_schema |  | mysql              |  | performance_schema |  | sys                |  | usersDB            |  +--------------------+  5 rows in set (0.02 sec)                          Spring boot application을 JAR파일로 패키징    7-1. 소스 코드가 있는 디렉터리에서 cmd 실행(디렉터리 표시 창에서 cmd 입력) 또는 git bash 열기    7-2. mvn clean install 입력    7-3. BUILD SUCCESS 가 출력되면 target폴더에서 JAR 파일을 확인할 수 있음         7-4. 만약, BUILD FAILIURE가 뜬다면?           Fatal error compiling: error: invalid target release: 17 -&gt; [Help 1]      내 경우는 mvn 버전(11)과 프로젝트의 java 버전(17)이 일치하지 않아 오류가 발생했다.      version 확인 명령어          mvn -version   java -version                                환경변수 편집으로 maven 의 java version 수정하기                  [시스템 환경 변수 편집] - [환경 변수] -  시스템 변수의 JAVA_HOME 선택 - [편집]          변경할 java version의 jdk가 저장된 위치를 복사해 변수값에 붙임 - [확인]                                                                  cmd에서 version 재확인 후 BUILD 재실행하기                    &lt; 출처 &gt;  ‘Amazon RDS | Deploy Spring Boot + MySQL CRUD Application into Elastic Beanstalk | JavaTechie,’ 유튜브 비디오, 14:39, 게시자 ‘Java Techie,’ 2020년07월19일, https://youtu.be/Tbf7F42tcBw  ‘Spring Boot AWS Deployment - Full Course,’ 유튜브 비디오, 1:03:19, 게시자 ‘Java Guides,’ 2021년05월01일, https://youtu.be/D1yOALZcMHs",
        "url": "/aws-deploy-RDS"
    }
    , 
    
    "postgresql": {
        "title": "postgreSQL 기본 사용법 [update 中]",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          이 글은 postgreSQL의 기본적인 사용법에 대해 다루고 있습니다.0. SQL Shell 사용하기  cmd에서 psql 명령으로 postgreSQL 접속하기  psql --version 명령이 실행되지 않는다면, 환경 변수 설정이 선행되어야 함          [환경 변수] - [시스템 변수: Path]선택 - 확인 - 새로 만들기 - 찾아보기 - C:\\Program Files\\PostgreSQL\\14\\bin 선택 - 확인- 확인 - cmd 종료 후 재실행        psql 실행  psql -U postgres 실행으로 user 암호 입력하기1. CREATE DATABASE  \\l명령으로 database 목록 확인  SQL syntax는 대문자로 입력하며 명령의 끝은 세미콜론(;)으로 끝맺어야 실행됨    CREATE DATABASE test;        \\l명령으로 database가 생성되었는지 확인                                 데이터베이스 목록  이름     |  소유주  | 인코딩 |    Collate     |     Ctype      |   액세스 권한-------------+----------+-------+----------------+----------------+-----------------test         | postgres | UTF8  |Korean_Korea.949|Korean_Korea.949|        \\c + db 이름으로 생성된 database에 연결하기(connect)    \\c test        접속정보: 데이터베이스=\"test\", 사용자=\"postgres\".      2. CREATE TABLE  datatype에 익숙해지기datatype 목록  입력    CREATE TABLE person (     id BIGSERIAL NOT NULL PRIMARY KEY,     first_name VARCHAR(50) NOT NULL,     last_name VARCHAR(50) NOT NULL,     gender VARCHAR(7) NOT NULL,     date_of_birth DATE NOT NULL,     email VARCHAR(150) );        CREATE TABLE        \\d 명령으로 테이블 확인          릴레이션(relation) 목록 스키마 |     이름      |  종류  |  소유주--------+---------------+--------+---------- public | person        | 테이블 | postgres public | person_id_seq | 시퀀스 | postgres(2개 행)        ※ BIGSERIAL (autoincrementing eight-byte integer) 때문에 person_id_seq 테이블이 생성됨    \\dt 명령으로 실제 테이블 확인    릴레이션(relation) 목록 스키마 |  이름  |  종류  |  소유주--------+--------+--------+---------- public | person | 테이블 | postgres(1개 행)        \\d + table 이름으로 해당 테이블 확인    \"public.person\" 테이블 필드명     |          종류          | Collation | NULL허용 |               초기값---------------+------------------------+-----------+----------+------------------------------------ id            | bigint                 |           | not null | nextval('person_id_seq'::regclass) first_name    | character varying(50)  |           | not null | last_name     | character varying(50)  |           | not null | gender        | character varying(7)   |           | not null | date_of_birth | date                   |           | not null | email         | character varying(150) |           |          |인덱스들: \"person_pkey\" PRIMARY KEY, btree (id)      3. INSERT INTO  data 입력하기    INSERT INTO person (first_name, last_name, gender, date_of_birth)VALUES ('Anne', 'Smith', 'FEMALE', date '1988-01-09');        sql 파일로 data 입력하기    \\i [download한 file의 경로]        ※ 해당 파일이 있는 곳에서 bash를 열어 pwd 명령을 이용하면 경로를 확인할 수 있음    \\i Downloads/person.sql      4. SELECT4-1. ASC/DESC  person 테이블의 id, first_name, country_of_birth를 country_of_birth의 오름차순(ASC)으로 정렬      SELECT id, first_name, country_of_birth   FROM person   ORDER BY country_of_birth ASC;          id  |   first_name   |         country_of_birth  -----+----------------+----------------------------------  316 | Gasper         | Afghanistan  613 | Mohandis       | Afghanistan  753 | Vevay          | Afghanistan   23 | Jodee          | Afghanistan  259 | Killian        | Afghanistan  641 | Jereme         | Afghanistan  529 | Finley         | Albania  346 | Leanna         | Albania  426 | Robinetta      | Albania  806 | Haskel         | Angola  666 | Devondra       | Argentina              person 테이블의 country_of_birth를 중복 없이(DISTINCT) 내림차순(DESC)으로 정렬          SELECT DISTINCT country_of_birth   FROM person   ORDER BY country_of_birth DESC;                  country_of_birth  -----------------  Afghanistan  Albania  ...  Yemen  Zambia                    4-2. WHERE 조건절  gender = 'Female'인 column(id, first_name, gender, country_of_birth)      SELECT id, first_name, gender, country_of_birth   FROM person   WHERE gender = 'Female';          id  |   first_name   | gender |         country_of_birth  -----+----------------+--------+----------------------------------      7 | Oona           | Female | Indonesia      8 | Colline        | Female | China   13 | Willyt         | Female | China   14 | Marice         | Female | Poland                                                  ...      4-3. WHERE … AND … 조건절  gender = 'Female'이고(AND), country_of_birth = 'Poland'인 조건      SELECT id, first_name, gender, country_of_birth   FROM person   WHERE gender = 'Female' AND country_of_birth = 'Poland';          id  | first_name | gender | country_of_birth  -----+------------+--------+------------------   14 | Marice     | Female | Poland   49 | Elisabeth  | Female | Poland   62 | Aurlie     | Female | Poland  474 | Sallie     | Female | Poland  535 | Larine     | Female | Poland  611 | Asia       | Female | Poland      4-4. WHERE … AND …( ~ OR ~) 조건절  gender = 'Female'이고(AND),    country_of_birth = 'Poland' 이거나(OR) country_of_birth = 'China'인 조건      SELECT id, first_name, gender, country_of_birth   FROM person   WHERE gender = 'Female' AND (country_of_birth = 'Poland' OR country_of_birth = 'China');          id  | first_name | gender | country_of_birth  -----+------------+--------+------------------       8 | Colline    | Female | China      13 | Willyt     | Female | China      14 | Marice     | Female | Poland      37 | Bari       | Female | China      46 | Bobine     | Female | China      49 | Elisabeth  | Female | Poland                                  ...        gender = 'Female'이고(AND),  country_of_birth = 'Poland' 이거나(OR) country_of_birth = 'China' 이며(AND),  last_name = 'Quest'인 조건      SELECT id, first_name, last_name, gender, country_of_birth   FROM person   WHERE gender = 'Female' AND (country_of_birth = 'Poland' OR country_of_birth = 'China') AND last_name = 'Quest';          id | first_name | last_name | gender | country_of_birth  ----+------------+-----------+--------+------------------  14 | Marice     | Quest     | Female | Poland  (1개 행)      5. Comparison Operator(비교 연산)  number, string, date 등 여러 datatype에 대해 연산이 가능함  TRUE      SELECT 1 = 1;          SELECT 'MONKEY' &lt;&gt; 'monkey';          ?column?  ----------   t  (1개 행)        FALSE      SELECT 1 = 2;          SELECT 2 &lt;= 1;          ?column?  ----------   f  (1개 행)      6. LIMIT  한정된 개수로 DATA 제한          최초의 3개 행(LIMIT 3)          SELECT id, first_name, country_of_birth   FROM person   LIMIT 3;                  id | first_name |    country_of_birth  ----+------------+------------------------   1 | Cody       | Bosnia and Herzegovina   2 | Prescott   | China   3 | Trev       | Indonesia  (3개 행)                    7. OFFSET … LIMIT  지정된 INDEX부터 한정된 개수로 DATA 제한          INDEX 2(OFFSET 2)부터 3개 행(LIMIT 3)          SELECT id, first_name, country_of_birth   FROM person   OFFSET 2   LIMIT 3;                  id | first_name  | country_of_birth  ----+-------------+------------------3 | Trev        | Indonesia4 | Bartolemo   | Poland5 | Christopher | Philippines  (3개 행)                    8. OFFSET  OFFSET만 사용시, 지정된 INDEX부터 끝까지          INDEX 926부터(OFFSET 926) 끝까지 (총 DATA는 930개)          SELECT id, first_name, country_of_birth   FROM person   OFFSET 926;                  id  | first_name | country_of_birth  -----+------------+------------------  927 | Gayleen    | China  928 | Mavis      | Peru  929 | Melody     | United States  930 | Isidoro    | Indonesia  (4개 행)                    9. FETCH  LIMIT 의 공식적인 버전          INDEX 1부터(OFFSET 1)  3개 행(FETCH FIRST 3 ROW ONLY)          SELECT id, first_name, date_of_birth   FROM person   OFFSET 1   FETCH FIRST 3 ROW ONLY;                  id | first_name | date_of_birth  ----+------------+---------------   2 | Prescott   | 2022-05-17   3 | Trev       | 2022-04-05   4 | Bartolemo  | 2021-09-24  (3개 행)                      INDEX 111부터(OFFSET 111) 1개행(FETCH FIRST ROW ONLY)          1은 생략가능          SELECT *   FROM person   OFFSET 111   FETCH FIRST ROW ONLY;                  SELECT *   FROM person  OFFSET 111   FETCH FIRST 1 ROW ONLY;                  id  | first_name | last_name | email | gender | date_of_birth | country_of_birth  -----+------------+-----------+-------+--------+---------------+------------------  112 | Henry      | Wakes     |       | Male   | 2021-12-03    | China  (1개 행)                    10. IN  반복되는 컬럼에 대한 값을 지정할 때 사용          반복적인 OR을 IN 으로 교체          SELECT id, first_name, country_of_birth   FROM person   WHERE country_of_birth = 'China'  OR country_of_birth = 'France'  OR country_of_birth = 'Brazil';                  SELECT id, first_name, country_of_birth  FROM person  WHERE country_of_birth IN ('China', 'Brazil', 'France');                  id  | first_name | country_of_birth  -----+------------+------------------2 | Prescott   | China8 | Colline    | China \t\t\t\t\t\t...  920 | Krisha     | Brazil  922 | Shirlee    | China  927 | Gayleen    | China  (255개 행)                    IN으로 반복을 묶고, ORDER BY로 정렬          SELECT id, first_name, country_of_birth  FROM person  WHERE country_of_birth IN ('China', 'Brazil', 'France')  ORDER BY country_of_birth;                  id  | first_name | country_of_birth  ----+------------+------------------  663 | Darbee     | Brazil  269 | Hamnet     | Brazil                          ...  825 | Jerrie     | France  309 | Janel      | France  (255개 행)                    11. BETWEEN … AND …  구간 지정      SELECT id, first_name, date_of_birth  FROM person  WHERE date_of_birth  BETWEEN DATE '2021-12-31' AND '2022-01-01';          id  | first_name | date_of_birth  -----+------------+---------------  576 | Seana      | 2022-01-01  782 | Kelcey     | 2021-12-31  789 | Jaine      | 2021-12-31  842 | Burl       | 2022-01-01  (4개 행)      12. LIKE / ILIKE      PostgreSQL LIKE 참고 문서    LIKE연산자는 =연산자처럼 작동함          LIKE : 대소문자 구분          SELECT 'Her' LIKE 'HER';                  ?column?  ----------      f  (1개 행)                    ILIKE : 대소문자 구분하지 않음          SELECT 'her' ILIKE 'HER';                  ?column?  ----------      t  (1개 행)                      PostgreSQL은 두 가지 wildcard(%, _)를 제공함          % : 일치하는 0개 이상의 문자      _ : 일치하는 하나의 문자        %.com : .com으로 끝나는 문자열      SELECT id, first_name, email   FROM person   WHERE email LIKE '%.com';          id  | first_name  |                email  ----+-------------+-------------------------------------    1 | Cody        | cgiocannoni0@github.com    3 | Trev        | tmackellar2@msn.com                  ...  927 | Gayleen     | gsawartrn@usnews.com  928 | Mavis       | mrallingro@gravatar.com  (384개 행)        %@mozilla.com : @mozilla.com으로 끝나는 문자열      SELECT id, first_name, email   FROM person   WHERE email LIKE '%@mozilla.com';           id  | first_name |          email  -----+------------+--------------------------   533 | Nonna      | nrucklessefr@mozilla.com   744 | Jobye      | jhappsma@mozilla.com  (2개 행)        @google. : @google.이 포함된 문자열      SELECT id, first_name, email   FROM person   WHERE email LIKE '%@google.%';            id  | first_name |            email  ------+------------+------------------------------    113 | Reuben     | rwinslett3a@google.ru    162 | Rice       | rblayney4t@google.co.jp                    ...    738 | Emmy       | eswindenm4@google.cn    751 | Hedvig     | hhardypigginmh@google.com.au  (18개 행)        8자의 문자열과 @ 로 시작하는 email      SELECT id, first_name, email   FROM person   WHERE email LIKE '________@%';         id  | first_name |             email-----+------------+-------------------------------  12 | Matthus    | mallbutc@nyu.edu  28 | Stefano    | srainers@npr.org                ... 894 | Anselm     | apirieqq@wisc.edu 901 | Leonore    | lwykeyqx@list-manage.com(78개 행)        P% : P로 시작하는 문자열      SELECT id, first_name, country_of_birth   FROM person   WHERE country_of_birth LIKE 'P%';        id  | first_name  |   country_of_birth----+-------------+-----------------------  4 | Bartolemo   | Poland  5 | Christopher | Philippines          ...926 | Edvard      | Portugal928 | Mavis       | Peru(136개 행)      13. GROUP BY&lt; 출처 &gt;  ‘Learn PostgreSQL Tutorial - Full Course for Beginners,’ 유튜브 비디오, 04:19:34, 게시자 ‘freeCodeCamp.org,’ 2019년04월04일, https://youtu.be/qw–VYLpxG4",
        "url": "/postgreSQL"
    }
    , 
    
    "python-django-orm": {
        "title": "Python(6) - ORM(Object-Relational Mapping)",
            "author": "ohoraming",
                "category": "",
                    "content": "Python 관련 포스팅    Python(1) - Django 설치    Python(2) - MySQL 연결    Python(3) - PostgreSQL 연결    Python(4) - Query 만들기    Python(5) - Django 가상 환경과 settings.py          Django ORM을 사용하면서 드는 의문점을 해결하기 위해 쓰는 글입니다.1. ORM이란?객체-지향Object-Relational Mapping (ORM) is a technique that lets you query and manipulate data from a database using an object-oriented paradigm. When talking about ORM, most people are referring to a library that implements the Object-Relational Mapping technique, hence the phrase “an ORM”.An ORM library is a completely ordinary library written in your language of choice that encapsulates the code needed to manipulate the data, so you don’t use SQL anymore; you interact directly with an object in the same language you’re using.For example, here is a completely imaginary case with a pseudo language:You have a book class, you want to retrieve all the books of which the author is “Linus”. Manually, you would do something like that:",
        "url": "/Python-django-orm"
    }
    , 
    
    "python-django-venv-settings": {
        "title": "Python(5) - Django 가상 환경과 settings.py",
            "author": "ohoraming",
                "category": "",
                    "content": "Python 관련 포스팅    Python(1) - Django 설치    Python(2) - MySQL 연결    Python(3) - PostgreSQL 연결    Python(4) - Query 만들기    Python(5) - Django 가상 환경과 settings.py          Django를 써보면서 알게 된 내용을 정리했습니다.틀린 내용이 있다면 편하게 의견 남겨주시기 바랍니다 :)가상환경 설정1. 가상환경 생성  프로젝트 별로 다른 버전의 python과 django를 사용하기 위함  가상환경을 관리할 폴더와 프로젝트를 관리할 폴더를 각각 만드는 것이 관리하기 편함  만들 프로젝트의 이름으로 가상환경을 생성  이 방법이 가상환경을 관리하기 편하다고 생각    mkdir [가상환경을 관리할 폴더 이름]      # 디렉터리 생성cd [가상환경 폴더 저장할 디렉터리]       # 디렉터리로 이동python -m venv [가상환경 이름]          # 가상환경 생성       2. 가상환경 진입(활성화)  source [가상환경 이름]/scripts/activate   # 가상환경 활성화  가상 환경에 진입하면, 터미널의 디렉터리명 앞에 (가상환경 이름) 이 덧붙여져 나타남  가상환경에서 나가려면 경로와 상관없이 deactivate 입력    deactivate                         # 가상환경 비활성화      3. django, djangorestframework, psycopg2 설치  가상환경에 진입한 상태에서 설치를 진행함      pip install django  pip install djangorestframework  pip install psycopg2              # PostgreSQL 사용시 설치        pip upgrade 경고 문구가 뜬다면,pip upgrade: (windows) python -m pip install --upgrade pip  참고          django upgrade(특정 버전): pip install --upgrade django==4.0.5      pip version 확인: pip --version      업데이트 해야 할 패키지 목록 확인: pip list -o      4. project만들기  프로젝트를 설치할 폴더로 이동해 프로젝트 이름으로 디렉터리 만들기    cd [프로젝트를 설치할 폴더]mkdir [프로젝트 이름]cd [프로젝트 이름]            [project 이름]을 config . 으로 만들면 프로젝트 관리가 수월함 (출처: 참고한 사이트)      cd ..  django-admin startproject [project 이름]    # 프로젝트 생성  python manage.py runserver                  # 서버 실행      settings.py 설정1. SECRET_KEY 설정  project root 경로에 secret_file.py 생성  settings.py의 SECRET_KEY = '...(내용)...' 복사해 붙여넣기  settings.py 수정     import secret_file ... SECRET_KEY = secret_file.SECRET_KEY      2.  INSTALLED_APPS 설정  app 설치     django-admin startapp [app 이름]    # app 생성        생성한 app과 rest_framework추가     INSTALLED_APPS = [         ...     'rest_framework',                 # 추가     '생성한 app 이름',                 # app 추가     '생성한 app 이름',                 # app 추가 ]      3. TEMPLATES 의 'DIRS' 설정  TEMPLATES = [      {                ...          'DIRS': [BASE_DIR / 'templates'], # 수정                ...      },  ]  여기서 BASE_DIR은 project 폴더  root에 templates 디렉터리 생성          모든 앱이 공통으로 사용할 템플릿 디렉터리 - [root]/templates      특정 앱이 사용할 템플릿 디렉터리 - [root]/templates/[특정 app]        이렇게 templates 폴더를 관리해주어야 Django가 제대로 인식 할 수 있음4. DB 설정(postgreSQL)  참고로, 이 과정은 반드시 python manage.py makemigration을 하기 전에 시행되어야 함    DATABASES = {  'default': {      'ENGINE': 'django.db.backends.postgresql',      'NAME': 'DB이름',       # DB 이름      'USER': 'postgres',      'PASSWORD': '1234',     # 비밀번호      'HOST': 'localhost',        'PORT': '5432',  }}        secret_file.py 에 위 내용 붙여넣기  settings.py는 아래 코드로 바꾸기      DATABASES = secret_file.DATABASES       5. LANGUAGE_CODE, TIME_ZONE 설정  LANGUAGE_CODE = 'ko-kr'  TIME_ZONE = 'Asia/Seoul'6. STATICFILES_DIRS 추가하기      STATIC_URL = 'static/' 아래에 추가하기      STATIC_URL = 'static/'  STATICFILES_DIRS = [      BASE_DIR / 'static',  ]        [project]아래에  static 폴더 만들기  BASE_DIR / 'static'은 [root]/static 디렉터리를 의미함7. urls.py 작성  [project 이름]/urls.py    from django.contrib import adminfrom django.urls import include, path  urlpatterns = [    path('admin/', admin.site.urls),    path('account/', include('account.urls')),  # 예시]      8. admin 페이지 사용하기  Django에서 제공하는 admin 페이지입니다          superuser 생성하기          python manage.py createsuperuser           # superuser 생성                    사용자 이름, 이메일, password를 입력              [app]/admin.py 작성         from django.contrib import admin from .models import 모델명       # Register your models here.       admin.site.register(모델명)                      서버 실행 후 admin에 접속    bash    python manage.py runserver                      http://127.0.0.1:8000/admin에 접속",
        "url": "/Python-django-venv-settings"
    }
    , 
    
    "web-api": {
        "title": "Web API",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          이 포스팅은 ‘A Brief, Opinionated History of the API’ (by. Joshua Bloch)스피치와 다수의 영문 포스팅을 한글로 해석한 내용이 포함되어 있습니다. 출처를 확인해주시기 바랍니다.web API를 공부하던 중 API library도 API로 혼용해 쓰는 것에 의문이 들었습니다. API의 정의는 정확히 무엇이며, 왜 이렇게 혼용을 해 사용하게 되었는지 그 역사를 기술한 자료를 읽어보고, 이와 관련해 흥미로운 스피치가 있어 소개합니다.API의 역사  1948년, Herman Goldstine과 John von Neumann은 프로그램이 공통 연산(common operations)을 사용하게 되면, 서브루틴 라이브러리(subroutine library)가 새 코드와 에러의 양을 줄여줄 것이라고 함→ 서브루틴 라이브러리에 대한 관점(idea)을 언급만 함[아래 사진의 서랍 속에 들어있는 것이 서브루틴 라이브러리 테이프](※ Subroutine에 대한 간단한 설명)  1952년, Wilkes와 Wheeler가 서브루틴 라이브러리에 관한 논문 발표(2pages 분량)  (참고)논문 전문→ 당시에 API를 Library와 구분하지 않은 이유는?          두 개념이 크게 보았을 때 같은 의미였으며,      컴퓨터는 하나밖에 없었기에 기계 이동성의 개념이 존재하지 않았음      레거시 프로그램이 없었음      그래서 API를 별개로 논의할 이유가 없었으나, 명확하게 API 디자인 개념에 대해 이해하고 있었음        1968년, AFIPS Fall Joint Computer Conference에서 처음 API라는 용어를 사용함          마침내, 중앙 컴퓨터에서 하드웨어의 독립은 컴퓨터가 교체될 때 일관된 application program interface가 유지된다는 것을 의미한다.      API(Application Programming Interface)란?  입출력을 통해 정의된 operation 세트를 제공하는가?  사용자를 손상시키지 않으면서 재실행을 허락하는가?이 두 조건을 모두 충족하면 API라고 할 수 있다즉, Library나 Framework에서 이용할 수 있는 Class나 Function도 API라고 부름프로젝트 내부에서 쓰여지고 있는 클래스나 모듈이 있다면, 이를 함수/인터페이스/API로 지칭할 수 있음Web API란?  1990년대부터 인터넷이 대중화되면서 컴퓨터와 다양한 기기들이 인터넷을 통해 의사소통하는 시대가 됨  다양한 기기에서 서버의 데이터를 읽고 쓰기 위해 Web API를 이용함  네트워크에서 기기들간의 의사소통 규격 사항을 HTTP(S)라고 부르며, REST는 Web API를 어떻게 만들지 정의한 것임  (과거에는 SOAP을 이용해 XML 포멧으로 정보를 주고 받았음)  REST의 POST/GET/PUT/DELETE를 이용해 새로운 데이터를 만들고(create)/읽고(read)/수정하고(update)/삭제(delete)할 수 있음  GET을 이용해 정보를 요청(request)하면, 서버로부터 해당 데이터를 JSON 포맷으로 응답(response)받을 수 있음더 읽을 거리 &amp; 참고한 자료  History of APIs  Intro to APIs: What Is an API?  The Evolution of APIs: Past, Present and the Future  What is an API: Everything You Need to Know About APIs?  Your Guide To Messaging APIs Web 3.0 Internet Communication&lt; 출처 &gt;  ‘A Brief, Opinionated History of the API,’ 유튜브 비디오, 47:04, 게시자 ‘InfoQ,’ 2018년 11월 22일, https://youtu.be/LzMp6uQbmns  “API란? 개념 정리와 포트폴리오에 유용한 대박 사이트 공유 🙌,” 유튜브 비디오, 08:07, 게시자 “드림코딩 by 엘리,” 2021년 3월 16일, https://youtu.be/ogT267HvNuQ  Kristopher Sandoval. “Who Invented the API?.” NORDIC APIS. September 20, 2018 https://nordicapis.com/who-invented-the-api/",
        "url": "/web-api"
    }
    , 
    
    "javascript-basic": {
        "title": "JavaScript(14) - basic",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage          ※ 이 글은 윤인성님의 Youtube 강의 내용을 참고 작성한 글입니다.예시는 변경해 적용한 부분이 많으니 참고하시기 바랍니다.원본 출처는 문서 하단을 확인하시기 바랍니다.1. 요소 값 추출 및 입력1-1. 요소 값 추출      textContent, innerHTML      &lt;body&gt;      &lt;h1 id=\"first\"&gt;h1 태그에 입력된 기존 문자열입니다.&lt;/h1&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          document.addEventListener('DOMContentLoaded', () =&gt; {      const header1 = document.querySelector('#first');      // 태그 확인      console.log(header1);                 // 값 추출       console.log(header1.textContent);      console.log(header1.innerHTML);  });                querySelector('selector') 사용 방법          selector: CSS selector를 string으로 넣음      &lt;h1 id=\"header\"&gt;제목&lt;/h1&gt;          document.querySelector('h1')  document.querySelector('#header')  document.querySelector('h1#header')                    &lt;span class=\"choose\"&gt;선택&lt;/span&gt;          document.querySelector('span')  document.querySelector('.choose')  document.querySelector('span.choose')                    &lt;input id=\"name-input\" type=\"text\" name=\"name\"&gt;          document.querySelector('input')  document.querySelector('#name-input')  document.querySelector('[type=text]')  document.querySelector('input[type=text]')  document.querySelector('input[type=text][name=name]')                    1-2. 요소에 원하는 값 입력  textContent          tag를 일반 문자열로 인식      많이 사용        innerHTML          tag를 인식      보안상 문제가 될 수 있어서 많이 사용하지 않음      &lt;body&gt;    &lt;h1 id=\"first\"&gt;h1 태그에 입력된 기존 문자열입니다.&lt;/h1&gt;    &lt;h2 id=\"second\"&gt;h2 태그에 입력된 기존 문자열입니다.&lt;/h2&gt;    &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;document.addEventListener('DOMContentLoaded', () =&gt; {    const header1 = document.querySelector('#first');    const header2 = document.querySelector('#second');    // 값 입력    header1.textContent = 'apple pie&lt;br&gt;🥧';    header2.innerHTML = 'apple pie&lt;br&gt;🥧'        // 값 추출    console.log(header1.textContent);    console.log(header2.textContent);});2. 속성 조작하기2-1. 표준에 있는 속성 조작하기  해당 속성을 직접 지정      &lt;body&gt;      &lt;img src=\"\" alt=\"\"&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;        document.addEventListener('DOMContentLoaded', () =&gt; {  const img = document.querySelector('img');      // 값 입력  img.src = 'http://placekitten.com/200/200';  // 값 추출  console.log(img.src);});          2-2. 표준에 없는 속성(사용자 정의 속성) 조작하기  setAttribute('속성 이름', '값')      getAttribute('속성 이름')      &lt;body&gt;      &lt;img src=\"\" alt=\"\"&gt;  &lt;/body&gt;          document.addEventListener('DOMContentLoaded', () =&gt; {      const img = document.querySelector('img');              // 값 입력      img.setAttribute('src', 'http://placekitten.com/152/152');      // 값 추출      console.log(img.getAttribute('src'));  });          3. 스타일 조작하기  style.backgroundColor          일반적으로 많이 사용        style['background-color']          CSS의 속성 명으로 쓰고 싶을 때 사용          &lt;body&gt;      &lt;!-- div tag 10개 --&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;div&gt;&lt;/div&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          document.addEventListener('DOMContentLoaded', () =&gt; {      const divs = document.querySelectorAll('div'); // div 여러 개 이므로 divs로 표현      divs.forEach((div, key) =&gt; { // key는 index값      // 값 입력      div.style.backgroundColor = `rgb(${key*25.5}, ${key*25.5}, ${key*25.5})`;      div.style.height = '30px'; // 반드시 문자열로 넣고 단위 생략하면 안 됨!                      // 값 추출      console.log(div.style.backgroundColor)      })  });          4. 문서 객체 생성하기  document.createElement('태그 이름')          element 생성        appendChild()          화면에 element 붙이기          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 만들기      // createElement()      const header = document.createElement('h1');                  // element의 속성 지정      header.textContent = 'createElement로 만든 tag';      header.style.color = 'salmon';      // element 붙이기      // appendChild()      const body = document.querySelector('body');      body.appendChild(header);  });          5. 문서 객체 제거하기  removeChild()          해당 요소를 직접 제거        parentNode.removeChild()          부모 요소를 이용해 제거하는 방법      많이 사용함          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 만들기      // createElement()      const header1 = document.createElement('h1');      const header2 = document.createElement('h2');      header1.textContent = 'createElement로 만든 tag1입니다!';      header2.textContent = 'createElement로 만든 tag2입니다!';      header1.style.color = 'green';      header2.style.color = 'red';      // element 붙이기      // appendChild()      const body = document.querySelector('body');      body.appendChild(header1);      body.appendChild(header2);      // element 제거하기      // 편의상 2초 뒤에 element가 제거되도록 setTimeout() 사용      setTimeout(() =&gt; {          // body.removeChild(header1);          header1.parentNode.removeChild(header1); // 많이 사용함      }, 2000);  });        body.removeChild() vs. header.parentNode.removeChild()          body와 header.parentNode는 같은 의미임              header.parentNode의 경우, 부모요소(body) 언급없이 제거할 요소만 지칭하므로 사용하기 편리해 많이 씀                      6. 문서 객체 이동하기      setTimeout(function, delay)      &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;div class=\"first\"&gt;          &lt;h1&gt;첫 번째 div tag 내부&lt;/h1&gt;      &lt;/div&gt;      &lt;hr&gt;      &lt;div class=\"second\"&gt;          &lt;h1&gt;두 번째 div tag 내부&lt;/h1&gt;      &lt;/div&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 만들기      const header = document.createElement('h2');      header.textContent = '추가된 h2 tag입니다';      const first = document.querySelector('.first');      const second = document.querySelector('.second');          // element 붙이기      first.appendChild(header);               const toFirst = () =&gt; {          first.appendChild(header);          setTimeout(toSecond, 1000); // 1초 뒤에 toSecond() 실행      }              const toSecond = () =&gt; {          second.appendChild(header);          setTimeout(toFirst, 1000); // 1초 뒤에 toFirst() 실행      }      toFirst();   });            1초마다 두 화면이 번갈아가며 나타남              또는 다음과 같은 방법으로 실행할 수도 있음          array에 element를 넣음      setInterval()          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;div class=\"first\"&gt;          &lt;h1&gt;첫 번째 div tag 내부&lt;/h1&gt;      &lt;/div&gt;      &lt;hr&gt;      &lt;div class=\"second\"&gt;          &lt;h1&gt;두 번째 div tag 내부&lt;/h1&gt;      &lt;/div&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 만들기      const header = document.createElement('h2');      header.textContent = '추가된 h2 tag입니다';                  const array = [          document.querySelector('.first'),           document.querySelector('.second')      ];      let counter = 0;      const move = () =&gt; {          array[counter % 2].appendChild(header);          counter ++;      };      setInterval(move, 1000);      move(); // 1초 뒤부터 h2 tag가 나타나므로 처음 한 번은 실행해 줌  });      7. event 연결  addEventLister('이벤트_이름', 이벤트 리스너(이벤트 핸들러))          이벤트가 실행될 때 호출되는 callBack fn을 이벤트 리스너 또는 이벤트 핸들러라고 부름      문서 객체에서 on으로 시작하는 속성들을 이벤트와 관련되므로 적절한 항목을 골라 사용자에 반응하는 프로그램을 만들 수 있음  e.g.) onmousedown, onmouseenter, onmouseleave 등          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 생성      const header = document.createElement('h1');       header.textContent = 'Click = 0'      header.style.color = 'salmon';      header.style.border = '1px solid salmon';      header.style.userSelect = 'none'; // 연속 click시 text가 선택되지 않도록 설정\t        // element 붙이기       // body 태그 내부에 붙이기      document.body.appendChild(header);               let count = 0; // 변수 설정              // h1 태그를 click할 때마다 이벤트를 발생시킴      header.addEventListener('click', () =&gt; {          count ++;          header.textContent = `Click = ${count}`;      });  });              h1 태그를 click할 때마다 숫자가 하나씩 증가함          8. 이벤트 제거  removeEventLister()          click연결 시 사용했던 eventLister를 별도의 변수(여기서는 listener)에 담아 주어야 함          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  let count = 0;  const listener = () =&gt; {      header.textContent = `클릭 횟수 = ${++count}`;  }  // element 생성(h1)  const header = document.createElement('h1');  header.style.border = '1px solid black';  header.style.userSelect = 'none'; // click시 text가 선택되지 않도록 설정  header.textContent = '클릭 횟수 = 0';  // element 생성(p)  const p = document.createElement('p');  p.textContent = '이벤트 연결 상태: 해제';  p.style.userSelect = 'none'; // click시 text가 선택되지 않도록 설정  // element 생성(button)  const connectButton = document.createElement('button');  connectButton.textContent = '이벤트 연결';  connectButton.addEventListener('click', () =&gt; {      header.addEventListener('click', listener)      p.textContent = '이벤트 연결 상태: 연결';   });  // element 생성(button)  const disconnectButton = document.createElement('button');  disconnectButton.textContent = '이벤트 제거';  disconnectButton.addEventListener('click', () =&gt; {      header.removeEventListener('click', listener)      p.textContent = '이벤트 연결 상태: 해제';  });  // 화면에 element 추가(순서대로)  document.body.appendChild(header);  document.body.appendChild(connectButton);  document.body.appendChild(disconnectButton);  document.body.appendChild(p);        이벤트 연결 버튼을 클릭하면,          이벤트 연결 상태가 ON 로 바뀌면서      header 클릭시 클릭 횟수가 증가        이벤트 제거 버튼을 클릭하면,          이벤트 연결 상태가 OFF로 바뀌면서      header 클릭시 클릭 횟수가 증가하지 않음            9. 키보드 이벤트  event가 발생했을 때, 해당 event와  관련된 정보가 이벤트 객체 형태로 callback fn의 첫 번째 parameter로 가져옴      document.addEventListener('이벤트', (이벤트 객체) =&gt; {      });              일반적으로 이 parameter의 이름은 event 또는 e 로 설정함                  e.code: 입력한 키          e.keyCode: 입력한 키를 나타내는 숫자          e.altKey: Alt 키를 눌렀는지          e.ctrlKey: Ctrl 키 를 눌렀는지          e.shiftKey: Shift 키를 눌렀는지          e.currentTarget: event를 발생시킨 객체                          currentTarget, this 를 사용한 코드 숙지하기      &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 생성(h1)      const header = document.createElement('h1');      header.textContent = '글자 수 = 0';      header.style.color = 'salmon';      header.style.border = '1px solid salmon';\t\t      // element 생성(textarea)      const textarea = document.createElement('textarea');      textarea.placeholder = '글자를 입력하세요';      // 화면에 element 추가      document.body.appendChild(header);      document.body.appendChild(textarea);      // 첫 번째 방법      textarea.addEventListener('keyup', (e) =&gt; {          h1.textContent = `글자 수: ${textarea.value.length}`;      });      // 두 번째 방법      // currentTarget 사용      textarea.addEventListener('keyup', (e) =&gt; {          h1.textContent = `글자 수: ${e.currentTarget.value.length}`;      });      // 세 번째 방법      // function을 만들어 this를 사용      textarea.addEventListener('keyup', function () {          h1.textContent = `글자 수: ${this.value.length}`;      });  });                      글을 입력하면 글자 수를 알려줌                      console.log(e.currentTarget)를 보면, 이벤트를 발생시킨 객체가 나옴              첫 번째 방법                  keyup          keydown인 상태에서는 입력한 글자 수를 알 수 없음                    두 번째 방법                  keypress          아시아 문자에서는 제대로 작동하지 않는 경우가 있음                    세 번째 방법                  this 사용          eventHandler내부에서 this가 이벤트 발생 객체를 의미함                    10. 기본 이벤트 막기  preventDefault()          기본 이벤트를 막음        a 태그          기본 이벤트: 클릭하면 지정된 주소로 이동      click 이벤트에 preventDefault() 를 설정하면 지정 주소로 이동하지 않음        요소에서 우클릭          기본 이벤트: context menu가 나옴      contextmenu 이벤트에 preventDefault() 를 설정하면 context menu가 나오지 않음      블로그의 우클릭 방지기능          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 생성(a 태그)      const link = document.createElement('a');      link.textContent = 'Google';      link.href = 'https://www.google.com';\t\t      // element 추가      document.body.appendChild(link);      // a 태그 click시 링크가 연결되는 것 막기      link.addEventListener('click', (event) =&gt; {          event.preventDefault();      });          // a 태그 우click시 context menu가 나오는 것 막기      link.addEventListener('contextmenu', (event) =&gt; {          event.preventDefault();      });  });              preventDefault() 적용 전        preventDefault() 적용 후        11. 입력 양식(1) - Button  세 가지 형태가 존재      // 1.  &lt;button&gt;글자&lt;/button&gt;      // 2.  &lt;input type=\"button\" value=\"글자\"&gt;      // 3.  &lt;form action=\"\"&gt;      &lt;input type=\"submit\" value=\"글자\"&gt;  &lt;/form&gt;              첫 번째와 두 번째는 click 이벤트 활용시에 사용      세 번째는 submit 이벤트 활용시에 사용      11-(1) click 이벤트 사용하기  event.currentTarget: 이벤트를 발생시킨 객체      &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {          // element 선택(button)      const firstButton = document.querySelector('button');      const secondButton = document.querySelector('input[type=button]');      // button 클릭시 event 지정      firstButton.addEventListener('click', (event) =&gt; {          event.currentTarget.textContent += '😎';       });      secondButton.addEventListener('click', (event) =&gt; {          event.currentTarget.value += '🌈';       });  });              button을 클릭할 때마다 버튼의 내용이 바뀜          11-(2) click 이벤트 사용하기  form 태그의 button을 클릭하면,  태그 안의 데이터를 서버로 넘김  ⇒ 주소가 바뀜  submit 이벤트는 form 태그를 선택해(document.querySelector('form')) 이벤트를 연결해야 함!  form 태그 내부에 있는 button은 submit 태그와 동일하게 동작하므로 주의!      form 태그 내부에 input[type=button] button을 만들어야 submit 이벤트가 일어나지 않음      &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;form action=\"\"&gt;          이메일 형식으로 입력하세요!&lt;br&gt;          &lt;!-- name 값을 반드시 입력해야 함 --&gt;          &lt;input type=\"text\" name=\"test\" id=\"\"&gt;          &lt;input type=\"submit\" value=\"글자\"&gt;      &lt;/form&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;           // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 선택(form)      const form = document.querySelector('form');          // (주의!) form 태그를 선택해 submit 이벤트를 관리함      form.addEventListener('submit', (event) =&gt; {          const text = document.querySelector('input[type=text]');\t\t\t            // indexOf()로 '@'가 있는지 확인          if (text.value.indexOf('@') &gt;= 0) {              alert('정상 제출합니다!');          } else {              alert('이메일 형식으로 입력해주세요!');                      // 이메일 형식이 아닐경우 기본 submit 이벤트를 막음              event.preventDefault();          }      });  });              @ 가 포함되어있지 않으면 주소 변경이 일어나지 않음        정상제출을 하면, 주소가 바뀜          12. 입력 양식(2) - 글자 입력  &lt;input type=\"text\"&gt;          한 줄의 글자 입력        &lt;textarea&gt;&lt;/textarea&gt;          여러 줄의 글자 입력        contenteditable=\"true\"                  해당 태그의 내용을 직접 수정가능하게 만들어줌          &lt;p contenteditable=\"true\"&gt;contenteditable!&lt;/p&gt;                            (참고) keydown, keypress, keyup, change 이벤트  키 이벤트와 입력 순서          keydown → keypress → ★입력양식에 값이 들어감★→ keyup              keydown 이나, keypress 이벤트를 주면,  입력 양식에 값이 들어가는 것이 시간상 더 이후이므로 코드 실행시 변환이 일어나지 않은 결과를 보여줌          button.addEventListener('keydown', () =&gt; {          p.textContent = `${Number(input.value) * 2.54}cm`;  });                          keydown시점에 이벤트가 실행되므로 입력 양식에 값이 들어가기 전이라 p태그에 값이 없음                      참고로 change 이벤트의 경우, 값 입력을 마쳤다는 선언(enter 키 입력)이 있어야 함       입력받은 cm 단위를 inch로 변환하기&lt;!-- index.html --&gt;&lt;body&gt;    &lt;input type=\"text\" name=\"inch\" id=\"\" placeholder=\"숫자\"&gt; inch &lt;br&gt;    &lt;p id=\"result\"&gt;숫자를 입력해주세요&lt;/p&gt;    &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;// main.jsdocument.addEventListener('DOMContentLoaded', () =&gt; {    // element 선택    const input = document.querySelector('input[name=inch]');    const p = document.querySelector('#result');    // 입력한 값을 숫자로 변경해 inch 단위로 변경    button.addEventListener('click', () =&gt; {        p.textContent = `${Number(input.value) * 2.54}cm`;    });});  &lt;textarea&gt;&lt;/textarea&gt; 를 사용했을 때도 마찬가지로 value 속성으로 text를 추출하면 됨13. 입력 양식(3) - 체크박스/라디오버튼  체크 박스          true 또는 false 가 선택됨        라디오 버튼          name 속성 지정 필수      같은 name 속성을 갖는 그룹으로 묶임       checkbox, radio button 선택시 해당 내용 출력하기  forEach()          라디오 버튼이 여러 개 이므로 각각 돌면서 addEventListener()를 실행          &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;!-- true 또는 false를 선택 --&gt;      &lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;      &lt;p id=\"checkValue\"&gt;&lt;/p&gt;      &lt;!-- 여러 대상 중 하나만 선택 --&gt;      &lt;input type=\"radio\" name=\"food\" value=\"아이스크림\"&gt;🍦      &lt;input type=\"radio\" name=\"food\" value=\"치킨\"&gt;🍗      &lt;input type=\"radio\" name=\"food\" value=\"도넛\"&gt;🍩      &lt;p id=\"radioValue\"&gt;&lt;/p&gt;          &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 선택      const checkBox = document.querySelector(\"input[type=checkbox]\");      // 라디오 버튼 모두 선택      const radios = document.querySelectorAll(\"input[type=radio][name=food]\");       const checkValue = document.querySelector(\"p#checkValue\");      const radioValue = document.querySelector(\"p#radioValue\");\t      // 체크박스가 체크되면 이벤트 실행      checkBox.addEventListener(\"change\", () =&gt; {          if (checkBox.checked) {              checkValue.textContent = \"체크!\";          } else {              checkValue.textContent = \"안 체크!\";          }      });\t      // 라디오버튼이 선택되면 이벤트 실행      // forEach문으로 각 radio버튼 돎      radios.forEach((radio) =&gt; {          radio.addEventListener('change', (event) =&gt; {              radioValue.textContent = event.currentTarget.value;          })      })  });           checkbox 선택시 배경색 바뀌면서, 타이머 작동시키기  구조 분해 할당(destructuring assignment)          객체나 배열을 변수로 분해할 수 있게 해주는 특별한 문법      참고 예시        setInterval()과 clearInterval()      &lt;!-- index.html --&gt;  &lt;body&gt;      &lt;input type=\"checkbox\" name=\"\" id=\"\"&gt; 타이머 ON      &lt;p id=\"timer\"&gt;0초&lt;/p&gt;      &lt;script src=\"main.js\"&gt;&lt;/script&gt;  &lt;/body&gt;          // main.js  document.addEventListener('DOMContentLoaded', () =&gt; {      // element 선택      const checkBox = document.querySelector(\"input[type=checkbox]\");      const timer = document.querySelector(\"p#timer\");      let [seconds, timerId] = [0, 0]; // 구조분해 할당      // 체크박스가 체크되면 이벤트 실행      checkBox.addEventListener(\"change\", () =&gt; {          if (checkBox.checked) {              document.body.style.backgroundColor = 'pink';              timerId = setInterval(() =&gt; {                  seconds += 1;                  timer.textContent = `${seconds}초`;              }, 1000)          } else {              document.body.style.backgroundColor = 'white';              clearInterval(timerId);          }      });  });          &lt; 출처 &gt;  “혼공 자바스크립트 40~46강,” 게시자 “윤인성,” https://www.youtube.com/playlist?list=PLBXuLgInP-5kxpAKy2DNXoebCse2grHjl",
        "url": "/JavaScript-basic"
    }
    , 
    
    "javascript-localstorage": {
        "title": "JavaScript(13) - localStorage",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        localStorage란?  현재 기기의 브라우저에 내에 key-value쌍을 저장할 수 있게 함  도메인별로 따로 저장(최대 5Mb까지 저장가능)되며, 삭제하기 전에는 없어지지 않음  이전 페이지에서 사용자가 검색했던 내용을 계속 parameter에 넣어서 들고 다니지 않을 수 있음  문자열만 저장할 수 있기 때문에 object나 array는 JSON.stringify()를 사용해 문자열로 변환한 뒤 저장하고, 가지고 올 때는 JSON.parse()를 사용해 JSON형태로 변환해서 사용  서버가 HTTP 헤더를 통해 storage 객체를 조작할 수 없으며, 웹 스토리지 객체 조작은 모두 javascript 내에서 수행됨cf.) sessionStorage  브라우저 창을 닫는 순간 사라짐  같은 브라우저 탭 안에서만 유지됨localStorage 사용1. localStorage 객체에 접근해 key, value 쌍을 추가함  localStorage.setItem('key', 'value');    localStorage.setItem('supermarket', 'carrot, 1000원');localStorage.setItem('drugstore', 'aspirin, 3000원');        개발자 도구(F12) application 탭의 Local Storage 항목에서 data를 확인할 수 있음2. localStorage에 저장된 value를 key값을 이용해 불러옴  localStorage.getItem('key');    localStorage.getItem('supermarket');localStorage.getItem('drugstore');          3. localStorage에 저장된 data를 key값을 이용해 개별 삭제함  localStorage.removeItem('key');    localStorage.removeItem('supermarket');          4. localStorage에 저장된 모든 data를 전체 삭제함  localStorage.clear();    localStorage.clear();          5. JSON 이용하기  localStorage의 key가 늘어나면 관리가 어렵기 때문에 일반적으로 하나의 key에 여러 data를 넣음  JSON을 이용하면 간편하게 data를 관리할 수 있음  JSON(JavaScript Object Notation)  → JavaScript에서 객체를 표현하는 형식으로 데이터를 저장  → 문자열을 사용해 다른 프로그램들과 통신을 하는 상황에서 사용  JSON 객체          JSON.stringify(): javascript객체를 JSON문자열로 변환      JSON.parse(): JSON문자열을 javascript객체로 변환        JSON 규정          key는 문자열만 가능      문자열은 반드시 큰따옴표로 감싸야 함      데이터는 숫자, 문자열, boolean 만 저장가능      컨테이너 데이터는 object, array만 사용 가능( function은 불가)      6. JSON data를 localStorage에 저장하기  JSON.stringify()로 javascript객체를 JSON으로 변환    const data = {  carrot: \"1000원\",  aspirin: \"3000원\"}localStorage.setItem('item', JSON.stringify(data));        → 모든 항목이 큰 따옴표로 감싸져 있음(JSON 문자열로 변환됨)  7. localStorage에 저장된 JSON data를 javascript 객체로 변환하기  JSON.parse()로 JSON 문자열을 JavaScript객체로 변환      JavaScript에서 사용가능한 객체로 변환됨      const item = {      carrot: \"1000원\",      aspirin: \"3000원\"  }  const stringifiedItem = JSON.stringify(item); // stringify()  localStorage.setItem('item', stringifiedItem); // localStorage에 저장  const parsedItem = JSON.parse(stringifiedItem); // parse()  console.log(stringifiedItem); // JSON 문자열  console.log(parsedItem); // JavaScript 객체  console.log(parsedItem.carrot); // 1000원  console.log(parsedItem.aspirin); // 3000원          &lt; 출처 &gt;  “입문자를 위한 자바스크립트 기초 #26 로컬스토리지 (localStorage),” 유튜브 비디오, 10:00, 게시자 “유노코딩,” 2021년 10월 08일, https://youtu.be/N7oln9Z3WYg  “혼공 자바스크립트 52강 - localStorage 객체(3) : JSON 객체와 결합해서 사용하기,” 유튜브 비디오, 8:02, 게시자 “윤인성,” 2021년 07월 25일, https://youtu.be/Id7o7DwhiFY",
        "url": "/JavaScript-localStorage"
    }
    , 
    
    "code-review": {
        "title": "왜 Code Review를 해야 하는가",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          ※ 이 글은 4월 우아한테크세미나 영상을 첨부된 발표 자료와 함께 정리한 것입니다.원본 영상은 4월 우아한테크세미나를 참고하시기 바랍니다.  발표자: 11번가 백명석 님1. 왜 코드 리뷰를 해야 하나?1-1. 우리가 살고 있는 시대오프라인 업체를 온라인 업체가 대체하고 있음4차 산업 혁명의 키워드 중 하나, VUCA  변동성(V)으로 인해 점점 기존의 방식으로는 문제를 해결할 수 없게 됨  혼자가 아니라 여러 명이 협력해 문제를 해결하는 것의 가치가 높아지고 있으며,코드 리뷰는 변동성을 해결하는 데 도움을 주는 방법이 됨  전체 산업에서 IT 비율이 10년만에 2배로 성장, 90%는 Digital Transformation (DT) 중  미국은 보다 원활한 서비스를 공급하기 위해서는 3배(2020년 당시) 더 많은 개발자가 필요하다고 함  우리 나라의 경우, 미국의 1/4 수준의 개발자를 보유하고 있으므로 현 시점보다 12배 많은 개발자가 필요함시장은 VUCA하고, 비즈니스는 빠른 혁신이 필요하므로,개발에 있어서 SW를 더 자주 안정적으로 출시(DRFR)해야 함(Clean Architecture 1장) 출시 때마다 개발자는 기하급수적으로 증가함하지만, 출시 때마다 생산성은 일정 수치에 수렴함처음에는 만든 모든 것이 산출물이라 기술부채가 없음출시가 거듭될 수록 개발자는 기존 코드를 파악 및 수정하는데 대부분의 시간을 쓰고, 새로운 기능을 추가하는 생산적인 일을 하는데 시간을 쓰지 못하게 됨1-2. 개발 생산성&lt; Martin Fowler’s Design Stamina Hypothesis(블로그 참조) &gt;좋은 설계와 나쁜 설계의 누적 생산성을 보여줌→ 설계 수익선을 지나 생기는 개발의 생산성 저하를 막아야 함1-3. SW 공학의 특성일반적인 공학의 경우,설계와 빌드 중 빌드 비용이 압도적건축물 완공 후에는 변경할 수 있는 것이 거의 없으므로 유지보수 비용이 상대적으로 낮음재생산이 가능하다는 것은 누가 빌드를 하든지 동일한 결과물이 나오는 것SW빌드는 인건비가 발생하지 않아 거의 무료임그래서 설계는 굉장히 중요하며, SW 엔지니어는 설계를 잘 하는 사람, 좋은 코드를 작성하는 사람임새 코드 작성하는 일은 20%, 코드를 읽고 변경하는 일이 80%코드 이해에 10배 이상의 에너지가 소요됨내 코드도 2주 뒤에는 남의 코드처럼 보임코드가 좋은 가독성과 좋은 설계를 가져야 하는 이유임일정에 쫓겨 빠르고 지저분하게 개발을 하는 것은 결코 빠른 개발이 아님SW의 경우, 비싸다고(비용이 많이 든다고) 품질이 좋은 것 아님(비정상적, 비직관적)처음에는 비용이 많이 들어도, 수정할 때는 훨씬 비용을 절감할 수 있게 됨개발자로서 테스트 커버리지를 높일 일정을 제공받고 싶다면,테스트 커버리지를 높였을 때 결함율이 감소하고, 변경 요청시 빠르게 처리가 가능해 출시 기간이 짧아질 수 있다고 말해야 비즈니스 측에서 원하는 대답이 됨1-4. 장인정신VUCA시대에 좋은 SW를 개발하는 가장 좋은 방법은 애자일하지만,단순히 절차만 변경하고, 애자일의 개발 역량(TDD, refactoring, test 자동화, 단순한 설계 등)에 대해서 다루지 않으면 실패함관련 지식과 경험은 학교가 아닌, 전문성을 갖춘 개발자가 공유를 해주는 방법이 유일함(이것이 SW의 장인정신, 애자일의 확장된 개념)SW 장인정신은 공유 활동이 아주 중요함공유 활동 중 코드 리뷰는 누구나 쉽게 접근할 수 있음온라인에서 code로 댓글 놀이를 하면 코드 리뷰 하는 느낌을 받을 수 있음1-5. 코드 리뷰의 정의(Wikipedia)한 명 또는 여러 사람이 주로 소스 코드 일부를 보고 읽는 방식으로, 프로그램을 확인하는 SW품질 보증 활동으로써 구현 혹은 구현을 잠시 중단하면서 시행함피어 리뷰, 풀 리퀘스트, 머지 리퀘스트라고도 불림1-6. 코드 리뷰의 목적코드 리뷰시 주목적 달성은 물론, 양방향의 배움이 일어남피어 또는 주니어 간의 코드 리뷰에서는 기술(하드 스킬)을 배우게 됨시니어가 주니어를 가르칠 때는 어떻게 소통해야 상대가 더 잘 받아들이는지, 친절함, 공감능력, 가르치는 방법 등의 소프트 스킬과 리더십을 배우게 됨또한, 잘 하는 사람이 하는 것을 보며 동기 부여가 됨팀원의 코드를 리뷰하면서 책임감이 생김팀원의 일에 관심을 가지게 되고, 내가 팀원에게 줄 수 있는 것은 무엇일까 생각하게 됨결과적으로 팀웍이 생김코드 리뷰로 좋은 사례가 공유되고, 부족한 부분에 대해선 좋은 의견을 물어볼 수 있음이런 공유활동이 지속되면 개발 문화가 개선됨2. 코드 리뷰의 절차  저자(코드를 작성한 사람)가 변경된 내용에 대해 PR를 만들어서 리뷰어에게 줌  리뷰어는 글로 피드백을 줌  위 과정을 반복하다 리뷰어가 배포해도 되겠다는 판단을 한 뒤, 배포함모든 산출물은 소비자를 위한 것PR 또한 산출물이므로 작성한 사람이 아니라 리뷰어를 위한 것리뷰어의 시간을 아껴주는 방향으로 작성해야함3. 왜 코드 리뷰가 어려운가“자신의 기술을 과대평가한 항공사들은 모두 망했음”저자와 리뷰어 모두 자신이 틀릴 수 있다는 자세로 접근해야 함처음에는 나의 코드에 대한 비판이 마치 나에 대한 비판같아서 힘들겠지만,나와 나의 코드는 분리해서 생각해야 함코드 리뷰를 개인적 공격으로 받아들이면 코드 리뷰의 의미가 없어짐처음부터 리뷰를 잘 하기는 힘듦사소한 것부터 언급하면서 차츰 잘 해나가는 방향으로 가야 함나의 글에 충격받는 사람이 있을 수 있다는 것을 잊지 말아야 함“파일 핸들 닫는 것을 잊어버리셨어요”를 “이 바보 같으니라구! 어떻게 파일 핸들 닫는 것을 잊어버릴 수 있지?”라고 받아들일 수 있음Git의 등장으로 소단위 리뷰가 가능하면서 팀원간의 갈등이 많이 사라짐(연사의 과거 경험)4. 기법들4-1. 효율적인 PR 방법4-1-1. 지루한 작업은 컴퓨터로 처리빌드, 테스트, 머지, 머지 컨플릭트 찾기 등은 기계가 더 잘 함사람은 로직만 잘 짤 수 있도록 하기익숙하지 않은 코드 포맷팅이나 약속되지 않은 포맷팅은 리뷰어를 힘들게 함(포맷팅을 전담하는 사람을 두는 곳도 있음)툴만 잘 다루는 것은 의미가 없으나, 툴도 잘 다루는 것은 중요함툴을 잘 다루면 본질적인 문제를 생각하는데 노력을 많이 쓸 수 있지만, 툴에 익숙하지 않으면 툴에 집중하게 되어 본질을 놓치게 됨4-1-2. 스타일 가이드를 통해 스타일 논쟁을 해소스타일 정하는 데 많은 시간을 쓰지 않아야 함  좋은 스타일이 있다면 가져다 쓰거나,  자신만의 스타일 가이드를 점진적으로 만들어 가거나,  위 두 가지를 조합하거나팀 내의 합의를 거쳐 하나를 선정하고 이를 지킬 것4-1-3. PR을 올릴 때 주석 달기description만으로는 설명이 부족할 수 으므로 PR을 한 저자가 구체적인 커멘트를 남기면 리뷰어들의 시간이 절약됨4-1-4. 리뷰어에 모두를 포함하라항상 여러 명에게 PR하는 것이 좋음4-1-5. 의미있는 커밋으로 분리혼자만의 프로젝트라도 커밋을 세세하게 나누어서 PR을 하면 보기 편함코드 리뷰를 하지 않더라도 이 방식은 중요함4-2. 효율적인 리뷰 방법4-2-1. 리뷰는 즉시 시작리뷰를 기다리는 것과 다른 것을 구현 하는 것이 동시에 일어나게 되면, context switching이 일어나 굉장히 비생산적이게 됨빠르게 리뷰를 종료해주는 것이 좋음이 과정이 선순환된다면, 사람들은 언제 리뷰를 처리하는 것이 효율적인지 알게 됨리뷰가 올라오고 나서는 하루를 넘기지 않아야 함코드 리뷰가 어려우면 더 자주해서 익숙해져라!팀원들이 반나절 정도 작업한 양을 30분 내에 모두 리뷰할 수 있도록 PR 속 변경을 최소화 해야 함리뷰어의 노고를 팀 내에서 조직적으로 평가하고 보상해 인정해 주어야 함Latency를 수용할 수 있는지, throughput을 수용할 수 있는지PR의 경우, Latency가 있지만, PairProgramming의 경우 바로 옆에서 피드백을 하므로 Latency가 없음반대로 PR은 한 명의 코드를 여러 명이 리뷰하거나 그 반대도 가능하지만, pair programming의 경우 대부분 1대 1로 진행되기에 throughput 측면에서는 PR이 더 좋음팀원들의 성향에 따라서 PR 또는 Pair Programming을 정하는 것도 좋음4-2-2. 고수준으로 시작, 저수준으로 내려가라처음부터 너무 많은 리뷰를 남기는 것은 위험함무조건 해결해야하는 것들(고수준)을 먼저 리뷰한 뒤,보다 우선 순위가 낮은 것들(저수준)에 대해 리뷰하는 것이 좋음4-2-3. 예제 코드 제공에 관대하라자신이 코드를 잘 작성할 수 없다고 생각해서 리뷰어가 많은 예제를 제시한다고 생각할 수 있음적당한 수의 코드 예제를 제공해야 함4-2-4. 리뷰의 범위를 존중하라4-2-5. 태그를 활용[Nit]는 nit picking(트집 잡기)에서 온 것팀에서 합의한 태그를 이용해 고친다면 더 좋을법한 내용에대해 언급할 수 있음4-2-6. 한 두 등급만 코드 레벨을 올리는 것을 목표로저자가 D등급(간신히 돌아는 가지만 엉망인)의 코드를 쓴 뒤,A+등급의 코드를 쓸 수 있는 리뷰어가 리뷰를 할 경우,A+가 아닌 C나 B의 등급을 받게 도와야 함(강제하는 것이 아니라)사람은 누구나 짧은 시간에 너무 많은 것을 습득할 수 없음4-3. 피드백 방법4-3-1. 절대 “너”라고 하지 마라(너는 왜 맨날 …)누가 잘못을 했는지는 중요하지 않음어떻게 해야 좋아질 것인가가 중요함‘너는’이 아니라‘이 코드는’이라고 말해야 함(사람 지칭하지 말 것)나 전달법을 사용해 소통할 것제안하는 방법으로 대화하기4-3-2. 건설적인 피드백을 하라실수를 하지 않으면 배울 수 없음자신이 알고 있는 방법만 사용하면 손가락은 빨라지고 실수는 없으나 절대로 실력이 늘지는 않음실수를 통해 내가 이런 것을 배웠구나라는 용기를 얻는 것이 중요함건설적인 피드백이 아니면 상처만 남기게 되므로 하고 싶은 말을 도저히 긍정적인 방법으로 할 수 없겠다는 판단이 들면 아무 말도 하지 말 것4-3-3. 진정한 칭찬을 해라칭찬이 존재하면, 팀원들이 나를 후원해주고 있다는 느낌을 받을 수 있음4-3-4. 피드백은 명령이 아니라 요청으로 표현해라일상에서는 동료에게 명령하지 않으면서, 리뷰에서는 명령이 발견됨 리뷰에 리뷰어의 걱정만 표현을 해도 저자는 스스로 문제점을 발견할 수 있고 보다 책임감을 가지고 업무에 임할 수 있게 됨4-3-5. 의견이 아니라 원칙에 기반하여 피드백하라제안과 이유를 함께 제시해야 하며,뚜렷한 이유는 모르겠지만 제시하고 싶다면 나 전달법을 사용해 소통할 것4-3-6. 반복적인 패턴에 대해서 피드백을 제한하라동일한 패턴의 실수를 했다면, 2-3개만 언급을 해도 저자는 스스로 살펴보고 동일한 패턴을 찾아내어 고칠 수 있음최악의 경우, 정말 2-3개만 고치더라도 시간이 지나면 더 많이 고치겠지라고 생각하기4-4. 교착상태 시교착상태를 적극적으로 처리해라  교착상태: 저자와 리뷰어 사이의 커멘트 승인과 반영 충돌 상태반드시 만나서 해결해야 함텍스트 뒤에 상대가 있음을 잊으면 안 됨당장 SW가 최고는 아니지만 적당한 상태라면, 타협하는 자세도 필요함동료가 퇴사하도록 만들면 영원히 최고의 SW는 기대할 수 없게 됨갈등을 회피하지 않고 논리적으로 푸는 자세가 중요VUCA 시대에는 뛰어난 한 사람보다 약간은 부족한 여러 사람들의 협업이 보다 좋은 결과를 만들어냄팀원과의 협업 능력을 얻는 것이 훨씬 의미 있는 일임4-5. 추가적인 사례코드 리뷰를 하는 아주 재밌는 방법20분 정도 짝을 이루어 멋지게 코드를 작성하는 것을 보여준 뒤, Revert 해 스스로 고칠 수 있게 하는 방법20동안 가르쳐 준 내용을 혼자서는 2시간 동안 고치고 있을 수 있지만, 다음부터는 스스로 할 수 있게 됨 풀이를 보고 수학 문제를 푸는 것과 같은 논리임 풀이를 안 보고도 풀어내보면 다음번에는 맞출 수 있게 됨완벽하게 하기 위해 죽자고 싸워서 팀원을 내보내는 것은 팀을 망가뜨리는 행위임코드 리뷰 문화 정착의 어려움 / 극복방법코드 리뷰의 시간을 확보하는 것은 저자의 노력(description 잘 달기, 커밋 잘 나누기, PR 사이즈 작게 유지하기, 자신이 만든 PR은 자신이 먼저 읽고 커멘트 달기)에 달려있음내가 바보같이 짠 코드에 내 동료가 좋은 의견을 주었다고 받아들여야 함뭐든 멋있어보이면 따라하려는 마음이 들게 됨어떻게 하면 장인정신, TDD, pair programming과 같이 한 번에 실행하기 어려운 것들을 받아들일 수 있게 영감을 줄 수 있는가에 대한 대답새로운 것을 도입하면 익숙하지 않기 때문에 고통의 계곡(valley of pain)에 빠지게 되어 성과가 떨어지게 됨긍정적인 마인드로 꾸준히 하다 보면, 고통의 계곡에서 빠져 나가게 되며, 기하급수적으로 성과가 상승하게 됨사람은 계단식으로 성장하며 계단의 앞에는 고통의 계곡이 있음코드 리뷰도 마찬가지임적응하는데 시간이 걸릴 뿐 그 이후에는 결실을 얻게 됨코드 리뷰의 효과코드리뷰를 잘 하기 위해 필요한 기술들리팩터링이 두 권의 책을 읽지 않고 refactoring을 한다고 말할 수 없음Java로 쓴 책과 JavaScript로 쓴 책 모두 볼 것Legacy Code 다루기오래된 책이지만 인상적인 부분들이 많음Clean Code &amp; TDDUnit Testing: 전통파(상태기반), 런던파(interaction기반)Clean Code: 번역본도 있어서 내용이 어렵지 않음. 추천FAQ코드리뷰 자체에 얽매이지 말고 공유와 논의에 초점 맞추기시간이 없어서 코드 리뷰를 못 하겠다면 개발 생산성와 개발 품질의 중요성에 대해 생각해 보아야 함분명 생산성이 증대되는 일임Q &amp; A항아리에 돌을 넣을 때는 큰 돌부터 넣어야 함무엇을 중요하게 생각하는 지 따져보고 먼저 수행해야 함우리에게 중요한 것이 품질이며, 설계라고 한다면, 코드 리뷰는 뺄 수 있는 문제가 아님코드 리뷰에 시간을 따로 책정하면 안 됨처음부터 포함이 되어있어야 함FAQSW는 수학이 아니라 과학임수학은 맞는 것을 증명할 수 있지만, 과학은 틀린 경우가 없다는 것을 증명해 나가는 것이지 맞는 것을 증명할 수 없음버그에 대해 100% 안전해진다고 말할 수 없음측정 항목들이 반기 혹은 1년의 기간 안에 얼만큼씩 좋아지고 있는데 이는 코드 리뷰의 결과라는 것을 증명해내어 상사를 설득해야 함의사결정권자들이 원하는 것은 TDD, 좋은 아키텍쳐, 코드 리뷰 이런 것들이 아니라, 요구사항들이 얼마나 결함없이 빨리 배포 되느냐이기 때문임자동화 테스트 작성, 리팩터링, 코드리뷰, 짝프로그래밍 등은 결과물을 잘 만들어내기 위한 수단이며, 우리가 어떤 도구를 사용할지는 우리 스스로 정하는 것임왜 무엇을 언제까지는 상사가 정할 수 있음어떻게는 상사가 정해주는 것 아님상사의 허락을 받으려고 하는 것이 아님Q &amp; A관련 영상 및 홍보 안내  “[LIVE] 지속가능한 SW 개발을 위한 코드리뷰 :: 4월 우아한테크세미나,” 유튜브 비디오, 2:06:22, 게시자 “우아한Tech,” 2022년 4월 27일, https://youtu.be/ssDMIcPBqUE",
        "url": "/code-review"
    }
    , 
    
    "git-and-github": {
        "title": "Git and github",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행        VCS (Version Control System)CVS (Centralized Version Control)  서버에서 히스토리를 관리  즉각적인 동기화  서버에 문제가 생길시 업무가 중단됨  오프라인에서 인터넷이 없으면 사용 불가DVC (Distributed Version Control)  서버 뿐만 아니라 모든 개발자들이 동일한 히스토리 정보를 가짐  서버에 문제가 생겨도 서로의 정보를 이용해 서버를 복원한 뒤 업무를 이어나갈 수 있음  오프라인에서도 업무 진행 가능  private 또는 cloud 이용 가능  github이 가장 대중적Git  변경 사항만 저장하는 delta-based version control과는 다르게, project의 전체적인 내용을 snapshot해서 가지고 있음  변경되지 않은 내용은 서로 link를 형성하고 있어서 snap shot이 매우 가벼움  버전별, branch별 이동이 자유로움  무료, 오픈소스임  가볍고, 가장 대중적임  오프라인에서도 사용 가능함  실수를 수정하기 쉬우며 branch를 이용한 협업에서 효율적으로 사용됨Git 명령어→ git 공식 사이트에서 모든 명령어 확인 가능→ git 명령어 -option 형식  version 확인git --version  설정 확인git config --list  ‘file’로 설정 확인git config --global -e      carrage-return과 line feed 설정(windows에서는 true, mac에서는 input)git config --global core.autocrlf true    git 초기화(기본적으로 master branch 형성)git init  git 상태 보기git status  git 명령어 관련 속성값 확인하기git 명령어 --he.g.) git status --h, git add --hGit workflow 이해1. Working directory→ project 파일을 작업하는 곳→ git의 추적 여부에 따라 untracked와 tracked로 나뉨  untracked: 새로 만들어진 파일이거나 git을 초기화했을 경우  tracked: git의 추척이 이루어지는 파일→ 수정 여부에 따라 unmodified와 modified로 나뉨(이전 버전과의 비교)  modified 버전만 staging area로 이동 가능관련 명령어  git add 특정 파일 이름  → 해당 파일을 working directory에서 staging area로 옮김  git add *.특정 확장자→ 특정한 확장자의 모든 파일을 staging area로 옮김  git add *→ directory의 모든 파일을 staging area로 옮김→ .으로 시작하는 이름의 파일(e.g.) .gitignore)은 제외  git add .→ directory의 모든 파일을 staging area로 옮김 → 예외 파일 없음  git add * vs. git add .참고 stackoverflow 글      add 후(= staging 이후) 파일을 변경하게 되면, 수정된 내용에 대해서는 tracked modified 상태가 됨(이전에 staging한 내용은 그대로 있음)    git rm --cached 파일이름→ staging area에서 working directory의 untracked 상태로 옮김  git tracking하고 싶지 않은 파일은 .gitignore파일을 생성해 명시하면 됨      log.log  *.log  build/ &lt;- 특정 directory안의 파일들  build/*.log            git status  → 기본적으로 git status --long으로 실행됨      → 간단하게 보려면, git status -s 입력   (A: adding, M: modified, ??: tracking이전 상태로 working directory에 존재)      git diff  → working directory의 변경 사항을 보여줌  → terminal이 아닌 다른 UI(e.g.)vscode)를 연결해 보고 싶다면,  git config --global -e를 실행해 .gitconfig 파일에 다음 내용을 추가한 뒤,  git difftool나 git difftool --staged를 입력하면 vscode에서 실행됨      [diff]  tool = vscode  [difftool \"vscode\"]  cmd = code --wait --diff $LOCAL $REMOTE        git diff --staged (git diff --cached)  → staging area의 변경 사항을 보여줌(q로 escape)2. Staging area  version history에 저장할 준비가 된 파일을 옮겨놓은 곳  commit 명령어로 staging area의 파일을 git repository에 옮김  각 commit에는 snapshot된 정보를 기반으로 고유한 hashcode가 부여되며, 이를 통해 version 정보를 참조함  application 전체를 한꺼번에 commit하기 보다는 application을 기능적인 작은 단위로 나누어 commit하면, 이후에 원하는 변경 사항을 찾아 보기 쉬움  commit message는 보통, 현재시제 동사로 만듦  commit message에 해당하는 코드만 commit 하기!!주의!  commit message를 벗어나 여러 내용이 추가된 코드를 commit하면, 코드 리뷰시 혼동이 오며 commit history를 읽기 어려워짐관련 명령어  git log  → git의 전체적인 history확인  → 누가, 언제 commit했으며, commit의 title과 description을 확인 할 수 있음  git commit -m \"commit message\"  → 간단히 commit message를 입력해 commit 실행  git commit -am \"commit message\"  → working directory의 모든 변경 사항을 포함해(working directory의 파일을 staging area로 옮기는 git add명령어의 사용을 건너 뜀) commit message를 입력해 commit 실행3. .git directory(.git repositor)  git version history를 가지는 곳  checkout 명령어로 언제든 원하는 version으로 돌아갈 수 있음  push 명령어로 local의 git directory를 server에 upload  pull 명령어로 server의 git directory를 local로 download&lt; 출처 &gt;  “깃, 깃허브 이건 알고 사용하자,” 유튜브 비디오, 06:49, 게시자 “드림코딩 by 엘리,” 2020년 11월 10일, https://youtu.be/lPrxhA4PLoA  “깃, 깃허브 제대로 배우기 (기본 마스터편, 실무에서 꿀리지 말자),” 유튜브 비디오, 47:13, 게시자 “드림코딩 by 엘리,” 2020년 11월 17일,https://youtu.be/Z9dvM7qgN9s",
        "url": "/git-and-github"
    }
    , 
    
    "javascript-avoid-both-prototypes-and-classes": {
        "title": "JavaScript(12) - Prototype과 Class 피하기",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage                    이후에 다른 코드도 다시 보기      prototype과 class를 피하는 코드  new와 this의 사용을 피할 수 있음      function secretFactory() {      const secret = \"Favor composition over inheritance, `new` is considered harmful, and the end is near!\"      const spillTheBeans = () =&gt; console.log(secret)      return {          spillTheBeans      }  }  const leaker = secretFactory()  leaker.spillTheBeans()              Console      Favor composition over inheritance, new is considered harmful, and the end is near!        spillTheBeans를 object로 return하는 함수(secretFactory)를 만들게 되면, 함수의 내용에 직접적인 접근을 막을 수 있음another examplefunction spyFactory(infiltrationTarget) {    return {        exfiltrate: infiltrationTarget.spillTheBeans    }}const blackHat = spyFactory(leaker)blackHat.exfiltrate() // Favor composition over inheritance, (...)console.log(blackHat.infiltrationTarget) // undefined (looks like we got away with it)  Console  Favor composition over inheritance, new is considered harmful, and the end is near!  undefined&lt; 출처 &gt;  Justen Robertson, “As a JS Developer, This Is What Keeps Me Up at Night”, Toptal, 2019, https://www.toptal.com/javascript/es6-class-chaos-keeps-js-developer-up.",
        "url": "/JavaScript-avoid-both-prototypes-and-classes"
    }
    , 
    
    "javascript-regular-expressions": {
        "title": "JavaScript(11) - Regular expressions(regex)",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        Regular expression (regex)  1950년, 수학자 Stephen Cole Kleene에 의해 개발됨  slash(/) 안에 찾고자하는 패턴을 작성 후 flag로 옵션을 지정함  → /pattern/flag1. Groups or ranges(1) | (or)/Hi|Hello/gm→ Hi 또는 Hello 매칭(2) () (group)/(Hi|Hello)|(And)/gm→ group #1: Hi 또는 Hello 매칭→ group #2: And 매칭/gr(e|a)y/gm→ gr로 시작, e 또는 a, y로 끝나는 단어 매칭(3) (?:) (group 미지정)/gr(?:e|a)y/gm→ group을 지정하고 싶지 않다면 ( ) 시작에 ?: 추가(4) [] ([]안의 문자 찾기)/gr[ead]y/gm→ [] 안의 문자 중 하나라도 만족하는 단어 매칭    gray, grey, grdy/[a-f]/gm→ a부터 f까지의 문자를 매칭/[a-zA-Z0-9]/gm→ 소문자 a부터 z까지, 대문자 A부터 Z까지, 숫자 0부터 9까지의 문자를 매칭(5) [^] ([]안의 문자를 제외한 나머지 찾기)/[^a-zA-Z0-9]/gm→ 소문자 a부터 z까지, 대문자 A부터 Z까지, 숫자 0부터 9까지의 문자를 제외한 나머지를 매칭/[가-힣]/gm→ 한글 단어 매칭※ 단, 이 방식으로는 ㄱㄴㄷ이나 ㅏㅑㅓㅕ같은 낱글자는 찾을 수 없음2. Quantifiers(1) ? (있거나 없거나)/gra?y/gm→ a가 있거나 없는 문자 매칭gray, gry(2) * (0개 이상)/gra*y/gm→ a가 있거나 없거나 많은 문자 매칭gray, gry, graay, graaay(3) + (하나 혹은 그 이상 연결된)/gra+y/gm→ a가 하나 이상 있는 문자 매칭gray, graay, graaay(4) {n} ({n}앞의 문자 n번 반복)/gra{2}y/gm→ a가 두 번 반복되는 문자 매칭graay(5) {min,} ({min,}앞의 문자 최소 n번 반복)/gra{2,}y/gm→ a가 최소 두 번 반복되는 문자 매칭graay, graaay(6) {min,max} ({min,max}앞의 문자가 최소 min번, 최대 max번 반복)/gra{2,3}y/gm→ a가 최소 두 번, 최대 세 번 반복되는 문자 매칭graay, graaay3. Boundary-type- 단어의 경계를 지정해 검색(1) \\b (단어의 앞 경계 또는 뒷 경계에서 검색)/\\bYa/gm→ 단어 앞에 있는 Ya를 매칭Ya, YaYaYa, Ya/Ya\\b/gm→ 단어 뒤에 있는 Ya를 매칭Ya, YaYaYa, Ya(2) \\B (\\b의 경우를 제외한 검색)/Ya\\B/gm→ 단어 뒤에 있는 Ya를 매칭(/Ya\\b/gm)하는 경우를 제외한 매칭YaYaYa, Ya- 문장의 경계를 지정해 검색(3) ^ (문장의 시작에서 검색)/^Ya/gm→ 문장의 시작에 있는 Ya를 매칭(4) $ (문장의 끝에서 검색)/Ya$/gm→ 문장의 끝에 있는 Ya를 매칭- 전체 문장의 경계를 지정해 검색※ flag에서 m(multiline)을 선택하지 않으면,전체 문장으로 경계를 지정해 검색함/^Ya/g→ 전체 문장의 시작에 있는 Ya를 매칭/Ya$/g→ 전체 문장의 끝에 있는 Ya를 매칭4. Character classes(1) \\특수문자/\\[/gm→ \\ 뒤의 특수 문자 [ 를 매칭(2) ././gm→ 줄바꿈 문자를 제외한 모든 문자를 매칭(3) \\d/\\d/gm→ 숫자(digit)를 매칭(4) \\D/\\D/gm→ 숫자를 제외한 매칭(5) \\w (소문자 w)/\\w/gm→ 문자(word)를 매칭  a, b, c, 가, 나, 다, 1, 2와 같은 문자와 숫자를 포함함  특수문자는 포함하지 않지만, _(언더스코어)는 포함함(6) \\W (대문자 w)/\\W/gm→ 문자를 제외한 매칭(7) \\s (소문자 s)/\\s/gm→ 공백 문자인 띄어쓰기(space), tap, newline 매칭(8) \\S (대문자 S)/\\S/gm→ 공백 문자를 제외한 매칭5. Exercises1. 전화번호 형태 찾기010-898-0893010 898 0893010.898.0893010-405-341202-878-8888/\\d{2,3}[- .]\\d{3}[- .]\\d{4}/gm→ 숫자(\\d)가 {2,3} 최소 두 번, 최대 세 번 반복→ 숫자(\\d)가 {3} 세 번 반복→ 숫자(\\d)가 {4} 네 번 반복→ 숫자 사이에는 [- .] - 또는 공백 또는 . 으로 연결2. 이메일 형태 찾기dream.coder.ellie@gmail.comhello@daum.nethello@daum.co.kr/[a-zA-Z0-9._+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9.]+/gm→ [a-zA-Z0-9._+-]+ 문자(소/대문자, 숫자, ., _, +, -)가 하나 이상→ @ 연결→ [a-zA-Z0-9-]+ 문자(소/대문자, 숫자, -)가 하나 이상→ . 연결→ [a-zA-Z0-9.]+ 문자(소/대문자, 숫자, .)가 하나 이상3. 특정 문자열 찾기http://www.youtu.be/-ZClicWm0zMhttps://www.youtu.be/-ZClicWm0zMhttps://youtu.be/-ZClicWm0zMyoutu.be/-ZClicWm0zM에서 youtube id인 -ZClicWm0zM 만 가져오기/(https?:\\/\\/)?(www.)?youtu.be\\/([a-zA-Z0-9-]{11})/gm  (https?:\\/\\/)?→ ?s s가 있어도 되고 없어도 됨 → :\\/\\/ ://(특수 문자) 연결→ (  )? 있어도 되고 없어도 되는 group  (www.)?→ (  )? 있어도 되고 없어도 되는 group  youtu.be\\/→ youtu.be/ 연결      ([a-zA-Z0-9-]{11})→ 소/대문자,숫자,-로 이루어진 11자리의 문자 group    결과적으로 group #1(http://), group #2(www.), group #3(youtube id)이 생성됨    /(?:https?:\\/\\/)?(?:www.)?youtu.be\\/([a-zA-Z0-9-]{11})/gm        → group #1과 group #2는 grouping하지 않으려면 group의 시작에 (?: )을 입력하면 됨  6. JavaScript 활용  String class의 match함수를 이용할 수 있음    const regex= /(?:https?:\\/\\/)?(?:www.)?youtu.be\\/([a-zA-Z0-9-]{11})/;const url = 'http://www.youtu.be/-ZClicWm0zM';url.match(regex);        배열을 반환함[0]: 매칭되는 전체 문자열,[1]: 매칭되는 group의 data          Console      0: “http://www.youtu.be/-ZClicWm0zM”1: “-ZClicWm0zM”      추가 code를 작성하면,const result = url.match(regex);result[1];  Console  ‘-ZClicWm0zM’const searchTarget = \"Luke Skywarker 02-123-4567 luke@daum.net\\다스베이더 070-9999-9999 darth_vader@gmail.com\\princess leia 010 2454 3457 leia@gmail.com\";const regex = /\\d{2,3}[- ]?\\d{3,4}[- ]?\\d{4}/g;  console.log(searchTarget.match(regex));  Console  [‘02-123-4567’, ‘070-9999-9999’, ‘010 2454 3457’]7. Python 활용  Python은 raw string을 지원해 대표 문자를 표현할 때 역슬래시(\\)를 한 번만 쓸 수 있음      import re  regex = r'\\d{2,3}[- ]?\\d{3,4}[- ]?\\d{4}'  search_target = '''이상한 전화번호 0030589-5-95826  Luke Skywarker 02-123-4567 luke@daum.net  다스베이더 070-9999-9999 darth_vader@gmail.com  princess leia 010 2454 3457 leia@gmail.com'''  # 정규표현식과 일치하는 부분을 모두 찾아주는 파이썬 코드  result = re.findall(regex, search_target)  print(result)              Console      [‘02-123-4567’, ‘070-9999-9999’, ‘010 2454 3457’]      8. 유용한 sitehttps://regexone.com/ → 학습https://regexr.com/ → 정규표현식 입력시 확인&lt; 출처 &gt;  “정규표현식 , 더이상 미루지 말자,” 유튜브 비디오, 22:01, 게시자 “드림코딩 by 엘리,” https://youtu.be/t3M6toIflyQ  프로그래머스 정규표현식 온라인 강의",
        "url": "/JavaScript-regular-expressions"
    }
    , 
    
    "python-making-queries": {
        "title": "Python(4) - Query 만들기 [object 검색]",
            "author": "ohoraming",
                "category": "",
                    "content": "Python 관련 포스팅    Python(1) - Django 설치    Python(2) - MySQL 연결    Python(3) - PostgreSQL 연결    Python(4) - Query 만들기    Python(5) - Django 가상 환경과 settings.py          https://docs.djangoproject.com/en/4.0/topics/db/queries/ 해석Retrieving objects [object 검색]  DB에서 object를 검색하기 위해서는 model class에서 Manager를 통해 query set을 만들어야 함  query set은 db의 object 집합을 의미함  0개 이상의 filter를 가지는데, filter는 주어진 parameter에 기반해 query 결과를 좁혀줌  SQL에서는 query set은 select문과 동일하며, filter는 where나 limit절과 같음  model의 manager를 사용해 query set을 설정함  각 medel은 하나 이상의 manager를 가지며, 이는 기본적으로 objects라고 부름  (manager는 ‘table-level’연산자와 ‘record-level’연산자를 분리시키기 위해 model instance보다는 model class를 통해 접근함 )  model을 통해 직접적으로 접근하려면, 아래와 같이 입력하면 됨      Blog.objects  # &lt;django.db.models.manager.Manager object at ...&gt;  b = Blog(name='Foo', tagline='Bar')  b.objects        manager는 model의 queryset의 main source임예를들어, Blog.objects.all()은 DB에 있는 모든 Blog object를 포함하는 queryset을 반환함1. Retrieving all objects (모든 object 검색)  table의 모든 object를 검색하기 위한 가장 간단한 방법  manager에 대해 all() 메서드를 사용하면 됨  all_entries = Entry.objects.all()2. Retrieving specific objects with filters (filter를 이용한 특정 object 검색)  all()에 의해 반환된 queryset은 db table의 모든 object를 서술함      하지만, 대게, 완전한 object의 특정 부분만 선택적으로 원할 것임    이러한 특정 부분을 생성하기 위해서는, filter 조건을 추가해 최초의 queryset을 정제해야 함  queryset을 정제하기 위한 가장 흔한 두 가지 방법,          filter(**kwargs)  주어진 검색 parameter와 일치하는 object가 포함된 새로운 queryset을 반환 함      exclude(**kwargs)  주어진 검색 parameter와 일치하지 않는 object가 포함된 새로운 queryset을 반환 함      검색 parameters(위의 함수 정의에 있는 **kwargs)는 아래의 Field lookups에 서술된 형태로 있어야 함  예를 들어, 2006년부터의 blog entry들의 queryset을 얻으려면 filter()를 사용함  Entry.objects.filter(pub_date__year=2006)  기본적인 manager class에서도 동일함  Entry.objects.all().filter(pub_date__year=2006)      Chaining filters(연쇄 필터)Entry.objects.filter(    headline__startswith='What').exclude(    pub_date__gte=datetime.date.today()).filter(    pub_date__gte=datetime.date(2005, 1, 30))  db의 모든 entry의 초기 queryset을 가져와, filter를 추가한 뒤, 또 다른 filter인 예외를 추가한 것임  최종 결과는 “What”으로 시작하는 헤드라인을 가지며, 2005년 1월 30일부터 현재사이에 발행된 모든 entry를 포함한 queryset임Filtered QuerySets are unique (걸러진 queryset은 고유함)  queryset을 정제할 때마다, 이전의 queryset과 bound되지 않은 새로운 queryset을 받게 됨  각각의 정제는 독립된 별개의 queryset을 만들며, 저장, 사용, 재사용될 수 있음    q1 = Entry.objects.filter(headline__startswith=\"What\")q2 = q1.exclude(pub_date__gte=datetime.date.today())q3 = q1.filter(pub_date__gte=datetime.date.today())        세 queryset은 독립되어있음          첫 번째는 “What”으로 시작하는 헤드라인을 포함하는 모든 entry를 가지는 기본 queryset      두 번째는 pub_date가 오늘의 record를 제외하는 추가적인 기준을 가진 첫 번째의 부분 집합      세 번째는 pub_date가 오늘인 record만 선택하는 추가적인 기준을 가진 첫 번째의 부분 집합      초기 queryset(q1)은 정제 과정에 영향 받지 않음      QuerySets are lazy (queryset은 게으름)  queryset을 생성하는 것은 어떠한 db 활동과도 연관되지 않음  온종일 filter를 쌓을 수 있고 django는 queryset이 평가될 때까지 실제로 query를 실행하지 않을 것임    q = Entry.objects.filter(headline__startswith=\"What\")q = q.filter(pub_date__lte=datetime.date.today())q = q.exclude(body_text__icontains=\"food\")print(q)        세 번의 db 접근으로 보이지만, 실제로는 마지막 줄의 print(q) 단 한 번만 db에 접근함  일반적으로 queryset의 결과는 “요청”할 때까지 db로부터 가져오지 않음  요청할 때, queryset은 db에 접근해 평가됨 (자세한 내용은 https://docs.djangoproject.com/en/4.0/ref/models/querysets/#when-querysets-are-evaluated 참조)Retrieving a single object with get() (get()으로 단일 object 검색)  filter()는 단 하나의 object가 query와 일치할지라도 하나의 요소가 포함된 queryset을 줌  query와 일치하는 단 하나의 object가 있다고 할 때, 직적적으로 object를 반환하는 get() 메서드를 manager에 사용할 수 있음one_entry = Entry.objects.get(pk=1)  filter()처럼 get()으로 어떤 query문이든 사용할 수 있음(https://docs.djangoproject.com/en/4.0/topics/db/queries/#field-lookups 참조)  [0]의 부분에 대해, get()을 사용하는 것과 filter()를 사용하는 것 사이에는 차이가 있음을 명심할 것  query와 일치하는 결과가 없다면, get()은 DoesNotExist 예외를 발생시킴  이 예외는 query가 수행되는 model class 속성임  pk=1인 entry object가 없다면 django는 Entry.DoesNotExist 예외를 발생시킬 것 임  비슷하게, 하나 이상의 item과 get() query가 일치한다면, django는 항의할 것임  이 경우, model class 속성인 MultipleObjectsReturned를 발생키길 것임Other QuerySet methods[다른 queryset 메서드]  db의 object를 찾아보아야 할 때, 대부분 all(), get(), filter(), exclude()를 사용할 것임  모든 다양한 queryset 메서드의 완전한 리스트를 위해서는 https://docs.djangoproject.com/en/4.0/ref/models/querysets/#queryset-api를 참조할 것Limiting QuerySets[한정 queryset]  특정한 수 만큼의 결과로 queryset을 한정하기 위해 python의 array-slicing 문법의 부분 집합을 사용하라  이는 SQL의 limit와 offset 절과 동일함Entry.objects.all()[:5] → 첫 5개의 object를 반환(LIMIT 5)Entry.objects.all()[5:10] → 여섯~열 번째 object를 반환(OFFSET 5 LIMIT 5)  음수 indexing은 지원되지 않음(예를 들면, Entry.objects.all()[-1])  일반적으로 queryset을 자르는 것은 새로운 queryset을 반환하며, 이는 query를 평가하지 않음      python의 slice 문법의 ‘step’ parameter를 사용하는 것은 예외임Entry.objects.all()[:10:2]→ 첫 10개의 두 번째마다의 object를 list로 반환하는 query 실행    잘려진 queryset를 추가적으로 filtering하거나 ordering하는 것은 금지됨      단일 object를 정제하기 위해 index를 slice하는 대신에 list를 사용함(SELECT foo FROM bar LIMIT 1)Entry.objects.order_by('headline')[0]Entry.objects.order_by('headline')[0:1].get()→ 헤드라인을 알파벳 순서에 따라 정렬한 뒤, db의 첫 Entry를 반환    주어진 기준과 일치하는 object가 없을 시, 첫 번째는 IndexError를, 두 번째는 DoesNotExist를 발생시킴(get()에 대한 자세한 사항은 https://docs.djangoproject.com/en/4.0/ref/models/querysets/#django.db.models.query.QuerySet.get 참조)",
        "url": "/Python-making-queries"
    }
    , 
    
    "test-code": {
        "title": "Test Code",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행        1. Test Code를 작성하는 이유  bug 발생 시점이 이를 수록 수정 비용이 적게 듦수정 비용: 요구 분석/기획 &lt; 설계 &lt; 구현 &lt; 테스트(QA) &lt; 유지 보수/배포  기획 단계에서 요구 조건을 보다 명확하게 이해할 수 있음  예외 케이스의 처리 방식을 다각도로 생각해 볼 수 있음  기능을 구현할 때마다 이미 쌓여있는 Test Code를 모두 테스트하면, 현재의 코드로 인해 다른 코드들이 받을 수 있는 side effect를 즉시 감지할 수 있음(회귀 테스트(Regression Test))  test coverage만큼 코드에 대해 확실할 수 있음2. Test Code를 작성하는 방법  케이스 단위로 테스트를 정리(기능별 분리)  케이스 별로 실제 행위 유발  행위의 결과 확인(pass/fail return)  케이스의 자동화3. 주의 사항  많은 Test Code를 작성하고 유지하는 데 시간이 걸림  이후, 제품을 완전히 변경한다고 하면 시간 낭비일 수 있음  Test Code와 실제 code를 작성하는 개발자가 같다면 사각지대가 발생할 수 있음4. Unit Test Tip  여러 테스트에 동일한 데이터를 재사용하지 않아야 함→ global instance의 재사용 금지  python의 built-in function은 test하지 않아도 됨→ 표준 라이브러리는 test의 목표가 되어선 안 됨",
        "url": "/test-code"
    }
    , 
    
    "python-postgresql": {
        "title": "Python(3) - PostgreSQL 연결",
            "author": "ohoraming",
                "category": "",
                    "content": "Python 관련 포스팅    Python(1) - Django 설치    Python(2) - MySQL 연결    Python(3) - PostgreSQL 연결    Python(4) - Query 만들기    Python(5) - Django 가상 환경과 settings.py        1. 선행 작업  django 설치$ python -m pip install Django  현재 directory에 project 만들기$ django-admin startproject [project 이름]  project파일 위치로 이동해 app 만들기$ cd [project 이름]$ django-admin startapp [app 이름]  server 실행$ python manage.py runserver  pgAdmin 4 다운로드  https://www.pgadmin.org/download/2. pgAdmin 4 실행  Servers - PostgreSQL - Databases 우클릭 - Create - Database... 선택  Database 이름 기입 후, Save3. Database 설정  [app]/settings.py 수정      DATABASES = {      'default': {          'ENGINE': 'django.db.backends.postgresql',          'NAME': 'testdb', # db 이름 설정          'USER': 'postgres',          'PASSWORD': '1234', # 비밀번호 설정          'HOST': 'localhost', # 127.0.0.1 도 가능          'PORT': '5432',      }  }              ENGINE: 자신이 사용할 db 엔진      NAME: db 이름      HOST: db host      PORT: db 실행할 포트(기본값 5432)          INSTALLED_APPS = [      'myapp', # app 등록       'django.contrib.admin',      'django.contrib.auth',      'django.contrib.contenttypes',      'django.contrib.sessions',      'django.contrib.messages',      'django.contrib.staticfiles',  ]              만든 app을 INSTALLED_APPS에 추가      4. Table 만들기  [app]/model.py      from django.db import models  class Question(models.Model):      question_text = models.CharField(max_length=200)      pub_date = models.DateTimeField('date published')  class Choice(models.Model):      question = models.ForeignKey(Question, on_delete=models.CASCADE)      choice_text = models.CharField(max_length=200)      votes = models.IntegerField(default=0)              table 이름을 class 이름으로, column 이름은 변수 이름으로 설정      field type은 아래 문서 참고  https://docs.djangoproject.com/en/4.0/ref/models/fields/#model-field-types      5. DB연결 및 table 생성  psycopg2 설치: Django와 PostgreSQL을 연결$ pip install psycopg2  migrations 폴더 생성: model이 신규로 생성 또는 변경될 시 실행$ python manage.py makemigrations  model class로부터 table 생성 및 수정 실행, 실제 migration을 DB에 적용$ python manage.py migrate",
        "url": "/Python-postgresql"
    }
    , 
    
    "python-mysql": {
        "title": "Python(2) - MySQL 연결",
            "author": "ohoraming",
                "category": "",
                    "content": "Python 관련 포스팅    Python(1) - Django 설치    Python(2) - MySQL 연결    Python(3) - PostgreSQL 연결    Python(4) - Query 만들기    Python(5) - Django 가상 환경과 settings.py        1. pymysql 설치$ pip install pymysql 입력2. DB 연결  import  connect()에 DB 기본 정보 입력    import pymysqlconn = pymysql.connect(host=\"localhost\", user=\"root\", password=\"1234\", db=\"dbpractice\", charset=\"utf8\")      3. cursor 설정  cursor()로 cursor 가져오기          실행 결과가 tuple로 반환됨          curs = conn.cursor()                    실행 결과를 dictionary로 반환하려면,  parameter로 pymysql.cursors.DictCursor 전달          curs = conn.cursor(pymysql.cursors.DictCursor)                        tuple 자료형→ 요솟값이 ()에 둘러싸임t3 = (1, 2, 3)  dictionary 자료형→ Key : Value 쌍 여러 개가 쉼표(,)로 구분되어 { }로 둘러싸여 있음→ Key에는 변하지 않는 고윳값을 사용→ Value에는 문자열과 리스트 모두 사용 가능{Key1:Value1, Key2:Value2, Key3:Value3, …}4. CRUD query문 작성  execute()에 작성      사용할 db 선언(USE) 후 용도에 맞는 query문 작성 시작  → 'USE [사용할 DB이름];'      curs.execute('USE dbpractice;') # cursor를 가져온 상태에서 sql문을 실행      (1) INSERT  execute()에 query문 작성 후, commit()과 close()를 실행    curs.execute('INSERT INTO user (id, name, region, insdt) VALUES(\"hong\", \"홍길동\", \"서울\", now());')conn.commit()conn.close()        sql 변수를 만들어 query문 쓰는 방법    sql = \"INSERT INTO user (id, name, region, insdt) VALUES('hong2', '홍길동2', '서울2', now())\" curs.execute(sql) conn.commit()conn.close()      (2) SELECTsql = \"SELECT * FROM user\"curs.execute(sql) rows = curs.fetchall() # 실행한 데이터를 가져옴print(rows) # 모든 행을 가져옴conn.close()sql = \"SELECT * FROM user WHERE region=%s\"curs.execute(sql) curs.execute(sql, '서울') # %s에 들어갈 문자열을 추가함rows = curs.fetchall() # 실행한 데이터를 가져옴print(rows[2], [\"region\"]) # 특정 행, 열의 내용을 가져옴conn.close()  fetchall(): 모든 레코드를 가져옴  fetmany(): 지정한 개수만큼의 레코드를 가져옴  fetchone(): 하나의 레코드만 가져옴(3) UPDATEsql = \"UPDATE user SET name='포로리' WHERE name='테스트'\"curs.execute(sql)conn.commit()conn.close()(4) DELETEsql = \"DELETE FROM user WHERE name='홍길동'\"curs.execute(sql)conn.commit()conn.close()",
        "url": "/Python-mysql"
    }
    , 
    
    "git-convention": {
        "title": "Git Convention",
            "author": "ohoraming",
                "category": "",
                    "content": "DevOps 관련 포스팅    Git Convention    Test Code    Git and github    왜 Code Review를 해야 하는가    Web API    postgreSQL    AWS 배포하기(1) - RDS (MySQL)    AWS 배포하기(2) - Elastic Beanstalk    Docker 설치 및 실행          https://codingsight.com/git-branching-naming-convention-best-practices/의 내용을 번역한 것입니다.Git Branching Naming Convention: Best PracticesGit branch는 Regular와 Temporary branch로 나눔Regular Git Branches  영구적인 repository에 씀  간단하고 쉬운 naming convention  dev(development)는 main 개발 branch임dev branch의 아이디어는 해당 branch에서만 변경를 일으키고, master branch의 직접적인 변경은 제한함dev branch의 변경은 review(검토)를 받고, 테스트 후 master branch와 merge됨  master는 Git repository의 기본 branch임항상 안정적이며, 어떠한 직접적인 check-in도 허용하지 않음code review이후에만 merge가 가능함팀 구성원 모두가 master를 안정적이며, 최신의 상태로 유지하는 것에 책임이 있음  QA 또는 test branch는 QA testing과 자동 testing을 위한 모든 코드를 포함하고 있음어떠한 변경이 production 환경으로 가기 전, 안정적인 codebase를 위해 반드시 QA testing을 거쳐야 함Temporary Git Branches  이름에서 알 수 있는 것처럼, 필요할 때마다 만들고 없앨 수 있음  Bug Fix, Hot Fix, Feature Branches, Experimental Branches, WIP branches 용도로 사용할 수 있음Git Branching Naming Convention수많은 naming convention이 존재함이 중 가장 좋은 일곱 개의 naming convention에 대해 알아보자1. Start branch name with a Group wordgroup word로 branch 이름을 시작하라.  최고의 방법 중 하나  group word는 자신의 작업 흐름과 일치하는 어느것이든 상관 없음e.g.)Bug - 곧 해결되어야하는 버그,WIP - 작업이 진행 중에 있으며, 조만간 끝나지 않을 것이라 예상되지 않을 때(WIP: work in process/progress)  branch 이름을 봤을 때, 해당 Git branch가 무엇에 대한 것이며, 어떤 목적을 가지고 있는지 알 수 있어야 함e.g.) bug-logo-alignment-issue: logo alignment issue를 고치는 중임wip-ioc-container-added: IoC container를 추가하는 작업을 진행 중임2. Use Unique ID in branch namesbranch이름에 고유한 ID를 사용하라.  branch 이름에 issue tracker ID를 사용할 수 있음  버그를 고칠 때, 선호하는 방법임e.g.)wip-8712-add-testing-module라는 이름은해당 branch가 testing module을 추가하는 업무에 적용되며,issue의 tracking Id는 8712이고,해당 업무가 진행 중에 있다는 것을 보여줌  branch 이름에 외부 tracking ID를 사용하는 것의 장점은 외부 시스템에서 진행 상황을 추적할 수 있다는 것임3. Use Hyphen or Slash as Separators구분자로 하이픈이나 슬래시를 사용하라.  많은 개발자들은 구분자로 슬래시와 하이픈을 사용함      어떤 것을 사용할 지는 자신 또는 자신의 팀의 선호에 달려있음    개인적으로, 하이픈은 이름을 읽기 편하게 만들어 주어서 branch 이름의 구분자로 적절하다고 생각함  슬래시, 하이픈, 언더스코어 모두 사용할 수 있음  중요한 것은 일관되어야 한다는 것임branch 이름에 구분자를 넣으면 두 가지 장점이 있음  가독성을 높일 수 있으며, 혼동을 줄여줄 수 있음  특히, 많은 branch를 다루고 있다면 관리하기 좋음구분자가 없는 featureupgradejqueryversionloginmodule보다는구분자가 있는 feature_upgrade_jquery_version_login_module이 읽기 쉬움4. Git Branch with Author Name작성자 이름을 포함하는 Git branch  많은 회사들은 &lt;author&gt;_&lt;branch-type&gt;_&lt;branch-name&gt; 형식에 따라 작성자의 이름이 branch이름에 있는 것을 선호함e.g.)  rajeev.bera_feature_new-experimental-changes  이 방법은 다른 개발자들의 작업과 추가적인 시스템의 진행 상황을 추적하기 좋음5. Avoid using numbers only숫자만 사용하는 것을 피하라.  몇몇 개발자들은 branch 이름에 issue Id만 기입하는데, 이는 일의 진행에 도움이 되지 않음  예를 들어, 9912라는 branch 이름은 무엇을 설명하는지 알 수가 없음  특히 이 방식은 다른 git branch와 merge하는 중에 혼란과 실수의 가능성만 증가시킴6. Avoid using all naming convention simultaneously모든 naming convention을 동시에 사용하는 것을 피하라.  모든 naming convention을 혼용해 사용하는 것은 좋은 방식이 아님      혼란만 가중시키고, 전반적인 처리 과정을 더 복잡하게 만듦    팀은 업무 중에 사용할 naming convention을 한번 정한 후, 팀원들이 받아들이도록 해야 함  일관성이 가장 중요함7. Avoid long descriptive names for long-lived branches오래가는 branch에 길게 설명하는 이름은 피하라.  branch 이름의 필수적인 특징은 정확해야 하며, 유용한 정보를 주어야 한다는 것임e.g.)wip_login_module_which_will_used_in_the_public_website,  wip_login_module_which_will_used_in_the_internal_website와 같은 branch 이름의 경우, 길고 상세함필수적이지 않음대신에,wip_feature_login_module과 같은 branch 이름은 짧지만 branch의 목적을 잘 설명함Conclusion  Git의 Branching 모델은 강력하지만, branch를 적절하고 효과적으로 다뤄야만 함  필수적인 요건 중 하나는 모든 팀원이 같은 convention을 따라야 하는 것임  pre-commit hook과 같은 Git hook을 사용하는 것도 쉬운 방법 중 하나임",
        "url": "/git-convention"
    }
    , 
    
    "os-contiguous-memory-allocation": {
        "title": "OS(11) - Contiguous Memory Allocation",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Contiguous Memory Allocation (연속 메모리 할당)  최초의 컴퓨터  → OS 없음  → 하나의 process만 main memory에서 돎  OS 등장  → OS와 하나의 process가 돎  → MS-DOS  Multi-programming 환경  → OS와 여러 개의 process가 돎  → booting 직후에는 OS와 big single hole(비어있는 하나의 큰 메모리)  → process 생성과 종료의 반복 후에는 OS와 scattered holes(흩어져있는 여러 메모리)  → memory가 흩어져 있으면 새 process 적재 불가      (hole을 모두 합하면 적재할 process 용량보다 커도 이어져있지 않으면 사용 불가)      (= 외부 단편화(external fragmentation))  연속 메모리 할당 방식          First-fit  → memory를 위(또는 아래)에서 순차적으로 훑어 처음으로 만난 적합한 공간에 할당      Best-fit  → 빈 hole 중에서 새 process 용량과 가장 크기가 비슷한 곳에 할당      Worst-fit  → 빈 hole 중에서 새 process 용량과 가장 크기가 크게 차이나는 곳에 할당      속도: first-fit이 가장 빠름  → 조건에 부합하는 첫 메모리 공간에 할당하기 때문      이용률: first-fit, best-fit 방식이 실행 못하는 process 수가 비교적 적음      first-fit이나 best-fit을 선택하더라도    여전히 external fragmentation 발생  → memory의 약 1/3은 사용 불가      compaction: 흩어져 있는 hole들을 한 곳으로 모으는 것  → 최적의 알고리즘의 부재, 고부담의 단점이 존재      Paging (페이징)  memory에 process가 연속 할당되어야 한다는 생각때문에 발생한 external fragmentation의 해결책  memory를 일정한 크기(= frame)로 자르고 process 역시 같은 일정한 크기(= page)로 자름  → size: frame = page  여러 개의 MMU가 relocation register값을 바꿔주면 각 page들이 hole의 frame에 각각 배치될 때, CPU는 process가 연속 할당되었다고 속음  이때의 MMU는 page table이라고 함Address Translation (주소 변환) ★★★★★  Logical address(논리 주소)와 Physical address(물리 주소)는 MMU를 기준으로 나뉨  Logical address  → CPU가 내는 주소, 2진수(binary)  → 전체 m비트, 하위 n비트(offset 또는 displacement(d)), 상위 m-n비트(page number(p))  Address translation: Logical address → Physical address  → page number: page table의 index 값  → frame number: 해당 page number의 내용  → displacement(변위): 변하지 않음  → page table의 entry 수 = 해당 process가 사용하는 page 수  예제 # 01          page size = 4byte      page table: 5 6 1 2      logical address = 13      pysical address = ?sol.)                  index number      page table                  0      5              1      6              2      1              3      2      page size (= frame size) = 4byte = 2^n = 2^2 → n = 2logical address: 13(10) = 1101(2)logical address = ‘page number(p)’ + ‘displacement(d)’logical address의 뒤에서부터 두 자리(=n)는 (d), 남은 앞의 두 자리는 (p)→ p: 11/01 :dpage number: 11(2) = 3(10)이며, page table 3번 index의 frame number는 2(10) = 10(2)pysical address = ‘frame number(f)’ + ‘displacement(d, ※불변)’이므로pysical address = 1001(2) = 9(10)  예제 # 02          page size = 1KB      page table: 1 2 5 4 8 3 0 6      logical address = 3000, pysical address = ?      pysical address = 0x1A53, logical address = ? sol.)                  index number      page table                  0      1              1      2              2      5              3      4              4      8              5      3              6      0              7      6      page size (= frame size) = 1KB = 2^n = 2^10 → n = 10logical address: 3000(10) = 1011 1011 1000(2)logical address = ‘page number(p)’ + ‘displacement(d)’logical address의 뒤에서부터 열 자리(=n)는 (d), 남은 앞의 두 자리는 (p) → p: 10/11 1011 1000 :dpage number: 10(2) = 2(10)이며, page table 2번 index의 frame number(f)는 5(10) = 101(2)pysical address = frame number(f):101(2) + displacement(d, ※불변): 11 1011 1000(2)이므로pysical address = 1 0111 1011 1000(2) = 6072(10)pysical address: 0x1A53 = 1 1010 0101 0011(2)n = 10, pysical address = ‘frame number(f)’ + ‘displacement(d, ※불변)’이므로→ f: 1 10/10 0101 0011 :dframe number: 110(2) = 6(10)이며, frame number 6의 index number는 7(10) = 111(2)logical address = page number(p):111(2) + displacement(d, ※불변):10 0101 0011(2)이므로logical address = 1 1110 0101 0011(2) = 0x1E53Internal Fragmentation(내부 단편화)  process size가 page size의 배수가 아니어서 마지막 page는 한 frame을 다 못 채우는 것e.g.) process: 15byte, page size: 4byte 일 때,|  4  |  4  |  4  |  3  |으로 마지막 frame의 남은 1byte는 못 쓰게 됨 → 낭비  내부 단편화는 비교적 미미한 낭비라 큰 문제는 아님  내부 단편화의 최대 크기 = page size - 1bytepage table 만들기  CPU register로 page table 만들기          CPU 안의 기억장치인 CPU register로 page table을 만들면, → 장점: 주소 변환 속도 빠름 → 단점: CPU는 memory가 아니라서 table entry 저장 용량이 작음        Memory로 page table 만들기          main memory 안에 넣는 방법으로, → 장점: table entry 수가 많아도 저장 용량에 문제 없음 → 단점: CPU가 낸 주소는 OS 안으로 가는데 그 주소를 한 번 읽어 frame number를 알아낸 뒤, 해당 frame number의 주소를 또 읽어야 해서 속도가 두 배로 느림        TLB(Translation Look-aside Buffer)로 page table 만들기          주소 변환을 목적으로 별도의 SRAM 칩으로 만듦      원리는 cash memory와 비슷      CPU보다는 느리지만 보다 많은 entry 저장 가능      CPU와 memory의 중간 성격      Effective Memory Access Time(유효 메모리 접근 시간)  → CPU가 주소를 내고, 메모리의 내용을 읽어오는데 걸리는 시간  → Tm: 메모리 내용을 읽는데 걸리는 시간  Tb: buffer를 읽는데 걸리는 시간  hit ratio(h): 주소에 해당하는 page table entry가 buffer에 존재할 확률  (buffer의 크기는 충분히 크지 않아서 entry 중 일부만 buffer에 있고 나머지는 memory에 존재)  (★ 중요 예제 ★)  Tm: 100ns, Tb: 20ns, hit ratio(h): 80% 일때, Teff=?  sol.) h(Tb+Tm) + (1-h)(Tb+Tm+Tm)  = (0.8*120ns) + (0.2)(220ns)  = 140ns  → Tm: 100ns인데 40%의 손실이 발생한 결과임  → 하지만, 실제 hit ratio는 95%이상이므로 손실은 아주 작음      ",
        "url": "/OS-contiguous-memory-allocation"
    }
    , 
    
    "python-django": {
        "title": "Python(1) - Django 설치",
            "author": "ohoraming",
                "category": "",
                    "content": "Python 관련 포스팅    Python(1) - Django 설치    Python(2) - MySQL 연결    Python(3) - PostgreSQL 연결    Python(4) - Query 만들기    Python(5) - Django 가상 환경과 settings.py        1. Django 설치$ python -m pip install Django입력설치 끝나면, django-admin 명령을 쓸 수 있음→ $ django-admin 입력시 사용 가능한 서브 명령이 출력됨2. Project 시작2-1. project 생성$ django-admin startproject [project 이름]→ 현재 디렉터리에 project파일이 생성되고 그 안에 같은 이름의 project파일이 생김또는,$ django-admin startproject [project 이름] .→ 현재 디렉터리에 project파일이 생성됨2-2. project 파일 구성  myproject 폴더      myproject/      manage.py      myproject/          __init__.py          asgi.py          settings.py          urls.py          wsgi.py        urls.py파일  → 사용자가 접속하는 path에 따라 그 요청 처리를 지정(routing)  3. Django 실행3-1. manage.py를 이용$ python manage.py입력시 사용 가능한 서브 명령이 출력됨(※ 반드시 현재의 디렉터리가 project폴더인지 확인하기!)$ python manage.py runserver 입력→ 8000번 포트에서 서버가 성공적으로 열림(※ python 개발 서버는 기본적으로 8000번 포트에서 리스닝)3-2. 서버를 끄고 싶다면,ctrl + c 입력3-3. 포트 번호를 바꾸고 싶다면,$ python manage.py runserver [바꿀 포트 번호] 를 입력4. Application 설치4-1. django-admin startapp [app 이름]4-2. app 파일 구성  myapp 폴더      myapp/      migrations/          __init__.py      __init__.py      admin.py      apps.py      models.py      tests.py      views.py      5. Routing5-1. [project]/urls.py 설정→ 큰 틀의 라우팅은 [project]/urls.py 에서 지정  myproject/urls.py      from django.urls import include, path  urlpatterns = [      path('', include('myapp.urls'))  ]        → urlpatterns 정의(routing 관련 정보를 기록)  → path() 를 이용해 url을 넣어줌  path('접속 경로/', include('연결할 app.urls'))  → include(): import 필요  → user 접속시 myapp.urls 로 연결5-2. [app]/urls.py 생성 및 설정  myapp/urls.py      from django.urls import include, path  urlpatterns = [      path(''),      path('create/'),      path('read/1/')  ]        → user가 각 경로로 접속했을 때, views.py로 전달→ views.py: client로 정보를 전달할 함수 작성(index, create, read)    myapp/views.py      from django.http import HttpResponse  from django.shortcuts import render  # Create your views here.  def index(request):      return HttpResponse('Welcome!')  def create(request):      return HttpResponse('Create!')  def read(request):      return HttpResponse('Read!')      5-3. [app]/urls.py 수정→ 사용자가 기본 포트로 접속 시, myapp/views.py의 index 함수를 실행하도록 수정→ views.index import  myapp/urls.py      from django.urls import path  from myapp import views  urlpatterns = [      path('', views.index),      path('create/', view.create),      path('read/1/', view.read)  ]        cf.) path('read/1/', view.read) 에서 1이 바뀔 수 있는 숫자라면, &lt;&gt;를 이용해 작성          myapp/urls.py          path('read/&lt;id&gt;/', views.read)                → views.py의 read()가 해당 인자(id)를 받아서 처리            myapp/views.py          def read(request, id):      return HttpResponse('Read!'+id)                    &lt;routing 정리&gt;  user가 read/1 경로로 접속시  myproject/urls.py로 감     urlpatterns = [     path('', include('myapp.urls')) ]        myapp/urls.py로 위임     path('read/&lt;id&gt;/', views.read)        위 코드에 걸림    myapp/views.py로 위임     def read(request, id):     return HttpResponse('Read!'+id)        read() 함수실행  client에 반환 값 전송",
        "url": "/Python-django"
    }
    , 
    
    "os-main-memory-mgmt": {
        "title": "OS(10) - Main Memory Management",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        메모리 역사  Core memory  → 반지 모양의 철심에 자성 물질을 바른 뒤 전기 흘려 자기장이 발생해 순간적으로 자석이 되는 원리를 이용해 메모리를 만듦  진공관 메모리  → 1950s ~ 1960s, 손가락 3-4개 정도의 크기로 1bit 저장시 4-5개 필요  트랜지스터 메모리  → 1960s ~ 1970s, 반도체 칩 안의 소자로 손톱만한 크기  → 1bit 저장시 4-6개 필요  결국,  공간을 많이 차지해 큰 메모리를 저장하기가 힘듦  집적회로 메모리(현재)  → SRAM: 주로 캐시 메모리 만들 때 사용  → DRAM: 메인 메모리 만들 때 사용언제나 부족한 메모리      메모리 용량은 1970s(64KB)에서 현재(수GB)로 늘어났지만,프로그램의 크기도 증가해 메모리는 여전히 부족함→ 과거(1960s)의 메모리 관리가 여전히 중요한 이유        메모리의 효과적인 사용  → 메모리 낭비 없애기  → virtual memory(가상 메모리): 실제 물리적인 memory보다 크게 보이도록 하는 기술  프로그램을 메모리에 올리기      메모리 구조  → address: cpu가 읽고자하는 memory의 주소  → data: 해당 주소에 있는 내용을 cpu에 전송(양방향)    프로그램 개발          source file: high level language 또는 assembly language  → high level language로 코드 작성 → compiler가 compile하면 기계어로 번역됨 또는, → assembly language로 코드 작성 → assembler가 assemble하면 기계어로 번역됨      object file: compile 또는 assemble 결과 = 기계어 → 유용한 함수들을 모아놓은 library와 object file을 linker가 연결(link) = 실행 파일(exe file)      executable file: 실행 파일 → 하드 디스크에 들어감   → 프로그램을 실행하려면 loader가 main memory에 적재(load) → ‘code + data + stack’ 으로 구성 e.g.) ‘a와 b 중 더 큰 수를 구하라’에서 a, b는 data, 더 큰 수를 구하는 것은 code, 함수 호출시 돌아오는 주소 저장 또는 지역 변수를 저장하는 것은 stack        실행 파일을 메모리에 올릴 때,몇 번지의 메모리에 올릴지 → loader가 결정메인 메모리에 여러 process가 올라와 있다면 → 메모리 번지 변화 → MMU사용  MMU(Memory Management Unit)  → CPU와 memory 사이에 존재  → base, limit, relocation register 존재  → CPU에서 나온 address가 바로 memory로 가는 것을 방지(memory 보호)  → 실행 중인 process가 address를 침범하는지 수시로 감시  e.g.) main.exe가  0번지(→ logical address: CPU가 보내는 주소)에서 실행하도록 프로그래밍 되어있는데, 실행 가능한 메모리는 500번지(→ physical address: 실제 메인 메모리로 가는 주소)가 비어있다면,  OS가 MMU의 relocation register 값을 500으로 변경함  즉, CPU가 봤을 땐 0번지에서 실행, 실제로는 500번지에서 실행되도록 함  (→ address translation)메모리 낭비 방지1. Dynamic Loading(동적 적재)  현대 OS의 처리 방식  프로그램 실행에 반드시 필요한 routine/data만 메모리에 적재(load)  오류처리, 버퍼 용량, java의 class 등이 항상 다 사용되는 것 아님  ‘필요할 때’ 해당 부분을 메모리에 올림  과거에는 Static Loading(정적 적재)를 많이 했음2. Dynamic Linking(동적 연결)  여러 프로그램에 공통으로 사용되는 library를 메모리에 중복해 올리면 메모리 낭비 발생  과거의 Static linking(정적 연결)의 경우, compile후 실행 파일 만들기 전에 link가 일어나 memory 낭비가 있었음  Dynamic Linking(동적 연결)은 common library를 제외한 나머지 부분을 memory에 load 후, 실행할 때 lib를 load해 link  library routine 연결(link)을 실행(load)할 때로 미루는 방법임  → Linux: shared library 확장자 .so(shared object)파일  → Windows: Dyanamic Linking Library(DLL) 확장자 .dll파일3. Swapping  main memory에 적재되어 있지만, 현재는 사용하지 않고 있는 process image를 backing store로 몰아냄  backing store→ 하드 디스크의 일부분으로 실행파일이 저장되어있는 부분(→ file system)과는 다른 곳 → 대략 main memory 정도의 크기면 됨  swapping되어 backing store에 들어가면, 해당 main memory 공간은 비워지고 다른 process가 들어갈 수 있게 됨  backing store에서 main memory로 복귀시 이전과는 다른 자리에 들어가지만, relocation register를 사용하므로 적재 위치는 무관함",
        "url": "/OS-main-memory-mgmt"
    }
    , 
    
    "os-midterm": {
        "title": "OS(9) - Midterm",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        1.프로세스 P1, P2, P3 의 CPU burst time 은 각각 4, 2, 8 msec 이며,세 프로세스는 각각 다른 시간에 ready queue 에 도착했다.즉 P1 은 0 msec에, P2 는 1 msec에, P3 는 5 msec 에 각각 도착했다.CPU scheduling 에 대한 아래 물음에 답하라.(※ 각 경우마다 Gantt chart를 그리고 수식도 적어라.답은 계산하지 않아도 되지만, 반드시 단위는 기록해야 한다).→ 먼저, process별로 알아보기 쉽게 표를 작성            process      Arrival Time(msec)      Burst Time(msec)      Priority                  P1      0      4      3              P2      1      2      2              P3      5      8      1      (a) FCFS 스케쥴링을 사용하면 평균 대기시간(average waiting time)은 얼마인가?    → First Come First Served    → AWT = ( 0 + 3 + 1) / 3 = 4/3msec  P1P2P3 &nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14  (b) 선점형(preemptive) SJF 스케쥴링을 사용할 때 평균반환시간(average turnaround time)은 얼마인가?    → Shortest Job First    → P1의 burst time은 4로 P2보다 길지만 0msec에 P1만 도착해있으므로 P1부터 실행함    → 1msec에서 burst time이 짧은 것은 P2이므로 P2실행    → preemptive이므로 강제전환 가능    → ATT: 도착부터 서비스가 끝나서 나가기까지 걸리는 시간    → ATT = ( 6 + 2 + 9) / 3 = 17/3msec  P1P2P1P1P30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14   (c) Time quantum 이 무한대 (∞) 인 Round-Robin scheduling을 적용하면 평균반환시간은 얼마인가?    → Time quantum = ∞ 이므로 FCFS와 같은 scheduling 양상을 보임    → AWT = ( 4 + 5 + 9) / 3 = 18/3 = 6msec(d) 비선점형(nonpreemptive) 우선순위(priority) 스케쥴링을 사용하면 처리율(throughput)은 얼마인가? 단, 프로세스 P1, P2, P3 의 우선순위는 각각 3, 2, 1 이며, 숫자가 작을수록 우선순위가 높다.    → Priority scheduling이지만 non-preemptive이므로 강제전환 불가    → priority가 더 낮은 P1이 끝나야 P2실행 가능    → throughput: 단위 시간당 처리한 작업의 수    → throughput = 3/14 jobs/msec2.프로세스 P1, P2, P3 의 코드는 각각 다음과 같다. 세마포(semaphore)를 사용하여 아래 조건이 각각 만족되도록 프로세스의 코드를 수정하라. 세마포의 초기값도 나타내어야 한다. 세마포는 한 개 또는 여러 개를 사용할 수 있다.P1: S1P2: S2P3: S3(a) S1 이 끝나야 S2 나 S3 가 실행된다. S2, S3 의 순서는 상관없다.  sem.value = 0;  P1: S1; sem.release(); sem.release();  P2: sem.acquire(); S2;    P3: sem.acquire(); S3;(b) S1 과 S2 가 모두 끝나야만 S3 가 실행된다. S1, S2 의 순서는 상관없다.  semaphore 2개 쓰는 경우,  sem.value = 0;  sem2.value = 0;  P1: S1; sem.release();   P2: S2; sem2.release();    P3: sem.acquire(); sem2.acquire(); S3;  semaphore 1개 쓰는 경우,  sem.value = 0;  P1: S1; sem.release();   P2: S2; sem.release();    P3: sem.acquire(); sem.acquire(); S3;(c) S1, S2, S3 의 순서대로 실행된다. 즉 S1 → S2 → S3 의 순서를 따라야 한다.  sem.value = 0;  sem2.value = 0;  P1: S1; sem.release();  P2: sem.acquire(); S2; sem2.release();  P3: sem2.acquire(); S3;3.a) 프로세스 동기화(process synchronization)란 무엇을 의미하는가?    → 올바른 계산 결과가 나올 수 있도록 임계구역(Critical Section) 문제를 해결하는 것    → process의 실행 순서를 제어하는 것b) 세마포의 내부 구조를 그림으로 나타내고 간략히 설명하라.    → 어떤 process가 acquire()를 호출하면 value가 1감소하고 그 결괏값이 0보다 작으면 해당 process를 queue에 가둠    → 어떤 process가 release()를 호출하면 value가 1증가하고 그 결괏값이 0보다 작거나 같으면 queue에 갇혀있는 process를 깨움(= ready queue에 넣음)c) 어떤 세마포에 다섯 개의 프로세스가 블록(block)되어있다고 가정하자.이때 세마포 내부의 정수 값(value)은 얼마인가?    → 처음 sem.value = 0; 일때, 어떤 process가 acquire()를 호출하면 value = -1이 되고 block 됨. 이 원리로 5개의 process가 acquire()를 호출하면 value = -5가 되고 모두 block됨4.a) 시스템 콜(system call)과 소프트웨어 인터럽트(software interrupt)는 어떤 관련성이 있는가?    → 시스템 콜은 운영체제 서비스를 받기 위해 호출하며 s/w interrupt로 만듦b) 유닉스/리눅스 운영체제에서 fork() 시스템 콜은 어떤 용도로 사용되는가?    → 하나의 parent process에서 여러 개의 child process를 만드는 목적으로 사용함c) 자신이 알고 있는 유닉스/리눅스 시스템 콜의 종류를 세 가지 나열하고 간략히 설명하라.    → exit(): process 종료    → open(): file 열기    → close(): file 닫기    → read(): file 읽기    → write(): file 쓰기    → exec(): 생성된 process에 실행 파일을 복사해 넣음5.다음 용어의 의미를 간략히 설명하라.a) parent process          → process는 process에 의해 만들어지는데, 자신을 만든 process를 parent process라고 함b) command interpreter    → 사용자에게 명령을 받아 그 명령을 번역한 뒤 실행함. os에서는 shell이라고 함c) job scheduler    → job queue 안의 여러 process 중 어떤 것을 main memory로 올려보낼지 결정함.    long-term schedulerd) multi-level queue scheduling    → 여러 개의 queue가 존재. 각각의 queue에 절대적인 우선순위가 존재하거나 CPU time을 차등배분하여 독립된 scheduling 정책을 시행함6.생산자-소비자 문제는 mutex, empty, full 등 세 가지 세마포를 사용하여 해결할 수 있다. mutex 는 상호배타 목적, empty 와 full 은 각각 버퍼의 빈 공간 및 차있는 공간에 대한 접근목적으로 사용한다.a) 버퍼에서 데이터를 빼내어 소비하는 동작을 위 세마포를 포함한 코드로 작성하라.  full.acquire();mutex.acquire();bufcount–;mutex.release();empty.release();b) 생산자와 소비자는 프로세스, 각 세마포는 자원이라고 가정하자. 생산자는 버퍼에 대한 접근 허용을 기다리고 있고, 소비자는 버퍼에서 데이터를 빼내어 소비하는 상황을 나타내는 자원할당도(resource allocation graph)를 그려라. 단, 버퍼 크기는 10이고 그 중 8개가 차있다고 가정한다.    →7.a) 교착상태(deadlock)가 일어나기 위한 네 가지 필요조건 중 보유 및 대기(hold and wait) 란 무슨 의미인가?    → 한 가지 자원을 가지고 있으면서 또 다른 자원을 가지려고 대기하는 것b) 식사하는 철학자 문제(dining philosopher problem)에서 보유 및 대기 조건이 만족되지 않게 하려면 어떻게 해야 하는가?    → 1. 젓가락 두 개를 동시에 집도록 함    → 2. 한 젓가락을 집고, 다른 하나는 이미 사용 중이라면 가지고 있던 젓가락을 내려 놓음     (일부 자원만 이용가능하면 보유 자원을 모두 포기)cf.a) 교착상태(deadlock)가 일어나기 위한 네 가지 필요조건 중 환형대기(circular wait) 란 무슨 의미인가?    → 자원할당도 상에 원이 만들어짐b) 식사하는 철학자 문제(dining philosopher problem)에서 환형대기 조건이 만족되지 않게 하려면 어떻게 해야 하는가?    → 자원에 번호를 부여하고 오름(또는 내림) 차순으로 요청하기    → 짝수번 철학자는 왼쪽에서 오른쪽 순서로, 홀수번 철학자는 오른쪽에서 왼쪽 순서로 젓가락 들기8.아래 문제에서 변수 n, i, s 는 각 프로세스의 지역변수이며, value 는 모든 프로세스가 공통적으로 사용하는 전역변수이다. 프로세스 P1 과 P2 의 코드는 각각 다음과 같다.P1 while (true) {    value = value + n;    n++;    }P2 while (true) {    for (i = 0; i &lt; 100; i++)        s = s + i;        value = value - s;    }(a) 프로세스 동기화 문제에서 임계구역(critical section)이란 무엇을 의미하는가?→ 공통 변수(common variable)를 업데이트 하는 구간(b) 위 P2 프로세스의 코드 내용 중 임계구역에 해당되는 부분은 어디인가? 이유도 설명하라.→ value = value - s;→ 이유: 임계구역은 공통변수를 업데이트하는 구간임.value는 모든 프로세스가 공통 사용하는 공통변수(c) 세마포어(semaphore)를 사용하여 P1, P2  코드의 임계구역 문제를 해결하라. 세마포어의 초기 값도 나타내어라.sem.value = 1; // mutual exclusion용 semaphore  P1 while(true) {      sem.acquire();      value = value + n;  // Critical Section    sem.release();      n++;  }  P1 while(true) {      for(i = 0; i &lt; 100; i++)          s = s + i;          sem.acquire();          value = value - s;  // Critical Section        sem.release();  }(d) 프로세스 스케쥴링 방식과 관계없이 항상 P1 이 P2 보다 전역변수 value 값을 먼저 업데이트 하도록 세마포어를 사용하여 위 P1, P2 의 코드를 수정하여라. 세마포어의 초기 값도 나타내어라.sem.value = 1; // mutual exclusion용 semaphoresem2.value = 0; // ordering용 semaphoreP1 while(true) {    sem.acquire();     value = value + n; // Critical Section    sem.release();     sem2.release();    n++;}P1 while(true) {    for(i = 0; i &lt; 100; i++)        s = s + i;        sem.acquire();        sem2.acquire();        value = value - s; // Critical Section        sem.release();}9.프로세스(process)와 쓰레드(thread)의 유사점 및 차이점을 각각 설명하라.  process → 메모리 공간이 따로 존재  thread → 동일한 메모리 공간을 공유  유사점 → context switching이 일어남10.a) 프로세서(processor)의 이중모드(dual mode)란 무엇을 의미하는가?→ 한 컴퓨터를 여러 사람이 동시에 접속하거나, 한 사람이 여러 프로그램을 동시에 사용하는 환경에서 사용자 모드와 관리자 모드를 나누는 것. 관리자 모드에서만 특권명령과 하드웨어 접근이 가능함b) 이중모드를 사용한 입출력장치(i/o devices) 보호 방법에 대해 설명하여라.→ I/O 명령을 관리자(시스템)모드로 만들어 사용자 모드에서 I/O명령 사용시 SW interrupt가 발생해 해당 process를 종료함11.프로세스의 상태는 new, ready, running, waiting, terminated 등 다섯 종류로 나눌 수 있다.a) 프로세스 상태 변화를 보여주는 상태천이도(state transition diagram)를 그려라.→b) ready 와 waiting 상태는 어떻게 다른지 구분하여 설명하라.→ ready: CPU 서비스를 받기 위해 기다리는 것→ waiting: I/O 서비스를 받기 위해 기다리는 것",
        "url": "/OS-midterm"
    }
    , 
    
    "os-monitor": {
        "title": "OS(8) - Monitor",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Monitor  semaphore 이후 process synchronization tool  semaphore(assembly 수준) 보다 고수준(high level language 수준) 개념  구조  → 공유자원(common variable) + 공유자원 접근함수  → 2개의 queues: 배타동기 + 조건동기  → 공유자원 접근함수에는 최대 1개의 thread만 진입(배타동기)       : mutual exclusion  → common variable에 접근한 method를 실행하고 있다면 다른 thread는 queue에 대기  → 진입 thread가 조건동기(wait())로 block되면 새 thread 진입가능      : conditional synchronization      : wait()을 부르면 실행중인 thread가 queue에 갇힘(= 새 thread 진입가능)  → 새 thread는 조건동기(notify())로 block된 thread를 깨울 수 있음  → 깨운 thread는 현재의 thread가 나가면 진입할 수 있음Java Monitor  Java의 모든 객체는 monitor가 될 수 있음  → 배타동기: synchronized 키워드 사용  → 조건동기: wait(), notify(), notifyAll() method사용일반적 사용(1): Mutual exclusion            synchronized {              Critical-Section              }      → synchronized 키워드만 사용하면 됨: 간단→ monitor는 초깃값 설정 없음→ semaphore는 semaphore import, 초깃값(= 1) 설정,    C.S. 앞뒤로 acquire(), release() 선언: 복잡일반적 사용(2): Ordering            p1      p2                     wait();              S1;      S2;              notify();             ",
        "url": "/OS-monitor"
    }
    , 
    
    "os-deadlock": {
        "title": "OS(7) - Deadlock",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Deadlock  OS는 자원(Resources)을 Application에 잘 나누어주는 역할을 함  자원: CPU, memory, file, printer…  자원을 잘 못 나누어주면 deadlock에 빠지게 됨  Necessary Conditions For Deadlock   → 아래의 네 조건이 모두 만족되어야 deadlock 발생 가능성이 있음          Mutual exclution(상호배타)      Hold and wait(보유 및 점유)      No preemption(비선점)      Circular wait(환형대기)      Resources  동일 형식(type)의 자원이 여러 개 있을 수 있음 → instance  e.g.) 동일 CPU 2개, 동일 printer 3개 등  자원의 사용  [요청 → 사용 → 반납]  자원을 필요로하는 application이 OS에 해당 자원을 요청하면,  OS가 올바른 요청인지 확인 후 허용  application은 자원을 사용 후 OS에 반납  자원 할당도(Resource Allocation Graph)  → 자원은 사각형, 인스턴스는 사각형 안의 점, 프로세스는 원,  할당은 화살표로 표현  자원(R) → 프로세스(P): assign(할당)   프로세스(P) → 자원(R): request(요청)  자원 할당도 상에 원이 만들어지면 환형 대기 상태가 됨Deadlock 처리  Deadlock Prevention(교착상태 방지)  Deadlock Avoidance(교착상태 회피)  Deadlock Detection &amp; Recovery(교착상태 검출 및 복구)  Don’t Care(교착상태 무시)(1) 교착상태 방지  교착상태 필요조건 4가지 중 한 가지 이상 불만족  Mutual exclution(상호배타) 깨려면,  → 자원을 공유  → CPU의 경우 시간을 두고 switching은 가능하지만 동시에 사용 불가  → 원천적으로 불가한 조건  Hold and wait(보유 및 점유) 깨려면,  → 일부의 자원만 가지고 있을 경우, 다른 자원을 기다려야한다면 보유한 자원을 모두 포기  → 단점: 자원 활용율 저하, starvation(process가 진행을 못 함)  No preemption(비선점) 깨려면,  → 자원을 강제로 빼앗음  → CPU는 context switching해서 사용이 가능하나, printer는 불가능함  → 원천적으로 불가한 조건  Circular wait(환형대기) 깨려면,  → e.g.) 자원에 번호를 부여해 순서대로 자원을 요청  → 단점: 자원 활용율 저하(2) 교착상태 회피  deadlock을 자원 요청에 대한 잘못된 승인으로 해석  대출 전문 은행(Banker’s Algorithm)의 파산과 같다고 생각해 더이상 거래가 불가능한 상태로 인식  OS는 자원을 할당할 때 불안전한 할당(Unsafe allocation)이 되지 않도록 해야 함(3) 교착상태 검출 및 복구  hold and wait 되더라도 말리지 않고 원하는 대로 자원을 나눠주다보면 deadlock 발생할 수 있음  deadlock 발생을 허용하며 주기적으로 검사함  검사(detection)시 overhead 발생  → CPU 계산, memory  → 너무 자주하면 deadlock 발견은 빠르지만 overhead 발생 가능성 증가  복구(recovery)  → process 일부 강제 종료  → 자원 선점해 일부 process에 할당  → deadlock 발생 전으로 되돌리려면 주기적으로 현상태를 기억해야 하기에 memory필요(4) 교착상태 무시  deadlock은 실제로 잘 일어나지 않음  4개의 필요조건을 모두 만족하더라도 반드시 일어나는 것 아님  개인 PC의 경우 deadlock발생시 재부팅하면 해결됨  그래서 다른 방법을 시도하는 것 보다는 재부팅이 효율적일 수 있음",
        "url": "/OS-deadlock"
    }
    , 
    
    "os-classical-sync-problems": {
        "title": "OS(6) - Classical Synchronization Problems",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Producer-Consumer Problem  producer(생산자)가 data를 생산하면 consumer(소비자)가 소비  e.g.) compiler(= producer)와 assembler(= consumer)의 경우,  compiler가 high level language를 low level language(assembly어)로 번역하면,  assembler가 번역된 assembly어를 기계어로 번역  e.g.) 파일 서버(= producer)와 클라이언트(= consumer)의 경우,  web browser가 요청을 보내면, server가 file안의 data를 처리해 응답하고, web brower가 web page형태로 보여줌  Bounded Buffer(유한 버퍼)  → 생산한 데이터는 버퍼에 우선 저장함  → buffer의 사이즈는 유한함  → producer는 buffer가 가득 차면 더이상 데이터를 넣을 수 없으며,  → consumer는 buffer가 비면 더이상 데이터를 뺄 수 없음  같은 수의 생산(insert)과 소비(remove)가 이루어졌다면, 결괏값은 0이 나와야 함  common variable인 count와 buf[]를 업데이트하는 C.S.(critical-section)에 동시 진입이 이루어져 최종 결괏값으로 0이 나오지 않음  solution  → mutual exclusion  → semaphore를 이용해 동시접근 방지  → number of permit = 1  Busy-wait  → producer: buffer가 가득차면 기다려야하며,  → consumer: buffer가 비면 기다려야 함  → OS의 ‘효율성 증가’의 목적에 위배됨  → semaphore를 사용해 busy-wait회피  → 무한 loop(while문)를 돌며 기다리지않고 semaphore에 가둠  → CPU 서비스를 받지 않고 block됨  → 빈공간이 생기면 producer를 깨우고, 데이터가 들어오면 consumer를 깨움Readers-Writers Problem  Reader: C.S.을 편집하지 않고 읽기만 함  Writer: C.S.를 읽고 편집함  Reader에 mutual exclusion을 적용하면 비효율적임  Reader가 들어왔는데 다른 Writer가 들어오려하면 block  Writer가 들어와 있으면 Reader는 block  Reader가 들어와 있는데 다른 Reader가 들어온다면 허용(효율성 제고)Dining Philosopher Problem  5명의 철학자와 5개의 젓가락이 서로 엇갈려 한 테이블에 존재  ‘생각 → 식사’의 반복  왼쪽 젓가락을 든 뒤, 오른쪽 젓가락을 듬  number of permit = 1 : 두 철학자 중 한 명만 젓가락 드는 것이 허용됨  결과: starvation: 모든 철학자들이 굶어 죽는 상황 발생  모두가 동시에 젓가락을 드는 상황이 있으면 deadlock에 빠짐",
        "url": "/OS-classical-sync-problems"
    }
    , 
    
    "os-thread": {
        "title": "OS(5) - Thread",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Thread  하나의 프로그램은 하나의 흐름/맥이 있음(single thread)  여러 흐름/맥이 있다면(multi threads)Multithreads  한 프로그램에 둘 이상의 흐름/맥이 있는 경우  짧은 시간 간격으로 흐름이 switching됨  → 여러 흐름/맥이 동시에 실행되는 것 같음(concurrent)  cf.) simultaneous - 실제로 동시에 여러 thread가 실행됨(불가능)Thread vs. Process  하나의 process에는 하나 이상의 thread가 존재(multi-thread program)  하나의 program은 code, data, stack으로 구성됨  thread는 process의 메모리 공간(code, data) 및 자원(file, I/O)을 공유  개별적인 program counter(PC), stack pointer(SP), registers, stack은 비공유  thread가 switching 될 때마다 PC, SP, registers값 모두 변화되므로 공유하지 않음  함수 호출시, stack에 return address, parameter 등을 저장함  현대의 context switching 단위는 process가 아닌 thread!java.lang.Thread  JAVA의 thread는 java.lang package 안에 있음  Thread.run() : thread가 시작되면 run() 메서드가 실행됨  run() 메서드를 override          class MyThread extends Thread {          public void run() {              // code          }      }      Process Synchronization(프로세스 동기화)  엄밀히 말하면 현대 OS는 context switching의 단위가 thread이므로 ‘thread synchronization’이 맞음  일반적으로, main memory에 올라간 process간에는 어떤 식으로든 영향을 주고 받음(cooperating process)  하나의 데이터베이스와 같은 공통된 자원(common resources)에 서로 접근하려 하기때문에 영향을 주고 받게 됨Bank Account Problem  parent는 deposit(입금), child는 withdraw(출금)을 진행  common variable인 balance(잔액)에 대해 동시 update가 발생함  코드를 읽어가다가 context switching이 일어날 경우, balance에 오류가 생김  high level language는 기계어(assembly어)로 변환되는 과정을 거침  한 줄의 코드가 여러 줄의 기계어로 번역될 때 context switching 일어나면 잘못된 결과가 발생  common variable update 진행 중에는 context switching 일어나면 안 됨  → common variable에 대해 한번에 하나의 thread만 update  → Critical-Section Problem (임계 구역 문제)Critical-Section Problem  Critical-Section (C.S.)  → multiple thread로 구성된 system  → common variable changing이 일어날 수 있는 구간  해결  → Mutual exclusion (상호 배타): 하나의 thread만 진입  → Progress (진행): 유한 시간 내에 C.S.에 누가 먼저 진입할 지 결정  → Bounded waiting (유한 대기): 유한 시간 내에 C.S.에 진입할 기회가 생김Synchronization Tools  Semaphores (세마포): 가장 전통적인 동기화 도구  Monitor (모니터): java에서 사용Semaphore  네덜란드의 Edsger Kijkstra가 제안  정수형 변수와 두 개의 동작(P, V)으로 구성  네덜란드어(Proberen, Verhogen)를 영어로 변환  P: acquire()  V: release()    class Semaphore {  int value;  Semaphore(int value) {      // code  }  void acquire() {      value--;      if (value &lt; 0) {          add this process/thread to list;          block;      }  }  void release() {      value++;      if (value &lt;= 0) {          remove a process P from list;          wakeup P;      }  }}        정수형 변수: number of permits  acquire()  → 정수값이 1감소  → 감소된 정수값이 0보다 작으면 호출한 process/thread를 queue안에 넣음      (block상태(= ready queue에 못 감))  → interrupted exception발생(try~catch)  release()  → 정수값이 1증가  → 증가된 정수값이 0보다 작거나 같으면(= queue에 block된 thread 존재) 호출한 process/thread를 queue에서 꺼냄(wake up)일반적 사용(1): Mutual exclusion      number of permits = 1  → C.S.에 하나의 process/thread만 들임                            acquire();                          Critical-Section                          release();                    일반적 사용(2): Ordering      number of permits = 1                            p1          p2                                     acquire();                          S1;          S2;                          release();                               ",
        "url": "/OS-thread"
    }
    , 
    
    "os-cpu-scheduling": {
        "title": "OS(4) - CPU Scheduling",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        CPU Scheduling  Preemptive(선점)  → CPU가 어떤 프로세스를 실행 중에 강제로 쫓아내고 다른 프로세스를 실행시킬 수 있는 scheduling 방식  Non-preemptive(비선점)  → CPU가 어떤 프로세스를 실행 중이라면 해당 프로세스가 I/O를 만나거나 종료되지 않은 상황에서는 절대 scheduling이 일어나지 않는 방식  CPU Utilization(CPU 이용률)  → CPU가 얼마나 열심히 일하고 있는가(%)  Throughput(처리율)  → 시간당 몇 개의 작업을 처리하는가(jobs/sec)  Turnaround time(반환시간)  → 어떤 작업이 ready queue에 들어가서 작업을 끝내고 나오는 시간(sec)  Waiting time(대기시간)  → ready queue에서 기다린 시간(sec)  Response time(응답시간)  → interactive system(대화형 시스템)에서 중요  → 첫 응답이 나오는 데까지 걸리는 시간CPU Scheduling Algorithms1. First-Come, First-Served(FCFS)  먼저 들어오면, 먼저 서비스 함  간단하며, 공평하지만 반드시 좋은 성능을 보장하지는 않음  Average Waiting Time(AWT): ready queue에서 기다리는 시간  단점: Convoy Effect(호위 효과)  → burst time이 긴 프로세스가 앞에 있으면 나머지 프로세스는 뒤에서 오래 기다리게 되는데 그 모양새를 왕을 호위하는 사람에 비유  Non-preeptive scheduling방식2. Shortest-Job-First(SJF)  실행 시간이 짧은 것을 먼저 서비스 함  대기 시간을 줄이는 최적의 방법  단점: 비현실적임(실제 CPU 사용 시간은 실행을 해보기 전에는 알 수 없음)      예측이 필수(과거를 기억하고 있어야 함)      → overhead 발생, 시간이 많이 걸림      → 현실적인 적용이 어려움  선점(preemptive)/비선점(non-preemptive) 두 가지 방식 가능  선점 방식의 경우 최소 잔여 시간 우선3. Priority Scheduling  우선 순위가 높은 것을 먼저 서비스 함  우선 순위 설정          integer number      내부적: 실행 시간 짧은, 메모리 작게 차지하는, I/O가 긴(=CPU가 짧은) 등      외부적: 비용을 많이 지불한 쪽, 정치적인 요소 등        선점 또는 비선점  문제점: starvation 돌입 가능 - 우선 순위에서 밀리면 아무리 기다려도 서비스를 받지 못 함  해결: aging - ready queue에서 오래 기다릴 수록 priority를 조금씩 상승시킴4. Round-Robin(RR)  time-sharing system에서 많이 사용  time quantum(시간 양자) = time slice = Δ  → 10 ~ 100msec: 1초당 10 ~ 100 번의 switching 발생  time quantum에 따라 성능이 달라짐  Δ → ∞ : FCFS  Δ → 0 : switching이 빈번해 여러 프로세스가 동시에 서비스 되는 것 같은 느낌을 줌Multilevel Queue Scheduling  process별로 queue를 달리해 서비스 함  여러 single ready queue의 묶음  queue마다 우선 순위는 다름  CPU time을 각 queue에 차등 배분함  queue별로 다른 scheduling 정책을 실행함Multilevel Feedback Queue Scheduling  여러 개의 queue  → multilevel queue scheduling과의 공통점  모든 process는 하나의 입구로 진입  너무 많은 CPU time 소비 시, 기아 상태가 우려될 시 다른 queue로 이동Process Creation  프로세스는 프로세스에 의해 만들어짐  → parent/child/sibling process, process tree  Process Identifier(PID)  → 사람의 주민등록번호와 같은 것  cf.) Parent Process Identifier(PPID)  system call          fork(): parent process 복사      exec(): 실행파일을 메모리로 가져오기      Process Termination  system call          exit(): 해당 프로세스의 자원 OS에 반환      ",
        "url": "/OS-cpu-scheduling"
    }
    , 
    
    "os-process-mgmt": {
        "title": "OS(3) - Process Management",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Process  실행 중인 프로그램  메인 메모리에 프로그램이 올라오면, text(code) + data + stack도 메인메모리에 생성됨  program vs. process  → 아무 일도 못하는 program, 살아 움직이는 process  상태: new, ready, running, waiting, terminated(출처: https://www.javatpoint.com/os-process-states)PCB(Process Control Block)  = Task Control Block(TCB)  C언어 구조체  OS의 process management 안에 존재  프로세스에 대한 모든 정보가 들어있음  process state(running, ready, waiting, …), program counter(PC, 몇 번째로 실행할지), MMU info(base, limit), CPU time(독점 방지용 시간 기록), process id(고유 번호), …  하나의 프로세스에 대해 하나의 PCB가 할당됨  CPU가 프로그램을 실행하다 I/O를 만나거나 time expired가 되어 다른 프로세스로 갈 때 이전까지 실행했던 정보들을 가지고 있어야 CPU 서비스를 다시 받을 때 이전 상태부터 이어서 받을 수 있음Queues  OS의 process management 안에 존재  각 queue마다 PCB들이 기다리고 있음  Job Queue          굉장히 더디며, 드물게 일어남      프로세스가 완전히 끝나 메모리가 비워져야 이 scheduling이 일어남        Ready Queue          아주 짧은 시간에 빈번하게 발생      프로세스 간의 이동이므로 switching이 빠름        Device Queue          특정 장치(I/O)를 사용하기 위해 대기      Multiprogramming  메인 메모리에 올려진 process의 수  I/O 관련 작업인지 CPU 사용 관련 계싼 작업인지 구분  midium-term scheduler  (※ Job scheduling: long term scheduler, CPU scheduling: short term scheduler)  context switching  → process간 전환  → dispatcher: scheculer가 선택한 process를 실행하도록 여러 값을 바꿔줌  → 자주 일어나면 overhead가 발생하므로 low level 언어로 코드를 구성해야 함",
        "url": "/OS-process-mgmt"
    }
    , 
    
    "os-interrupt-based-system": {
        "title": "OS(2) - Interrupt-Based System",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        Interruptinterrupt: v. 방해하다, 중단시키다→ 어떤 일을 하고 있는데 가로채서 다른 일을 함  현대 운영체제는 interrupt 기반 시스템          booting 완료 후, OS는 메모리에 상주함(resident)      마우스를 움직이면 전기신호(=interrupt)가 발생해 CPU의 interrupt선으로 감 &lt;HW interrupt&gt;      CPU는 하던 일을 중지하고 OS안의 마우스 Interrupt Service Routine(ISR)(코드)으로 점프      특정 icon을 더블클릭하면 interrupt가 걸리고, 더블클릭의 routine(코드)을 실행 &lt;SW interrupt&gt;      하드 디스크 속 특정 프로그램을 메인 메모리에 올림      바탕화면이 바뀌며 특정 프로그램의 화면이 나옴      IRS 종료후 다시 user program 또는 원래의 대기상태로 복귀      interrupt 기반 OS      OS는 여러 가지 code들의 모임  → 평소에는 작동하지 않고 interrupt에 의해 작동함        평소 OS는 대기상태          HW/SW/Internal(내부) interrupt에 의해 운영체제 코드(ISR)을 실행      Internal interrupt  e.g.) divide by zero:   결괏값이 무한대가 되어 컴퓨터에 저장 공간이 없음  → CPU가 내부적인 interrupt로 인식      이중 모드(Dual Mode)  사용 환경          한 컴퓨터(= 서버 컴퓨터)를 여러 사람이 동시에 사용하는 환경      또는 한 사람이 여러 프로그램을 동시에 사용하는 환경 (e.g.) pc, 스마트폰)      또는 한 사람이 특권 명령을 입력하는 경우        사용자 모드(User mode) vs. 관리자 모드(Supervisor mode)          CPU 동작 모드를 두 가지로 진행      OS 서비스가 실행될 때, HW/SW interrupt 발생할 때 관리자 모드 실행      사용자 프로그램이 실행될 때, OS 서비스가 끝나면 다시 사용자 모드 실행      사용자 모드에서는 CPU 중지 명령어(STOP, HALT, RESET 등)와 같은 치명적인 명령어를 사용하지 못하도록 함      관리자(supervisor) 모드 = 시스템(system) 모드 = 모니터(monitor)(감시자) 모드 = 특권(priviliged) 모드      레지스터에 mode를 나타내는 flag가 존재함                  register: 비트들의 모임          flags(carry, negative, zero, overflow)에 monitor 비트를 추가해 0과 1로 이중모드를 구현                      특권 명령(Privileged instruction)          특권 모드에서만 내릴 수 있는 명령어      STOP/HALT/RESET(CPU 중지 명령어), SET_TIMER(일반 유저가 시간을 바꾸면 안 됨), SET_HW(HW의 값을 바꿈)…            일반 User program은 하드 디스크에 접근이 불가함  즉, 서버 컴퓨터에 접속해 타인의 파일을 열람할 수 없다는 뜻(보안 문제)  그래서 OS에 SW interrupt를 걸어 ISR을 실행해 필요한 작업을 하게 함    일반적인 프로그램의 실행          power on      booting: 하드 디스크의 프로그램이 메인 메모리에 적재                  monitor 비트 = 1 : system mode라는 뜻          OS는 system mode에서 동작함          일반 user는 못 내리는 명령 수행 가능                    user mode &gt; (키보드, 마우스) HW interrupt &gt; system mode(ISR) &gt; user mode &gt; (모니터, 디스크, 프린터) &gt; system mode &gt; user mode                  만약, user mode에서 CPU에 STOP 명령을 내리면, CPU는 internal interrupt가 발생했다고 여겨 OS의 ISR로 점프해 해당 명령을 내린 프로그램을 강제 종료시켜 메모리에서 내림  → protection과 연관됨                    하드웨어 보호  입출력장치 보호 → 사용자가 input/output device에 바로 접근하는 것 불가, 반드시 OS를 거쳐야함  메모리 보호 → 자신에게 주어진 메모리 영역을 넘어서는 것을 막음  CPU 보호 → 한 컴퓨터를 여러 명이 쓴다면, CPU 역시 침범 대상이 될 수 있음(1) 입출력장치 보호  서로 다른 사용자들 간의 입출력 정보가 끼어들어 혼선이 생기는 것을 막기 위함  입출력 명령(IN OUT)을 특권 명령으로 지정함  SW interrupt(명령어: INT) &gt; OS에 요청(system mode로 전환) &gt; 입출력 실행 &gt; 다시 user mode로 복귀  이때, 올바른 요청인지 ISR의 초반에 확인하며, 그렇지 않다면 OS가 거부함  user mode에서 사용자가 직접 입출력 명령을 내린다면 ISR로 점프해 해당 프로그램을 종료시킴(privileged instruction violation, 특권 명령 침범)(2) 메모리 보호  다른 사용자의 메모리 혹은 OS영역의 메모리에 접근하는 것을 막기 위함  MMU(Memory Management Unit)를 두어 다른 메모리 영역 침범을 감시함  일종의 문지기로 base registar와 limit register 사이의 값만 통과시킴  Address bus에 base/limit register를 설정해두고 그 범위를 넘어서면 interrupt를 발생시킴  메모리에 잘못된 접근이 일어나면 ISR이 동작해 해당 프로그램을 강제 종료시킴(segment violation, 영역 침범)(3) CPU 보호  한 사용자의 CPU 시간 독점이 다른 사용자의 프로그램 실행을 방해하는 것을 막기 위함  TIMER를 두어 일정 시간 경과시 timer interrupt 발생  timer가 cpu에 주기적으로 interrupt를 걸어줌  interrupt가 발생 &gt; ISR로 jump &gt; ISR의 코드에 한 프로그램이 CPU시간을 독점하는지 감시하는 부분이 존재 &gt; 다른 프로그램으로 강제 전환OS 서비스  프로세스 관리 ★★          process: 메모리에서 실행 중인 program  (vs. program: 하드 디스크에 존재)      process의 생성, 소멸, 활동 일시 정지, 활동 재개, 통신, 동기화, 교착상태 처리 등        주기억장치 관리 ★          process에 메모리 공간 할당, process 종료시 메모리 회수, 가상 메모리        파일 관리          파일의 생성과 삭제, directory(folder))의 생성과 삭제, file 기본 동작, 백업        보조기억장치 관리          하드 디스크, 스마트 폰의 플래시 메모리 등      빈 공간 관리, 저장공간 할당, 디스크 스케줄링        입출력장치 관리          장치 드라이브, 입출력 장치의 성능 향상…      시스템 콜  OS 서비스를 받기 위한 호출(요청)  주요 시스템 콜          Process: end(종료), abort(강제 종료), load(하드 디스크의 프로그램을 메인 메로리로 가져오는 것), execute(실행), create(process 생성), terminate(종료(=end)), get/set attributes(속성)      Memory: allocate(새 객체 생성시 메모리가 필요해 OS에 요청), free(메모리를 다 쓰고 나서 돌려줌)      File: create(생성), delete(삭제)      ",
        "url": "/OS-interrupt-based-system"
    }
    , 
    
    "os-intro": {
        "title": "OS(1) - Introduction",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation        운영체제(Operating System, OS)의 목적  컴퓨터 하드웨어를 잘 관리하여          HW: processor, memory, disk, keyboard, mouse, monitor…      OS가 메모리에 올라오면 User가 컴퓨터를 제어할 수 있게 됨        성능을 높이고          같은 HW라도 OS가 좋으면 성능이 향상됨        사용자에게 편의성을 제공          컴퓨터를 몇 번만 사용해보면 누구나 쉽게 사용할 수 있음      과거, 1940s-1950s에는 전문가(oprator)들만 컴퓨터를 사용할 수 있었음      부팅(Booting)boot: n. 목이 긴 신발, 부츠booting: 부츠를 끌어당겨 신는 것처럼 OS를 메인 메모리로 끌어당김  전원을 켜면  ROM의 code를 읽어와 실행          ROM: Read Only Memory      RAM: main memory의 대부분을 차지(수GB(10^9))        POST(Power-On Self-Test) 실행          전원을 켰을 때, 컴퓨터의 환경 설정이 제대로 되었는지 확인        Boot loader실행          load: v.적재하다      하드 디스크 안의 OS를 메인 메모리로 가져옴        OS가 메인 메모리(RAM)에 올라오면, 명령을 받아들일 준비를 마침          Windows의 경우 바탕화면이 뜨고, Linux의 경우 prompt 창이 뜸      OS = kernel + shell  Kernel          핵심      HW를 둘러싸며 이를 제어, 관리함      실제로 관리하는 프로그램        Shell          OS의 껍질 부분      명령어 해석기(command interpreter)      사용자로부터 명령을 받아 변역 후 해당 명령을 실행함      명령: 아이콘 더블 클릭(Windows), 텍스트 입력(Linux $ls(현 directory file 보여줌), $who(사용자 확인), $ds(디스크 용량 확인) 등)      OS의 위치  Application(App) ⊃ OS  ⊃ HW   정부(government)에 비유할 수 있음  주어진 자원을 할당(resource allocator)하고 관리함(resource manager)  OS가 직접 일을 하지 않고, 각 부서에 맞는 업무를 할당함  프로세스 관리와 메인 메모리 관리가 가장 중요한 업무역사  컴퓨터의 역사          1940s, OS가 없었음      programmer가 종이에 연필로 program을 작성해 전산실에 전달      전달받은대로 구멍(천공)을 뚫은 카드와 compiler 프로그램 카드를 카드 리더기에 올림      프로그램과 compiler가 메모리에 적재되고 기계어가 도출됨      처리기(processor)가 기계어를 실행하면      line printer가 망치로 두드려 결과를 인쇄        Batch processing system(일괄처리)          resident monitor: 최초의 OS      사람(operator)이 직접 compiler, linker, loading을 했음      이 일련의 과정을 메모리에 프로그램으로 넣어(=상주시켜) 자동으로 실행시킴        Multiprogramming system(다중 프로그래밍)          컴퓨터는 비싼 자원      CPU에 비해 i/o의 처리 속도는 느리며, i/o 처리 시간 동안 CPU는 idle상태(가동되지 않는)가 됨      i/o 처리시 다음 user의 연산을 처리      하나의 CPU를 여러 user(program)가 사용해 이용률을 증가시킴      user program의 효율적인 배치를 고민해야 함        Time-sharing system(시공유 시스템)          아주 짧은 시간(1/100초~1/1000초)동안 각 user의 작업을 나눠서 처리함      혼자서 CPU를 쓰는 느낌을 줄 수 있음      OS 기술 천이  컴퓨터 규모별 분류                  Supercomputer &gt; Mainframe &gt; Mini &gt; Micro  Supercomputer: 최강의 컴퓨터. 메모리 용량이 크고, CPU가 빠르며, 보조 기억장치가 뛰어남  Mainframe: 수백 대의 단말기를 연결한 형태  Mini: 수십 대의 단말기를 연결한 형태                    Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embeded  Handheld: 노트북, 태블릿, 스마트 폰  Embeded: 차나 가전에 내장된 형태              고성능 컴퓨터의 기능이 Handheld, Embeded까지 적용됨고등 운영체제(※대학원 과정)  다중 프로세서 시스템  분산 시스템  실시간 시스템",
        "url": "/OS-intro"
    }
    , 
    
    "javascript-promise": {
        "title": "JavaScript(10) - promise",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        promise  비동기(asynchronous)를 callback fn 대신 간편하게 처리하도록 도와주는 내장 object  정해진 장시간의 기능을 수행 후          정상적으로 기능이 수행이 되었다면, 성공 메시지와 처리된 결괏값을 전달해줌      만약 기능 수행 중 예상치 못한 문제가 발생하였다면, 에러를 전달해줌      포인트      State [상태] 이해 프로세스가 heavy한 명령을 수행하고 있는지, 기능 수행 완료 후 성공했는지, 실패했는지        Producer vs. Consumer Producer: 우리가 원하는 데이터를 제공하는 사람 Consumer: 제공된 데이터를 쓰는/필요로 하는 사람  State [promise의 상태]promise가 만들어져서,  지정한 operation을 수행하고 있는 중이라면 pending상태  operation을 성공적으로 끝내게 되면 fulfilled상태  file을 찾을 수 없거나 네트워크에 문제가 생기면 rejected상태Producer vs. Consumer  Producer  원하는 기능을 수행해 해당하는 데이터를 만들어내는 promise object  Consumer  원하는 데이터를 소비1. Producer  Promise 만들기  class라서 new 키워드를 이용해 object를 생성할 수 있음  promise 생성자를 보면 executor라는 callback fn을 전달해주어야 함          executor는 resolve (기능이 정상 수행되어 결괏값을 전달함)와  reject (기능 수행 중 문제가 생기면 호출함) 두 개의 callback fn으로 구성됨      var Promise: PromiseConstructor new &lt;any&gt;(executor: (resolve: (value: any) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; void) =&gt; Promise&lt;any&gt;const promise = new Promise((resolve, reject) =&gt; {// doing some heavy work(network, read files)console.log('doing something...');setTimeout(() =&gt; {    resolve('success!');}, 2000);});→ 어떤 일을 2000ms(=2sec)정도 하다가 잘 마무리 해서 resolve (callback fn)를 호출하여 ‘success!’라는 값을 전달하는 Promise  promise안에서는 다소 heavy한 일을 함  네트워크에서 데이터를 받아오거나 파일에서 큰 데이터를 읽어오는 과정은 시간이 꽤 걸림  시간이 많이 소요되는 과정들을 과정들을 동기적(synchronous)으로 처리하는 동안에 다음 라인의 코드는 실행되지 않게 됨  그래서 시간이 좀 걸리는 일들은 Promise를 만들어 비동기적으로 처리하는 것이 좋음※주의※ Promise를 만드는 순간, 우리가 만든 executor(callback fn)가 바로! 자동 실행됨2. Consumer  producer를 사용하는 주체      then, catch, finally 로 값을 받아옴      promise.then((value) =&gt; {      console.log(value);  })        ⇒ 위에서 만든 promise가 정상적으로 수행이 된다면(then),  value라는 parameter를 받아오는 callback fn을 수행하게 됨    ※ 여기서 value는 resolve(callback fn)으로 전달된 ‘success!’라는 값    Console  doing something…  success!resolve가 아닌 reject를 사용한다면?  reject는 주로 Error object를 통해 값을 전달함      Error object에는 어떤 error가 발생했는지 이유를 잘 명시해야함      const promise = new Promise((resolve, reject) =&gt; {      // doing some heavy work(network, read files)      console.log('doing something...');      setTimeout(() =&gt; {          // resolve('success!');          reject(new Error('no network'));      }, 2000);  });              Console      doing something…      ▶ Uncaught (in promise) Error: no network at promise.js:16:16        console장에 Uncaught (잡히지 않는)라고 뜨는 이유는 then 으로 성공적인 케이스만 다뤘기 때문임→ catch 를 이용해 error가 발생했을 때 어떻게 처리할 지 callback fn을 등록해주면 됨promise     .then((value) =&gt; {        console.log(value);    })    .catch(error =&gt; {        console.log(error);    });  Console  doing something…  Error: no network at promise.js:15:16⇒ catch의 등록으로 더는 error를 생성하지 않게 됨then과 catch를 chaining  promise의 then을 호출하면, 똑같은 Promise를 리턴함  리턴된 Promise에 catch를 호출할 수 있게 됨  (array에서 map, sort, join함수를 중첩 사용하는 것도 chaining)(method) Promise&lt;any&gt;.then&lt;void, never&gt;(onfulfilled?: (value: any) =&gt; void | PromiseLike&lt;void&gt;, onrejected?: (reason: any) =&gt; PromiseLike&lt;never&gt;): Promise&lt;void&gt;finally는 성패와 상관 없이 무조건 마지막에 호출됨const promise = new Promise((resolve, reject) =&gt; {    console.log('doing something...');    setTimeout(() =&gt; {        resolve('success!');        // reject(new Error('no network'));    }, 2000);});promise     .then((value) =&gt; {        console.log(value);    })    .catch(error =&gt; {        console.log(error);    })    .finally(() =&gt; {        console.log('finally!');    });  Console  doing something…  success!  finally!const promise = new Promise((resolve, reject) =&gt; {    console.log('doing something...');    setTimeout(() =&gt; {        // resolve('success!');        reject(new Error('no network'));    }, 2000);});promise     .then((value) =&gt; {        console.log(value);    })    .catch(error =&gt; {        console.log(error);    })    .finally(() =&gt; {        console.log('finally!');    });  Console  doing something…  Error: no network at promise.js:15:16  finally!3. Promise chainingconst fetchNumber = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(1), 1000); // 1 전달});fetchNumber.then(num =&gt; num * 2) // 1 * 2 = 2.then(num =&gt; num * 3) // 2 * 3 = 6.then(num =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; resolve(num -1), 1000);    }); // 6 - 1 = 5}).then(num =&gt; console.log(num)); // 5  Console  54. Error handlingOriginal codeconst getHen = () =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve('🐓'), 1000);});const getEgg = hen =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(`${hen} =&gt; 🥚`), 1000);});const cook = egg =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(`${egg} =&gt; 🍳`), 1000);});getHen().then(hen =&gt; getEgg(hen)).then(egg =&gt; cook(egg)).then(meal =&gt; console.log(meal));  Console  🐓 =&gt; 🥚 =&gt; 🍳tip.then에서 받아오는 value를 바로 callback fn의 parameter로 전달할 때, 중복되는 value는 생략이 가능함getHen().then(getEgg).then(cook).then(console.log)Error 발생const getHen = () =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve('🐓'), 1000);});const getEgg = hen =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; reject(new Error(`error! ${hen} =&gt; 🥚`)), 1000);});const cook = egg =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(`${egg} =&gt; 🍳`), 1000);});  Console  ▶ Uncaught ReferenceError: Cannot access ‘getHen’ before initialization at promise.js:62:1Error를 .catch로 잡아주면,getHen().then(getEgg).then(cook).then(console.log).catch(console.log)  Console  Error: error! 🐓 =&gt; 🥚 at promise.js:71:29.then뒤에 .catch로 바로 error를 처리해주면 됨getHen().then(getEgg).catch(error =&gt; {    return '🥖';}).then(cook).then(console.log).catch(console.log)  Console  🥖 =&gt; 🍳&lt; 출처 &gt;  “자바스크립트 12. 프로미스 개념부터 활용까지 JavaScript Promise | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 28:09, 게시자 “드림코딩 by 엘리,” 2020년 6월 18일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-promise"
    }
    , 
    
    "javascript-callback": {
        "title": "JavaScript(9) - callback",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        Synchronous vs. AsynchronousSynchronous(동기적)  JavaScript는 synchronous(동기적)          hoisting이 된 이후부터, 코드 작성 순서에 맞추어 동기적으로 실행됨      hoisting이란?  var, function declararion 은 선언 지점과 상관 없이 JS engine에 의해 문서의 최상단으로 끌어올려짐          console.log('1');  console.log('2');  console.log('3');              Console      123      Asynchronous (비동기적)  언제 코드가 실행될 지 예측 불가  e.g.) setTimeout(): 지정한 시간이 지나면 전달한 callback fn을 호출함      function setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number          console.log('1');  setTimeout(function() {      console.log('2');  }, 1000);  console.log('3');        코드를 순차적으로 읽어감    → console.log(’1’); 실행  → setTimeout() 을 만나 1000ms(=1sec) 뒤 callback fn 실행 요청  → console.log(’3’) 실행  → 1초 뒤 console.log(’2’) 실행  (tip) 위의 callback fn는 arrow fn으로 바꿔 쓸 수 있음console.log('1');setTimeout(() =&gt; console.log('2'), 1000);console.log('3');Callback fn  나중에 다시(back) 부르는(call) 함수  synchronous와 asynchronous 두 가지가 존재함Synchronous callbackfunction printImmediately(print) {    print();}printImmediately(() =&gt; console.log('hello'));Asynchronous callbackfunction printWithDelay(print, timeout) {    setTimeout(print, timeout);}printWithDelay(()=&gt; console.log('async callback'), 2000);Resultconsole.log('1');setTimeout(() =&gt; console.log('2'), 1000);console.log('3');// Synchronous callbackfunction printImmediately(print) {    print();}printImmediately(() =&gt; console.log('hello'));// Asynchronous callbackfunction printWithDelay(print, timeout) {    setTimeout(print, timeout);}printWithDelay(()=&gt; console.log('async callback'), 2000);      코드 실행순으로 코드 나열을 다시 해보면,      function printImmediately(print) { // hoisting      print();  }  function printWithDelay(print, timeout) { // hoisting      setTimeout(print, timeout);  }  console.log('1'); // 동기  setTimeout(() =&gt; console.log('2'), 1000); // 비동기  console.log('3'); // 동기  printImmediately(() =&gt; console.log('hello')); // 동기  printWithDelay(()=&gt; console.log('async callback'), 2000); // 비동기        function declaration은 hoist되므로 코드 최상단으로 끌어올려짐  function printImmediately와 function printWithDelay가 상단으로 이동  이후 코드들을 순서대로 실행함  ‘1 → 3 → hello → 2 → async callback’ 순으로 console이 찍힘  Callback hell exampleclass UserStorage {    loginUser(id, password, onSuccess, onError) {        setTimeout(() =&gt; {            if((id === 'minji' &amp;&amp; password === 'pass') ||            (id === 'someone' &amp;&amp; password === 'pass too')            ) {                onSuccess(id);            } else {                onError(new Error('not found'));            }        }, 2000);    }    getRoles(user, onSuccess, onError) {        setTimeout(() =&gt; {            if(user === 'minji') {                onSuccess({ name: 'minji', role: 'admin' });            } else {                onError(new Error('no access'));            }        }, 1000);    }}  사용자에게 id와 password를 입력 받음  서버에 login  login이 성공적이라면 해당 id를 받아와 role 요청  role을 성공적으로 받아오면 name과 role이 있는 사용자의 object를 출력const userStorage = new UserStorage();const id = prompt('enter your id');const password = prompt('enter your password');userStorage.loginUser(    id,     password,     user =&gt; {        userStorage.getRoles(            user,            userWithRole =&gt; {                alert(`Hello ${userWithRole.name}, you have a ${userWithRole.role} role`);            },             error =&gt; {                console.log(error);            }             );    },     error =&gt; {console.log(error)});문제점  가독성이 떨어짐  error, debugging, 유지 보수가 어려움&lt; 출처 &gt;  “자바스크립트 11. 비동기 처리의 시작 콜백 이해하기, 콜백 지옥 체험 😱 JavaScript Callback | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 21:15, 게시자 “드림코딩 by 엘리,” 2020년 6월 9일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-callback"
    }
    , 
    
    "javascript-json": {
        "title": "JavaScript(8) - JSON",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        JSON  JavaScript Object Notation  ECMAScript 3rd 1999 Object { key : value } 에서 영감 받은 data format  data를 주고 받을 수 있는 가장 간단한 file format  text를 기반으로 해서 가벼움  읽기 쉬움  key와 value로 이루어진 file format  서버와 data를 주고 받을 때, data의 serialization과 전송을 위해 사용  프로그래밍 언어와 플랫폼에 상관 없이 사용 가능parse();parse(text: string, reviver?: (this: any, key: string, value: any) =&gt; any): any;  string data를 받아 object type으로 변환함  optional type의 reviver이라는 callbackfn을 이용하면 보다 세밀한 조건을 적용해 data를 object로 바꿀 수 있음stringify();stringify(value: any, replacer?: (this: any, key: string, value: any) =&gt; any, space?: string | number): string;  object를 받아 string으로 변환함  optional type의 replacer이라는 callbackfn을 이용하면 보다 세밀한 조건을 적용해 object를 string으로 바꿀 수 있음Object to JSONstringify(obj)      boolean / array를 JSON으로 변환     // boolean to JSON let json = JSON.stringify(true);  console.log(json); // array to JSON json = JSON.stringify(['apple', 'banana']);  console.log(json);              Console      true[“apple”, “banana”]        ※ array의 경우, [\"  \"] 형태로 출력        object를 JSON으로 변환     // object to JSON const rabbit = {      name: 'tokki',     color: 'white',     size: null,     birthDate: new Date(),     symbol: Symbol('id'),      jump: () =&gt; {          console.log(`${this.name} can jump!`);     }, }; json = JSON.stringify(rabbit); console.log(json);              Console      {“name”:”tokki”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}        ※ console에서 null은 출력되지만, Symbol과 function은 누락됨. 즉, JSON으로 변환 불가!    ⇒ boolean, array, object는 JSON으로 변환(serialize)가능 Symbol이나 함수는 JSON으로 변환 불가        (array 형태 callbackfn 사용) 원하는 property를 JSON으로 변환     json = JSON.stringify(rabbit, ['name', 'color']); console.log(json);              Console      {“name”:”tokki”,”color”:”white”}            (함수 형태 callbackfn 사용) property를 JSON으로 변환 + 조건 추가     json = JSON.stringify(rabbit, (key, value) =&gt; {     console.log(`key: ${key}, value: ${value}`);     return key === 'name' ? 'minji' : value; // 조건 추가 }); console.log(json);              Console      key: , value: [object Object]      key: name, value: tokki      key: color, value: white      key: size, value: null      key: birthDate, value: 2021-08-11T08:11:16.785Z      key: jump, value: () =&gt; {console.log(${this.name} can jump!);}      {“name”:”minji”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}      JSON to Objectparse(json)      object를 JSON으로 변환하면 string type이 됨    json = JSON.stringify(rabbit);console.log(json);console.log(typeof json);              Console      {“name”:”tokki”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}      string      ※주의※JSON을 다시 object로 만들 때 역시 함수가 포함되지 않는다!(serialize 할 때(object to JSON), 함수는 포함되지 않았음)json = JSON.stringify(rabbit);const obj = JSON.parse(json); console.log(obj);console.log(obj.birthDate.getDate()); // error!  Console  {“name”:”tokki”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}※ object의 birthDate에 있던 Date()는 JSON으로 바뀌면서 string type이 되어 더이상 getDate();를 호출할 수 없게 됨      callbackfn을 이용해 object를 유의미하게 사용하기    const obj = JSON.parse(json, (key, value) =&gt; {    console.log(`key: ${key}, value: ${value}`);    return key === 'birthDate' ? new Date(value) : value;});console.log(obj);console.log(obj.birthDate.getDate());              Console      {name: ‘tokki’, color: ‘white’, size: null, birthDate: Thu Aug 12 2021 17:01:29 GMT+0900 (한국 표준시)}      12      tip) 유용한 사이트JSON Diff checker: http://www.jsondiff.com/JSON Beautifier/editor: https://jsonbeautifier.org/→ 정렬이 어그러진 JSON파일을 읽기 쉽게 정렬해줌JSON Parser: https://jsonparser.org/→ JSON을 object type으로 변환시켜 보여줌JSON Validator: https://tools.learningcontainer.com/j…→ JSON data 유효성 검사기&lt; 출처 &gt;  “자바스크립트 10. JSON 개념 정리 와 활용방법 및 유용한 사이트 공유 JavaScript JSON | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 22:36, 게시자 “드림코딩 by 엘리,” 2020년 5월 31일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-json"
    }
    , 
    
    "javascript-array": {
        "title": "JavaScript(7) - array",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        Declaration  new keyword 사용  [ ] 사용 ★★★★★    const arr1 = new Array();const arr2 = [1, 2];      Index position      array의 마지막 element를 찾을 때는 [array.length-1] 를 사용함    const fruits = ['🍦','🍉'];console.log(fruits);console.log(fruits[2]); // undefinedconsole.log(fruits[fruits.length-1]);              Console      (2) [‘🍦’, ‘🍉’]undefined🍉      Looping over an arraya. for loop  console.log(fruits);  for(let i = 0; i &lt; fruits.length; i++) {      console.log(fruits[i]);  }  Console  (2) [‘🍦’, ‘🍉’]🍦🍉b. for of  console.log(fruits);  for(let fruit of fruits){      console.log(fruit);  }  Console  (2) [‘🍦’, ‘🍉’]🍦🍉c. forEach  array에 들어있는 각 element마다 함수를 수행함      전달한 callback 함수를 value마다 호출    console.log(fruits);fruits.forEach(function (fruit, index, array) {    console.log(fruit, index, array);});        (※ 보통, forEach에서 array는 잘 받아오지 않음)          Console      (2) [‘🍦’, ‘🍉’]🍦 0 ▶ (2) [‘🍦’, ‘🍉’]🍉 1 ▶ (2) [‘🍦’, ‘🍉’]        console.log(fruit, index, array);              Console      🍦 0 ▶ (2) [‘🍦’, ‘🍉’]🍉 1 ▶ (2) [‘🍦’, ‘🍉’]        console.log(fruit, index);              Console      🍦 0🍉 1        console.log(fruit);              Console      🍦🍉        ※ Arrow function에서,logic이 한 줄이면 {} curly braces와 ; semicolon을 지울 수 있음    // Arrow functionfruits.forEach((fruit, index) =&gt; console.log(fruit, index));fruits.forEach((fruit) =&gt; console.log(fruit));      Addition, deletion and copya. push      배열의 마지막에 element를 더해줌    console.log(fruits);fruits.push('🍑', '🥝');console.log(fruits);              Console      (2) [‘🍦’, ‘🍉’]   (4) [‘🍦’, ‘🍉’, ‘🍑’, ‘🥝’]      b. pop  배열의 마지막 element를 제거    console.log(fruits);fruits.pop();fruits.pop();console.log(fruits);              Console      (4) [‘🍦’, ‘🍉’, ‘🍑’, ‘🥝’]  (2) [‘🍦’, ‘🍉’]      c. unshift  배열 시작에 element를 더함    console.log(fruits);fruits.unshift('🍌', '🍍');console.log(fruits);              Console      (2) [‘🍦’, ‘🍉’]   (4) [‘🍌’, ‘🍍,’🍦’, ‘🍉’]      d. shift      배열의 첫 element를 제거함    console.log(fruits);fruits.shift();console.log(fruits);              Console      (4) [‘🍌’, ‘🍍,’🍦’, ‘🍉’]  (3) [‘🍍,’🍦’, ‘🍉’]      배열의 ‘마지막’에 element를 넣고 빼는 push 와 pop 이 빠름배열의 ‘시작’에 element를 넣고 빼는 shift 와 unshift 는 느림⇒ 배열 시작 지점(index[0])에 item을 넣으려면 기존의 item들을 뒤로 이동 후 새 item을 넣어야 하며, 반대로 배열 시작 지점(index[0])의 item을 빼면, 이후의 item들을 앞으로 이동해야 하기에 시간이 오래 걸림e. splice  ( vs. slice : 배열 자체의 수정 없이 특정 부분 리턴 )  splice(index number) : 해당 index부터 끝까지 지움  splice(index number, 지우려는 개수) : 해당 index부터 개수 만큼 지움      splice(index number, 지우려는 개수, 'item1', 'item2') : 해당 index부터 개수만큼 지우고 item1, item2 추가    console.log(fruits);fruits.splice(4);console.log(fruits);fruits.splice(0, 2);console.log(fruits);fruits.splice(1, 1, '🍇', '🍏');console.log(fruits);              Console      (6) [‘🍍,’🍦’, ‘🍉’, ‘🍈’, ‘🥥’, ‘🍊’]  (4) [‘🍍,’🍦’, ‘🍉’, ‘🍈’](2) [‘🍉’, ‘🍈’](3) [‘🍉’, ‘🍇’, ‘🍏’]      f. slice  ( vs. splice : 기존 배열 자체를 수정함)  배열의 특정한 부분을 배열로 리턴      slice(시작 index, 끝나는 index);  ※ 이때, 끝나는 index는 배제됨(exclusive)!    const array = [1, 2, 3, 4, 5];const result = array.slice(2,5);console.log(result);console.log(array);              Console      (3) [3, 4, 5](5) [1, 2, 3, 4, 5]      g. concat      서로 다른 두 배열을 연결함  array이름.concat(연결할 array);      console.log(fruits);  const food = ['🍕', '🍔'];  const newFood = fruits.concat(food);  console.log(newFood);              Console      (3) [‘🍉’, ‘🍇’, ‘🍏’](5) [‘🍉’, ‘🍇’, ‘🍏’, ‘🍕’, ‘🍔’]      Searchinga. indexOf  array이름.indexOf('index를 알고 싶은 element', [검색을 시작할 index]);  배열 내에 item이 처음 등장하는 index 반환 (vs. lastIndexOf)      해당 array에 없는 item일 경우 -1 반환    console.log(fruits);console.log(fruits.indexOf('🍇'));              Console      (3) [‘🍉’, ‘🍇’, ‘🍏’]1            요소의 모든 index찾기    let indices = [];let array = ['a', 'b', 'a', 'c', 'a', 'd'];let element = 'a';let idx = array.indexOf(element);while (idx != -1) {  indices.push(idx);  idx = array.indexOf(element, idx + 1);}console.log(indices); // [0, 2, 4]        참고: Array.prototype.indexOf() - JavaScript | MDN  b. lastIndexOf  배열 내에 둘 이상의 같은 element가 있을 때, 마지막 element의 index를 반환함      array이름.lastIndexOf('index를 알고 싶은 element');    console.log(fruits);console.log('indexOf');console.log(fruits.indexOf('🍎'))console.log('lastIndexOf');console.log(fruits.lastIndexOf('🍎'));              Console      (5) [‘🍎’, ‘🍉’, ‘🍇’, ‘🍏’, ‘🍎’]04      c. includes  array이름.includes('element');  특정 element가 배열에 존재하는지 확인할 때      true/false 반환    console.log(fruits);console.log(fruits.includes('🍏')); // trueconsole.log(fruits.includes('🍤')); // false              Console      (5) [‘🍎’, ‘🍉’, ‘🍇’, ‘🍏’, ‘🍎’]truefalse      d. find  find&lt;S extends T&gt;(predicate: (this: void, value: T, index: number, obj: T[]) =&gt; value is S, thisArg?: any): S | undefined;  전달된 predicate(callbackfn)가 첫 번째로 true인 요소를 만나면 그 값을 반환(아니면 undefined 반환)하며 predicate는 종료됨      predicate(value, index, obj)는 배열의 각 요소마다 적용되며, boolean을 반환    class Student {  constructor(name, age, enrolled, score) {    this.name = name;    this.age = age;    this.enrolled = enrolled;    this.score = score;  }}const students = [  new Student('A', 29, true, 45),  new Student('B', 28, false, 80),  new Student('C', 30, true, 90),  new Student('D', 40, false, 66),  new Student('E', 18, true, 88),];const result = students.find((student)=&gt;student.score === 90);console.log(result);              Console      ▶ Student {name: ‘C’, age: 30, enrolled: true, score: 90}      e. filter  filter&lt;S extends T&gt;(predicate: (value: T, index: number, array: T[]) =&gt; value is S, thisArg?: any): S[];      predicate(callbackfn)를 전달해 이 함수가 true인 배열의 요소들만 모아 새 배열을 반환함    const result = students.filter((student)=&gt;student.enrolled === true);console.log(result);              Console      ▶ (3) [Student, Student, Student]      ▶ 0: Student {name: ‘A’, age: 29, enrolled: true, score: 45}      ▶ 1: Student {name: ‘C’, age: 30, enrolled: true, score: 90}      ▶ 2: Student {name: ‘E’, age: 18, enrolled: true, score: 88}      length: 3      ▶ [[Prototype]]: Array(0)      Stringa. join  join(separator?: string): string;  배열의 모든 요소들을 더해서 string으로 반환      (opt) 원하는 separator(구분자)를 넣어서 반환할 수 있음    const fruits = ['apple', 'banana', 'orange'];const result1 = fruits.join();const result2 = fruits.join('\\n');const result3 = fruits.join('|');console.log(result1);console.log(result2);console.log(result3);        result1: w/o separator          Console      apple, banana, orange        result2: separator \\n          Console      applebananaorange        result3: separator: |          Console      apple|banana|orange      b. splitsplit(separator: string | RegExp, limit?: number): string[];  separator(string 또는 정규표현식(RegExp))에 따라 여러 가지 문자열을 나눠 줌      (opt) limit에 반환할 배열의 크기를 지정할 수 있음    const fruits = '🍎, 🥝, 🍌, 🍒';const result1 = fruits.split(', ');const result2 = fruits.split(', ', 3);console.log(result1);console.log(result2);              Console      (4) [“🍎”, “🥝”, “🍌”, “🍒”](3) [“🍎”, “🥝”, “🍌”]      c. reversereverse(): T[];  배열의 순서를 거꾸로 만들어 리턴※ (주의) 배열 자체가 변화됨!    const array = [1, 2, 3, 4, 5];const result = array.reverse();console.log(result);console.log(array);              Console      (5) [5, 4, 3, 2, 1](5) [5, 4, 3, 2, 1]      d. sortsort(compareFn?: (a: T, b: T) =&gt; number): this;  compareFn(callbackfn)에 이전 값(a)과 현재 값(b)이 전달됨  a - b의 결과가 음수이면, a &lt; b 이므로 a, b 순서로 정렬됨  b, a 순서로 정렬하고 싶다면, b - a 를 리턴하게 하면 됨e. mapmap&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[];  배열 내의 각 요소들이 callbackfn에 의해 다른 값으로 mapping되어 반환  // students의 score만 배열로 반환  const result = students.map((student)=&gt;student.score);  console.log(result);  Console  (5) [45, 80, 90, 66, 88]f. somesome(predicate: (value: T, index: number, array: T[]) =&gt; unknown, thisArg?: any): boolean;  배열의 요소 중 predicate(callbackfn)를 만족하는 것이 하나라도 있는지 확인함      ( vs. every : 배열의 요소 전부가 predicate(callbackfn)를 만족하는지 확인)    // student의 score가 50점 미만인 요소가 있는지 확인const result = students.some((student) =&gt; student.score &lt; 50);console.log(result);              Console      true      g. reducereduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T): T;  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue: T): T;  원하는 시작부터 배열의 모든 요소의 값을 누적  return값 정의 필수  previousValue : 이전에 callbackfn에서 리턴한 값  currentValue : 배열의 요소를 순차적으로 전달 받은 값      initialValue를 지정할 수 있음    // student score의 평균 구하기const result = students.reduce((prev, curr) =&gt; prev + curr.score, 0);console.log(result/students.length);              Console      73.8      tip!      map, filter, join과 같이 배열 자체를 리턴하는 함수들은 서로 섞어서 사용이 가능    const result = students  .map((student) =&gt; student.score)  .filter((score) =&gt; score &gt; 50)  .join(', ');  console.log(result.toString());              Console      80, 90, 66, 88      &lt; 출처 &gt;  ‘자바스크립트 8. 배열 제대로 알고 쓰자. 자바스크립트 배열 개념과 APIs 총정리 | 프론트엔드 개발자 입문편 (JavaScript ES6 ),’ 유튜브 비디오, 32:07, 게시자 ‘드림코딩 by 엘리,’ 2020년 5월 17일, https://youtu.be/tJieVCgGzhs  ‘자바스크립트 9. 유용한 10가지 배열 함수들. Array APIs 총정리 | 프론트엔드 개발자 입문편 ( JavaScript ES6),’ 유튜브 비디오, 37:13, 게시자 ‘드림코딩 by 엘리,’ 2020년 5월 24일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-array"
    }
    , 
    
    "javascript-object": {
        "title": "JavaScript(6) - object",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage          &lt; 추천 &gt;Object 관련 글 읽어보기Object - JavaScript | MDNObject의 등장 배경const name = 'minji';const age = 5;print(name, age);function print(name, age) {    console.log(name);    console.log(age);}  Console  minji  5  primitive type은 변수 하나당 값을 하나만 할당할 수 있음  함수의 parameter로 사용할 변수를 일일이 써주어야 함  인자가 많아질 수록 추가해야하는 코드가 늘어나 관리가 힘들어지며, grouping해서 논리적으로 생각하기도 어려움Object 생성- Literals and properties  object literal syntax  → { } curly braces를 사용해 생성  → { } 안에 내용을 입력      const obj1 = {}; // 'object literal' syntax        object constructor syntax  → new keyword를 사용해 생성  → Object에서 정의된 constructor가 호출되기 때문      const obj2 = new Object(); // 'object consrtuctor' syntax        object = { key : value }  → object는 key와 value의 집합체      function print(person) {      console.log(person.name);      console.log(person.age);  }  const minji = {name: 'minji', age: 5}; // object 생성  print(minji);              Console      minji      5      object의 property에 접근하기1. 일반적인 경우(. 사용)  object.key 형태    const minji = {name: 'minji', age: 5};console.log(minji.name); // minjiconsole.log(minji.address); // undefined              Console      minji      undefined        존재하지 않는 property(여기서는 address)를 호출하면 undefined 반환2. Computed properties  동적으로 원하는 key 값을 받아오고 싶을 때는 [] 을 사용함  (→ computed properties)      key는 반드시 string type(['string'])으로 설정해야 함!      const minji = {name: 'minji', age: 5};  console.log(minji['name']); // minji  console.log(minji[name]); // undefined              Console      minji      undefined        동적으로 key에 관련된 value를 받아와야 할 때 유용함      const minji = {name: 'minji', age: 5};  function printValue(obj, key) {      console.log(obj[key]); // computed properties  }  printValue(minji, 'name'); // minji              Console      minji      Property value shorthand  동일한 key와 value를 반복해서 object를 생성하는 경우,    const person1 = {name: 'Bob', age: 2};const person2 = {name: 'Steve', age: 3};const person3 = {name: 'Dave', age: 4};        function을 사용해 간단하게 나타낼 수 있음  → 이 방법은 과거, JavaScript에 class가 없었을 때 많이 사용했음  → 아래 예시처럼 key와 value의 이름이 동일하다면, name: name,을 name,으로 축약할 수 있음      function makePerson(name, age) {      return {          name: name, // name, 으로 축약 가능          age: age, // age, 로 축약 가능      }  }  const person4 = makePerson('minji', 5);  console.log(person4);              Console      {name: ‘minji’, age: 5}            ★ Constructor function 사용  → class의 constructor와 비슷하다고 생각하면 됨  → 순수하게 object를 생성하며, 함수 이름의 첫 글자는 대문자로 시작    → return 대신 this를 사용  → this = {};와 return this;가 생략된 것으로, JavaScript engine이 알아서 object를 생성해 줌   → new를 사용해 호출      // Constructor function  function Person(name, age) {      // this = {};       this.name = name;      this.age = age;      // return this;   }  const person5 = new Person('baby', 3);  console.log(person5);              Console      Person {name: ‘baby’, age: 3}      in operator  in keyword로 해당 object 내에 key가 존재하는 지 확인(boolean 반환)      const minji = {name: 'minji', age: 5};  console.log('name' in minji); // true  console.log('age' in minji); // true  console.log('random' in minji); // false  console.log(minji.random); // undefined              Console      true      true      false      undefined      for…in vs. for…of      특정 object 안의 key를 모두 받을 때는 in을 사용함      const minji = {name: 'minji', age: 5};  for (key in minji) {      console.log(key);  }              Console      name      age            Array나 List같은 data를 순차적으로 계산하거나 출력할 때,  → 기존 방법      const array = [1, 2, 4, 5];  for (let i = 0; i &lt; array.length; i++) {      console.log(array[i]);  }              Console      1      2      4      5        → of를 사용하면 보다 간편하게 작성 가능      const array = [1, 2, 4, 5];  for (value of array) {      console.log(value);  }               Console      1      2      4      5      Cloning (object 복제하기)  예전 방법  → 빈 object를 만들고, for…in으로 복제할 원본의 값을 하나하나 넣어줌      const user = {name: 'minji', age: 10};  const user2 = {};  for (key in user) {      user2[key] = user[key];  }  console.log(user2);              Console      {name: ‘minji’, age: ‘10’}        Object.assign() 사용  → 복사하고자 하는 target과 원문인 source를 parameter로 전달하면, 이 둘을 합쳐 return함  ※ 새로운 함수나 API를 쓰기 전에는 항상 parameter와 return값을 숙지할 것!  | 참고: Object.assign() - Java Script | MDN          Syntax          Object.assign(target, ...sources)                            Parameters  target  The target object — what to apply the sources’ properties to, which is returned after it is modified.        sources  The source object(s) — objects containing the properties you want to apply.                    Return value  The target object.          const source = { name: 'elephant', age: '6'}; // 복제할 원문  const result = {}; // 빈 target 생성  Object.assign(result, source);          console.log(result);                          Console          {name: ‘elephant’, age: ‘6’}                아래처럼 축약해서 적어도 됨          const source = { name: 'elephant', age: '6'};  const result = Object.assign({}, source); // 축약된 형태  console.log(result);                    다른 예시          const fruit1 = { color: 'red'};  const fruit2 = { color: 'yellow', size: 'small' };  const fruit3 = { color: 'green'};  const mixed1 = Object.assign({}, fruit1, fruit2);  const mixed2 = Object.assign({}, fruit1, fruit2, fruit3);  console.log(mixed1.color); // yellow  console.log(mixed2.color); // green  console.log(mixed2.size); // small                          Console          yellow          green          small                      ※ 주의! ※  assign&lt;T, U, V&gt;(target: T, source1: U, source2: V): T &amp; U &amp; V; 를 적용할 때,  나중에 나오는 source2는 먼저 있던 source1의 내용을 덮어 쓰게 됨  &lt; 출처 &gt;  “자바스크립트 7. 오브젝트 넌 뭐니? | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 23:03, 게시자 “드림코딩 by 엘리,” 2020년 5월 6일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-object"
    }
    , 
    
    "javascript-classobject": {
        "title": "JavaScript(5) - class vs. object",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        Class  ES6부터 도입됨  다양한 object를 만들기 위한 청사진, template (일종의 ‘틀’)  관련 있는 변수와 함수를 묶어 놓은 것  속성(field)과 method로 구성됨  한 번만 선언함  data가 들어있지 않아 메모리에 올라가지 않음      붕어빵 틀로 비유함      class Person {      // constructor      constructor(name, age) {          // fields          // 두 fields에 전달받은 name과 age를 할당          this.name = name;          this.age = age;      }      // methods      speak() {          console.log(`${this.name}: hello!`);      }  }  const minji = new Person('minji', 20); // 새 object를 생성  console.log(minji.name);  console.log(minji.age);  minji.speak(); // speak 함수 호출              Console      minji      20      minji: hello!      Object  class를 이용해 새로운 instance를 생성한 것  data를 넣었기때문에 메모리에 올라감  여러 맛의 붕어빵들로 비유함Getter and setters  class를 사용하는 사용자가 잘못된 값을 입력시 이에 대응할 수 있도록 getter/setter를 사용함      class User {      constructor(firstName, lastName, age) {          this.firstName = firstName;          this.lastName = lastName;          this.age = age;      }      // getter      get age() {          return this._age;      }      // setter      set age(value) {          // 다소 공격적인 대응          // if(value &lt; 0) {          //     throw Error('age can not be negative');          // }          // this._age = value;          // 수정한 대응          this._age = value &lt; 0 ? 0 : value;          // 나이는 음수 안 됨          // 음수 입력시 0 반환      }  }  const user1 = new User('Steve', 'Jobs', -1);  console.log(user1.age);              Console      0        age라는 getter를 정의하는 순간, this.age는 getter를 호출하게 됨.  age라는 setter를 정의하는 순간, =age; 가 할당되며 setter를 호출하게 됨.  전달된 value는 setter안의 this._age에 할당되며, 메모리 값을 업데이트 함.  getter/setter에 쓰이는 변수의 이름(여기서는 _age)을 달리 사용해 call stack이 다 차는 것을 막을 수 있음public, private  too soon!  public: constructor(생성자)를 사용하지 않고 field를 정의하면  외부에서 접근이 가능함      private: # 기호와 함께 field를 정의하면(# names: hash names로 발음) 클래스 내부에서만 접근, 변경이 가능함      class Experiment {      publicField = 2; // public      #privateField = 0; // private  }  const experiment = new Experiment();  console.log(experiment.publicField); // 2  console.log(experiment.privateField); // undefined              Console      2      undefined      static  too soon!      class가 가진 고유의 값과 반복 사용하는 method들을 object와 상관없이 class이름을 이용해 호출함      class Article {      static publisher = 'I am MINJI';      constructor(articleNumber) {          this.articleNumber = articleNumber;      }      static printPublisher() {          console.log(Article.publisher);      }  }  const article1 = new Article(1); // 새 object 생성  const article2 = new Article(2); // 새 object 생성  console.log(article1.publisher); // undefined  // class(Article)로 호출해야 함  console.log(Article.publisher);  Article.printPublisher();              Console      undefined      I am MINJI      I am MINJI      Inheritance (상속)  extends 키워드를 사용하면 해당 클래스의 fields와 methods를 포함할 수 있음  overriding: 필요한 함수만 재정의해 사용함  overriding을 할 경우 부모의 함수는 더 이상 쓸 수 없게 됨      overriding했지만, 부모의 함수를 쓰고 싶다면, super. 를 사용해 부모 함수를 호출      class Shape {      constructor(width, height, color) {          this.width = width;          this.height = height;          this.color = color;      }      draw() {          console.log(`drawing ${this.color} color!`);      }      getArea() {          return this.width * this.height;      }  }  class Rectangle extends Shape {}  class Triangle extends Shape {      draw() { // overriding          super.draw(); // 부모 함수의 draw() 호출          console.log('🔺');       }      getArea() { // overriding          return (this.width * this.height) / 2;      }      toString() { // object의 함수를 overriding          return `Triangle: color: ${this.color}`      }  }  const rectangle = new Rectangle(20, 20, 'blue');  rectangle.draw();  console.log(rectangle.getArea());  const triangle = new Triangle(20, 20, 'red');  triangle.draw();  console.log(triangle.getArea());              Console      drawing blue color!      400      drawing red color!      🔺      200      ※ 참고: Inheritance in JavaScript - Web 개발 학습하기 | MDNinstanceOf  object instanceof class  왼쪽의 object가 오른쪽의 class의 instance인지 확인함      boolean 반환      console.log(rectangle instanceof Rectangle); // true  console.log(triangle instanceof Rectangle); // false  console.log(triangle instanceof Triangle); // true  console.log(triangle instanceof Shape); // true  console.log(triangle instanceof Object); // true  console.log(triangle.toString());              Console      true      false      true      true      true      Triangle: color: red      ※ JS에서 만든 모든 object class들은 JS의 Object를 상속함⇒ 즉, 어떤 object든 공통적으로 존재하는 함수들을 사용할 수 있다는 말!예시 코드의 Triangle class의 toString처럼 overriding해서 사용하면 됨Standard built-in objects(표준 내장 객체)※ 참고: Standard built-in objects - JavaScript | MDN  Value properties, Error objects, Indexed Collections, keyed collections, Promise, JSON 참고!&lt; 출처 &gt;  “자바스크립트 6. 클래스와 오브젝트의 차이점(class vs object), 객체지향 언어 클래스 정리 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 25:36, 게시자 “드림코딩 by 엘리,” 2020년 4월 27일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-classObject"
    }
    , 
    
    "javascript-function": {
        "title": "JavaScript(4) - function",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        Function  구조          function key word를 사용함      전달받을 값은 ()안에 기입함      함수 안에서 동작할 코드는 {}(code block) 안에 작성         function name (param1, param2) {     logic...     return; }                      규칙          하나의 함수는 하나의 일을 하도록 만들어야 함      doSomething, command, verb 형태로 명명      JS에서 함수는 object        cf.) First-class function          → variable에 할당 가능          → 다른 함수의 parameter로 전달이 가능          → return 값으로 지정 가능    함수의 종류                  특정 기능을 수행하는 함수         function doSomething() {     console.log('hello!'); }                            계산을 수행한 뒤 특정 값을 전달하는 함수         function add(a, b) {     const sum = a + b;     return sum; }                      특징          program을 구성하는 기본적인 building block      subprogram이라 불리며 여러 번 재사용이 가능함      한 가지의 일(=기능 수행)을 하거나, 값을 계산/전달하기 위해 사용      Function declaration [함수 선언식]  hoist 가능: 함수가 선언되기 전에 호출이 가능함  (※ hoisting: 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림)※ 다른 언어와 다르게, JS에서는 parameter type과 return type을 명시하지 않음    ⇒ TypeScript로 보완// javascript 코드function log(message) {    console.log(message);    return 0;}// typescript 코드function log(message: string): number {    console.log(message);    return 0;}※참고: TS Playground - An online editor for exploring TypeScript and JavaScriptFunction expression [함수 표현식]  hoist 불가: 변수에 할당된 다음부터 호출이 가능함      const print = function () { // annonymous function      console.log('print');  }      Call a function [함수 호출]  함수를 선언만하고 호출하지 않으면 코드블럭 안의 코드가 실행되지 않음  방법          함수이름();으로 함수를 호출          print(); // 함수 호출                    변수();로 할당된 함수를 호출                  함수를 변수에 할당 가능함          ‘함수 이름’만 변수에 할당함 ()없이             const printAgain = print; // print함수를 printAgain 변수에 할당 printAgain(); // 호출                                          Parameters  함수 이름을 이용해 함수 자체를 인자로 전달할 수 있음  주의: 함수()형태로 쓰면 안 됨!      function doAnything(add) { // add 함수를 인자로 전달      console.log(add);      const result_add = add(3, 4);      console.log(result_add);  }  doAnything(add);      Default parameters  added in ES6  parameter= 옆에 원하는 default값을 지정할 수 있음      function showMessage(message, from = 'unknown') {      console.log(`${message} by ${from}`);  }  showMessage('Hi!');               Console      Hi! by unknown      Rest parameters  added in ES6      parameter 자리에 ... 을 입력하면 배열 형태로 전달      function printAll(...args) {      for (let i = 0; i &lt; args.length; i++) {          console.log(args[i]);      }  }  printAll('one', 'two', 'three');              Console      one      two      three      ※ 위의 for문을 보다 간단하게 나타내면,// 1.for (const arg of args) {    console.log(arg); }// 2.args.forEach((arg) =&gt; console.log(arg));Local scope  global variable vs. local variable          global variable: 함수의 바깥에 선언한 변수. 문서 전체에서 사용 가능함      local variable: 함수의 안에 선언한 변수. 함수 안에서만 사용 가능함 (block scope)  ※ 참고: Variable scope - JavaScript | MDN        밖에서는 안이 보이지 않고, 안에서만 밖을 볼 수 있다!          block 안에서는 global/local variable에 접근 가능,  block 밖에서는 local variable에 접근 불가              parent/child function에서도 동일하게 적용됨          let globalMessage = 'global'; // global variable  function printMessage() {      let message = 'hello'; // local variable      console.log(message);       console.log(globalMessage);  }  printMessage();  console.log(message); //error                          Console          hello          global                    Return a value  함수 내에 return;을 기술하지 않은 경우, return undefined; 가 생략된 것으로 간주함Tip: Early return, early exit  조건이 맞지 않을 때는 빨리 return 해서 함수를 종료 시킬 것!      필요한 logic들은 그 이후에 작성하는 것이 좋음      // bad  function upgradeUser(user) {      if(user.point &gt; 10) {          // long upgrade logic...      }  }  // good  function upgradeUser(user) {      if(user.point &lt;= 10) {          return;      }      // long upgrade logic...  }      Callback function      callback function이 parameter로 전달됨      function randomQuiz(answer, printYes, printNo) {      if (answer === 'love you') {          printYes();      } else {          printNo();      }  }  // annonymous function  const printYes = function() {       console.log('yes!');  };  // named function  const printNo = function print() {      console.log('no!');  };  randomQuiz('wrong', printYes, printNo);  randomQuiz('love you', printYes, printNo);              Console      no!      yes!        annonymous function: 이름 없는 함수      named function: 이름 있는 함수    ⇒ debugging할 때, stack trace에 함수 이름이 나오게 하기 위함  ⇒ 또는 recursion할 때 사용 ( ※ call stack )  Arrow function  항상 annonymous!      function 키워드, return 키워드, {}curly braces를 지운 뒤, 이 둘을 =&gt; 로 연결      // Annonymous function  const simplePrint = function() {      console.log(`simplePrint!`);      };  // Arrow function  const simplePrint = () =&gt; console.log('simplePrint!');            함수의 내용이 길어진다면, block을 설정하면 됨!이때, block을 설정했으므로 반드시 return 값을 기입해주어야 함!      const simpleMultiply = (a, b) =&gt; {      // do something more      return a * b;  };      IIFE  Immediately Invoked Function Expression  함수의 생성과 호출을 동시에 할 때 사용      (function)();형태로 사용      (function hello() {      console.log('IIFE');  })();              Console      IIFE      &lt; 출처 &gt;  “자바스크립트 5. Arrow Function은 무엇인가? 함수의 선언과 표현 | 프론트엔드 개발자 입문편(JavaScript ES6),” 유튜브 비디오, 25:01, 게시자 “드림코딩 by 엘리,” 2020년 4월 22일, https://youtu.be/tJieVCgGzhs  “프로그래밍 포기 하지 마세요 (자바스크립트 함수 기본편),” 유튜브 비디오, 17:17, 게시자 “드림코딩 by 엘리,” 2020년 7월 10일, https://youtu.be/PuG2VW18O1E",
        "url": "/JavaScript-function"
    }
    , 
    
    "javascript-operator": {
        "title": "JavaScript(3) - operator",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        1. String concatenation```javascriptconsole.log('my' + ' cat');console.log('1' + 2);console.log(`string literals: 1 + 2 = ${1 + 2}`);console.log(`string literals: '''''3 + 4 = ${3 + 4}`);```&gt; **Console**  &gt; ###### my cat  &gt; ###### 12  &gt; ###### string literals: 1 + 2 = 3  &gt; ###### string literals:  &gt; ###### '''''  &gt;   &gt; ###### 3 + 4 = 7  - string literals의 경우, \\`(backtick)을 사용해 줄 바꿈과 **`'`** (single qoutation mark) 입력이 쉬움2. Logical operators:  ||(or), &amp;&amp;(and), !(not)      ||(or)  → 여러 조건 중 하나라도 true이면 true  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → true인 조건을 만나면 이후의 조건은 더 이상 읽지 않음        &amp;&amp;(and)  → 여러 조건 중 하나라도 false이면 false  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → false인 조건을 만나면 이후의 조건은 더 이상 읽지 않음  → null check할 때 유용하게 쓰임  3. Equalityconst stringFive = '5';const numberFive = 5;// == loose equality, with type conversionconsole.log(stringFive == numberFive); // trueconsole.log(stringFive != numberFive); // false// === strick equality, no type conversionconsole.log(stringFive === numberFive); // falseconsole.log(stringFive !== numberFive); // true  Console  true  false  false  true// object equality by referenceconst minji1 = { myname: 'minji'};const minji2 = { myname: 'minji'};const minji3 = minji1;console.log(minji1 == minji2); // falseconsole.log(minji1 === minji2); // falseconsole.log(minji1 === minji3); // true  Console  false  false  true→ object에는 object를 가리키는 reference를 저장함// equalityconsole.log(0 == false); // trueconsole.log(0 === false); // falseconsole.log('' == false); // trueconsole.log('' === false); // falseconsole.log(null == undefined); // trueconsole.log(null === undefined); // false⇒ 0, null, undefined, NaN, ‘’ 은 false로 간주함⇒ 0은 boolean type이 아니라서 strict equality를 적용하게 되면 0은 false가 아님⇒ null은 undefined로 간주되지만, null과 undefined는 다른 type4. Ternary operator  삼항연산자  condition?value1:value2;  조건이 간단한 경우에만 씀  조건이 복잡해질 경우에는 if나 switch를 사용하는 것이 좋음Switch statement  if, else if를 반복하게 된다면 switch를 쓰는 것이 더 나음      enum-like value check시 사용      const browser = 'IE';  switch (browser) {      case 'IE':          console.log('go away!');          break;      case 'Chrome':      case 'Firefox':          console.log('love you!'); // 'Chrome'과 'Firefox'의 결과 값이 같으므로 한번에 적어줌!          break;      default:          console.log('same all!');          break;  }      ※ 같은 결과 값을 요구한다면, case를 이어서 적어주면 됨Loopsnested loopsfor (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        console.log(`i:${i}, j:${j}`);    }}⇒ O(n^2)이므로 CPU에 좋지 않으므로 피하는 것이 좋음!continue/break// Q1. iterate from 0 to 10 and print only even numbers (use continue)for (let i = 0; i &lt; 11; i++) {    if (i % 2 !== 0) {        continue;    }    console.log(`q1. ${i}`);}// Q2. iterate from 0 to 10 and print numbers until reaching 8 (use break)for (let i = 0; i &lt; 11; i++) {    if (i &gt; 8) {        break;    }    console.log(`q2. ${i}`);}※ label은 다른 방식으로 코드를 바꿔 사용이 가능해 현업에서는 쓰지 않으니 참고!&lt; 출처 &gt;  “자바스크립트 4. 코딩의 기본 operator, if, for loop 코드리뷰 팁 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 20:14, 게시자 “드림코딩 by 엘리,” 2020년 4월 15일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-operator"
    }
    , 
    
    "javascript-variable": {
        "title": "JavaScript(2) - strict mode, variable",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        1. Strict Mode  ES(ECMAScript) 5부터 추가됨  Valina JS 문서가 시작될 때, 'use strict'; 를 쓰면 strict mode로 시작  보다 상식적인 범위 내에서 코딩이 이루어 질 수 있도록 엄격한 잣대로 코드를 실행  JS engine이 보다 효율적으로 구동됨Strict mode - JavaScript | MDN2. Variable      Data types                  primitive, single item→ 더 이상 작게 쪼갤 수 없는 한 가지 아이템→ number, string, boolean, null, undefined, symbol→ 값(value) 자체가 메모리에 저장됨                    object, box container→ single item들을 묶어서 관리하는 것→ object를 가리키는 reference가 메모리에 저장됨                    function※ first-class function  → variable에 할당 가능  → 다른 함수의 parameter로 전달이 가능  → return 값으로 지정 가능                  Immutable/Mutable data types                  Immutable data types→ data 자체 변경 불가→ primitive types, frozen objects (i.e. object.freeze())                    Mutable data types→ data 변경 가능→ all objects by default are mutable in JS            let→ ES6에서 추가됨  → var는 이제 사용하지 말 것!  var hoisting변수의 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림→ var는 block scope가 적용되지 않음  → block 안에 있는 변수를 block 바깥에서도 부를 수 있는 상황이 발생함※참고:  Variable hoisting - JavaScript | MDN  {    age = 4;    var age;  }  console.log(age);  Console  4global variable vs. local variable  global variable → 함수의 바깥에 선언한 변수→ 문서 전체에서 사용 가능함  local variable → 함수의 안에 선언한 변수→ 함수 안에서만 사용 가능함 (block scope)※참고:  Variable scope - JavaScript | MDNnumber  JS에서는 숫자의 data type과 상관없이 number type으로 할당됨      const count = 17; // integer  const size = 17.1; // decimal number  console.log(`value: ${count}, type: ${typeof count}`);  console.log(`value: ${size}, type: ${typeof size}`);              Console      value: 17, type: number      value: 17.1, type: number        양수를 0으로 나누면 infinity음수를 0으로 나누면 negative infinity숫자가 아닌 것을 숫자로 나누면 NaN(not a number)string  글자는 수에 상관 없이 모두 string으로 할당됨  +기호를 사용해 다른 변수와 붙일 수 있음  const brendan = \"brendan\";  const greeting = \"hello \" + brendan;  console.log(`value: ${greeting}, type: ${typeof greeting}`);  Console  value: hello brendan, type: string      template literals (string literals)→ `(backtick)을 이용해 string과 ${variable} 을 써주면 결과 값이 붙여져 나옴→ ‘ ‘(quotes)와 +를 쓰는 것보다 편리함    const helloBob = `hi ${brendan}!`; // template literals (template string)console.log(`value: ${helloBob}, type: ${typeof helloBob}`);console.log(\"value: \" + helloBob + \", type: \" + typeof helloBob);              consol      value: hi brendan!, type: string      value: hi brendan!, type: string      boolean  false: 0, null, undefined, NaN, ‘ ‘      true: any other value    const canRead = true;const test = 3 &lt; 1; // falseconsole.log(`value: ${canRead}, type: ${typeof canRead}`);console.log(`value: ${test}, type: ${typeof test}`);        consol  value: true, type: boolean  value: false, type: booleannull / undefined  null로 할당하면 아무런 값도 없다는 것을 명시하는 것  undefined로 지정하거나 아무 것도 지정하지 않으면, 선언은 되었지만 값이 정해지지 않은 상황// nulllet nothing = null;console.log(`value: ${nothing}, type: ${typeof nothing}`);// undefinedlet x = undefined; // let x; 도 같은 뜻console.log(`value: ${x}, type: ${typeof x}`);  consol  value: null, type: object  value: undefined, type: undefinedsymbol// symbol, create unique identifiers for objectsconst symbol1 = Symbol(\"id\");const symbol2 = Symbol(\"id\");console.log(symbol1 === symbol2);const gSymbol1 = Symbol.for(\"id\");const gSymbol2 = Symbol.for(\"id\");console.log(gSymbol1 === gSymbol2); // true  consol  false  true※ .description을 이용해 string으로 변환한 뒤, 출력해야 함!console.log(`value: ${symbol1}, type: ${typeof symbol1}`); // error!console.log(`value: ${symbol1.description}, type: ${typeof symbol1}`);  console  Uncaught TypeError: Cannot convert a Symbol value to a string at ~  value: id, type: symbolobjectobject 문서 연결하기!3. Constantconst  가능하면 const로 선언하는 것이 좋음  block scope (like let)let은 mutable(변경 가능), const는 immutable(변경 불가) data type  reassignment(재할당)로 값이 바뀌거나, redeclare(재선언) 불가  장점          보안상 좋음      다양한 threads의 동시 접속으로 변수 값 변경이 일어나는 것을 방지      코드 변경시 실수를 줄여줌      4. Dynamic typing  JS = dynamically typed language→ run time 동안 할당된 값에 따라 data type 변화됨  C, JAVA = statically typed language→ 변수 선언시 data type 명시 필요    let text = \"hello\";console.log(text.charAt(0)); // hconsole.log(`value: ${text}, type: ${typeof text}`);text = 1;console.log(`value: ${text}, type: ${typeof text}`);text = \"7\" + 5;console.log(`value: ${text}, type: ${typeof text}`);text = \"8\" / \"2\";console.log(`value: ${text}, type: ${typeof text}`);console.log(text.charAt(0));              console      h      value: hello, type: string      value: 1, type: number      value: 75, type: string      value: 4, type: number      Uncaught TypeError: text.charAt is not a function at ~        → string과 숫자가 합쳐지면 string이 되고,숫자로 이루어진 string끼리의 연산이 이루어지면 number가 되는 오류 발생  (→ TS(typescript)가 나오게 되는 계기)    출처: “자바스크립트 3. 데이터타입, data types, let vs var, hoisting 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 27:58, 게시자 “드림코딩 by 엘리,” 2020년 4월 11일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-variable"
    }
    , 
    
    "javascript-asyncdefer": {
        "title": "JavaScript(1) - async vs. defer",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise    JavaScript(11) - Regular expressions    JavaScript(12) - Prototype과 Class 피하기    JavaScript(13) - localStorage        1. &lt;head&gt;tag내에서 &lt;script src=”main.js”&gt;&lt;/script&gt; 선언할 때  parsing HTML : HTML 문서를 한 줄 씩 읽어 내려가다가  &lt;script&gt; tag를 만나면 parsing을 멈추고, fetching js, executing js : js파일을 다운 받아서 실행함.  2번이 끝나면, 다시 parsing HTML을 이어서 마무리 함⇒ 단점: 사용자가 웹사이트를 보기까지 시간이 많이 걸림2. &lt;body&gt;tag 가장 아랫 부분에 &lt;script&gt;tag를 넣는 경우⇒ 장점: 사용자가 HTML 컨텐츠를 빠르게 볼 수 있음⇒ 단점: js의 영향력이 큰 페이지라면 사용자가 온전한 페이지를 접하기까지 오래 걸림3. &lt;head&gt;tag 내에 &lt;script async src=”main.js”&gt;를 선언하는 경우  HTML parsing을 하다가 async를 만나면 js문서의 다운로드를 병렬로 진행하다가  js의 다운로드가 끝나면, parsing을 멈추고 다운로드 된 js를 실행시킴  실행이 끝나면 나머지 HTML을 parsing함⇒ 장점: js의 다운로드 시간을 절약할 수 있음⇒ 단점: js가 적용되는 HTML문서의 parsing에 따른 시간 차이로 인해 오류가 생길 수 있으며, 여전히 온전한 페이지 로딩에 시간이 많이 걸림4. &lt;head&gt;tag내에 &lt;script defer src=”main.js”&gt;를 선언하는 경우★★★★★  HTML parsing 하다가 defer를 만나면 js문서의 다운로드를 병렬로 진행하다가  HTML parsing이 끝나면 사용자에게 페이지를 보여줌  다운로드 된 js를 실행시킴5. async vs. deferasync의 경우,여러 개의 js문서가 적용 순서와 상관없이 fetching이 완료된 순서로 실행이 됨→ 실행 순서가 중요하다면 오류가 생길 수 있음defer의 경우,parsing하는 동안 js가 모두 다운로드 되므로 순서대로 실행이 됨※ 그러므로, &lt;head&gt;tag 내에 &lt;script defer src=”main.js”&gt;&lt;/script&gt;로 선언하는 것이 가장 효율적이며, 안전함!&lt; 출처 &gt;  “자바스크립트 2. 콘솔에 출력, script async 와 defer의 차이점 및 앞으로 자바스크립트 공부 방향 | 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 17:43, 게시자 “드림코딩 by 엘리,” 2020년 4월 7일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-asyncDefer"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ohoraming.github.io/">백엔드 개발자의 노트</a> &copy; 2023</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a>
                </section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">백엔드 개발자의 노트</h1>
            <p class="subscribe-overlay-description">게시글 검색</p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm" />
    <input class="location" type="hidden" name="location" />
    <input class="referrer" type="hidden" name="referrer" />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"
            placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if (event.code == 'Enter') {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function () {
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });
        });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
        </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
    <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>

</html>