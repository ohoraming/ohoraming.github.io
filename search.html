<!DOCTYPE html>
<html>

<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- syntax.css 추가-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- 웹폰트(나눔 고딕) 추가 -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"> -->

    <!-- font awesome 추가 -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
        integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

    <style>
        .hljs {
            background: none;
        }

        /* web font 추가 */
        @font-face {
            font-family: 'MaruBuri-Regular';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-10-21@1.0/MaruBuri-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
    </style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="배움을 기록합니다" />
    <link rel="shortcut icon" href="https://ohoraming.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ohoraming.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="예비 개발자의 노트" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="배움을 기록합니다" />
    <meta property="og:url" content="https://ohoraming.github.io/search" />
    <meta property="og:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="배움을 기록합니다" />
    <meta name="twitter:url" content="https://ohoraming.github.io/" />
    <meta name="twitter:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="예비 개발자의 노트" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "예비 개발자의 노트",
        "logo": "https://ohoraming.github.io/"
    },
    "url": "https://ohoraming.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://ohoraming.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ohoraming.github.io/search"
    },
    "description": "배움을 기록합니다"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>

<body
    class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
        
        <a class="site-nav-logo" href="https://ohoraming.github.io/">예비 개발자의 노트</a>
        
        
        
        <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!-- About: blog에 대한 기본적인 소개-->
    <!-- C:\myblog\about\index.md에서 세부설정 -->
    <!-- href: C:\myblog\_data\authors\tags.yml에서 설정한 tag명 tag/다음에 넣음 -->
    <li class="nav-about" role="menuitem"><a href="/about/">Portfolio</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/java/">JAVA</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/javascript/">JavaScript</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/os/">OS</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/other/">Other</a></li>
    <li class="nav-archive" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-archive" role="menuitem"><a href="/author_archive.html">All Tags</a></li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
        <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>
    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "git-convention": {
        "title": "Git - Git Convention",
            "author": "ohoraming",
                "category": "",
                    "content": "여러 가지 포스팅    Git - Git Convention  https://codingsight.com/git-branching-naming-convention-best-practices/의 내용을 번역한 것입니다.Git Branching Naming Convention: Best PracticesGit branch는 Regular와 Temporary branch로 나눔Regular Git Branches  영구적인 repository에 씀  간단하고 쉬운 naming convention  dev(development)는 main 개발 branch임dev branch의 아이디어는 해당 branch에서만 변경를 일으키고, master branch의 직접적인 변경은 제한함dev branch의 변경은 review(검토)를 받고, 테스트 후 master branch와 merge됨  master는 Git repository의 기본 branch임항상 안정적이며, 어떠한 직접적인 check-in도 허용하지 않음code review이후에만 merge가 가능함팀 구성원 모두가 master를 안정적이며, 최신의 상태로 유지하는 것에 책임이 있음  QA 또는 test branch는 QA testing과 자동 testing을 위한 모든 코드를 포함하고 있음어떠한 변경이 production 환경으로 가기 전, 안정적인 codebase를 위해 반드시 QA testing을 거쳐야 함Temporary Git Branches  이름에서 알 수 있는 것처럼, 필요할 때마다 만들고 없앨 수 있음  Bug Fix, Hot Fix, Feature Branches, Experimental Branches, WIP branches 용도로 사용할 수 있음Git Branching Naming Convention수많은 naming convention이 존재함이 중 가장 좋은 일곱 개의 naming convention에 대해 알아보자1. Start branch name with a Group wordgroup word로 branch 이름을 시작하라.  최고의 방법 중 하나  group word는 자신의 작업 흐름과 일치하는 어느것이든 상관 없음e.g.)Bug - 곧 해결되어야하는 버그,WIP - 작업이 진행 중에 있으며, 조만간 끝나지 않을 것이라 예상되지 않을 때(WIP: work in process/progress)  branch 이름을 봤을 때, 해당 Git branch가 무엇에 대한 것이며, 어떤 목적을 가지고 있는지 알 수 있어야 함e.g.) bug-logo-alignment-issue: logo alignment issue를 고치는 중임wip-ioc-container-added: IoC container를 추가하는 작업을 진행 중임2. Use Unique ID in branch namesbranch이름에 고유한 ID를 사용하라.  branch 이름에 issue tracker ID를 사용할 수 있음  버그를 고칠 때, 선호하는 방법임e.g.)wip-8712-add-testing-module라는 이름은해당 branch가 testing module을 추가하는 업무에 적용되며,issue의 tracking Id는 8712이고,해당 업무가 진행 중에 있다는 것을 보여줌  branch 이름에 외부 tracking ID를 사용하는 것의 장점은 외부 시스템에서 진행 상황을 추적할 수 있다는 것임3. Use Hyphen or Slash as Separators구분자로 하이픈이나 슬래시를 사용하라.  많은 개발자들은 구분자로 슬래시와 하이픈을 사용함      어떤 것을 사용할 지는 자신 또는 자신의 팀의 선호에 달려있음    개인적으로, 하이픈은 이름을 읽기 편하게 만들어 주어서 branch 이름의 구분자로 적절하다고 생각함  슬래시, 하이픈, 언더스코어 모두 사용할 수 있음  중요한 것은 일관되어야 한다는 것임branch 이름에 구분자를 넣으면 두 가지 장점이 있음  가독성을 높일 수 있으며, 혼동을 줄여줄 수 있음  특히, 많은 branch를 다루고 있다면 관리하기 좋음구분자가 없는 featureupgradejqueryversionloginmodule보다는구분자가 있는 feature_upgrade_jquery_version_login_module이 읽기 쉬움4. Git Branch with Author Name작성자 이름을 포함하는 Git branch  많은 회사들은 &lt;author&gt;_&lt;branch-type&gt;_&lt;branch-name&gt; 형식에 따라 작성자의 이름이 branch이름에 있는 것을 선호함e.g.)  rajeev.bera_feature_new-experimental-changes  이 방법은 다른 개발자들의 작업과 추가적인 시스템의 진행 상황을 추적하기 좋음5. Avoid using numbers only숫자만 사용하는 것을 피하라.  몇몇 개발자들은 branch 이름에 issue Id만 기입하는데, 이는 일의 진행에 도움이 되지 않음  예를 들어, 9912라는 branch 이름은 무엇을 설명하는지 알 수가 없음  특히 이 방식은 다른 git branch와 merge하는 중에 혼란과 실수의 가능성만 증가시킴6. Avoid using all naming convention simultaneously모든 naming convention을 동시에 사용하는 것을 피하라.  모든 naming convention을 혼용해 사용하는 것은 좋은 방식이 아님      혼란만 가중시키고, 전반적인 처리 과정을 더 복잡하게 만듦    팀은 업무 중에 사용할 naming convention을 한번 정한 후, 팀원들이 받아들이도록 해야 함  일관성이 가장 중요함7. Avoid long descriptive names for long-lived branches오래가는 branch에 길게 설명하는 이름은 피하라.  branch 이름의 필수적인 특징은 정확해야 하며, 유용한 정보를 주어야 한다는 것임e.g.)wip_login_module_which_will_used_in_the_public_website,  wip_login_module_which_will_used_in_the_internal_website와 같은 branch 이름의 경우, 길고 상세함필수적이지 않음대신에,wip_feature_login_module과 같은 branch 이름은 짧지만 branch의 목적을 잘 설명함Conclusion  Git의 Branching 모델은 강력하지만, branch를 적절하고 효과적으로 다뤄야만 함  필수적인 요건 중 하나는 모든 팀원이 같은 convention을 따라야 하는 것임  pre-commit hook과 같은 Git hook을 사용하는 것도 쉬운 방법 중 하나임",
        "url": "/git-convention"
    }
    , 
    
    "os-contiguous-memory-allocation": {
        "title": "OS(11) - Contiguous Memory Allocation",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationContiguous Memory Allocation (연속 메모리 할당)  최초의 컴퓨터  → OS 없음  → 하나의 process만 main memory에서 돎  OS 등장  → OS와 하나의 process가 돎  → MS-DOS  Multi-programming 환경  → OS와 여러 개의 process가 돎  → booting 직후에는 OS와 big single hole(비어있는 하나의 큰 메모리)  → process 생성과 종료의 반복 후에는 OS와 scattered holes(흩어져있는 여러 메모리)  → memory가 흩어져 있으면 새 process 적재 불가      (hole을 모두 합하면 적재할 process 용량보다 커도 이어져있지 않으면 사용 불가)      (= 외부 단편화(external fragmentation))  연속 메모리 할당 방식          First-fit  → memory를 위(또는 아래)에서 순차적으로 훑어 처음으로 만난 적합한 공간에 할당      Best-fit  → 빈 hole 중에서 새 process 용량과 가장 크기가 비슷한 곳에 할당      Worst-fit  → 빈 hole 중에서 새 process 용량과 가장 크기가 크게 차이나는 곳에 할당      속도: first-fit이 가장 빠름  → 조건에 부합하는 첫 메모리 공간에 할당하기 때문      이용률: first-fit, best-fit 방식이 실행 못하는 process 수가 비교적 적음      first-fit이나 best-fit을 선택하더라도    여전히 external fragmentation 발생  → memory의 약 1/3은 사용 불가      compaction: 흩어져 있는 hole들을 한 곳으로 모으는 것  → 최적의 알고리즘의 부재, 고부담의 단점이 존재      Paging (페이징)  memory에 process가 연속 할당되어야 한다는 생각때문에 발생한 external fragmentation의 해결책  memory를 일정한 크기(= frame)로 자르고 process 역시 같은 일정한 크기(= page)로 자름  → size: frame = page  여러 개의 MMU가 relocation register값을 바꿔주면 각 page들이 hole의 frame에 각각 배치될 때, CPU는 process가 연속 할당되었다고 속음  이때의 MMU는 page table이라고 함Address Translation (주소 변환) ★★★★★  Logical address(논리 주소)와 Physical address(물리 주소)는 MMU를 기준으로 나뉨  Logical address  → CPU가 내는 주소, 2진수(binary)  → 전체 m비트, 하위 n비트(offset 또는 displacement(d)), 상위 m-n비트(page number(p))  Address translation: Logical address → Physical address  → page number: page table의 index 값  → frame number: 해당 page number의 내용  → displacement(변위): 변하지 않음  → page table의 entry 수 = 해당 process가 사용하는 page 수  예제 # 01          page size = 4byte      page table: 5 6 1 2      logical address = 13      pysical address = ?sol.)                  index number      page table                  0      5              1      6              2      1              3      2      page size (= frame size) = 4byte = 2^n = 2^2 → n = 2logical address: 13(10) = 1101(2)logical address = ‘page number(p)’ + ‘displacement(d)’logical address의 뒤에서부터 두 자리(=n)는 (d), 남은 앞의 두 자리는 (p)→ p: 11/01 :dpage number: 11(2) = 3(10)이며, page table 3번 index의 frame number는 2(10) = 10(2)pysical address = ‘frame number(f)’ + ‘displacement(d, ※불변)’이므로pysical address = 1001(2) = 9(10)  예제 # 02          page size = 1KB      page table: 1 2 5 4 8 3 0 6      logical address = 3000, pysical address = ?      pysical address = 0x1A53, logical address = ? sol.)                  index number      page table                  0      1              1      2              2      5              3      4              4      8              5      3              6      0              7      6      page size (= frame size) = 1KB = 2^n = 2^10 → n = 10logical address: 3000(10) = 1011 1011 1000(2)logical address = ‘page number(p)’ + ‘displacement(d)’logical address의 뒤에서부터 열 자리(=n)는 (d), 남은 앞의 두 자리는 (p) → p: 10/11 1011 1000 :dpage number: 10(2) = 2(10)이며, page table 2번 index의 frame number(f)는 5(10) = 101(2)pysical address = frame number(f):101(2) + displacement(d, ※불변): 11 1011 1000(2)이므로pysical address = 1 0111 1011 1000(2) = 6072(10)pysical address: 0x1A53 = 1 1010 0101 0011(2)n = 10, pysical address = ‘frame number(f)’ + ‘displacement(d, ※불변)’이므로→ f: 1 10/10 0101 0011 :dframe number: 110(2) = 6(10)이며, frame number 6의 index number는 7(10) = 111(2)logical address = page number(p):111(2) + displacement(d, ※불변):10 0101 0011(2)이므로logical address = 1 1110 0101 0011(2) = 0x1E53Internal Fragmentation(내부 단편화)  process size가 page size의 배수가 아니어서 마지막 page는 한 frame을 다 못 채우는 것e.g.) process: 15byte, page size: 4byte 일 때,|  4  |  4  |  4  |  3  |으로 마지막 frame의 남은 1byte는 못 쓰게 됨 → 낭비  내부 단편화는 비교적 미미한 낭비라 큰 문제는 아님  내부 단편화의 최대 크기 = page size - 1bytepage table 만들기  CPU register로 page table 만들기          CPU 안의 기억장치인 CPU register로 page table을 만들면, → 장점: 주소 변환 속도 빠름 → 단점: CPU는 memory가 아니라서 table entry 저장 용량이 작음        Memory로 page table 만들기          main memory 안에 넣는 방법으로, → 장점: table entry 수가 많아도 저장 용량에 문제 없음 → 단점: CPU가 낸 주소는 OS 안으로 가는데 그 주소를 한 번 읽어 frame number를 알아낸 뒤, 해당 frame number의 주소를 또 읽어야 해서 속도가 두 배로 느림        TLB(Translation Look-aside Buffer)로 page table 만들기          주소 변환을 목적으로 별도의 SRAM 칩으로 만듦      원리는 cash memory와 비슷      CPU보다는 느리지만 보다 많은 entry 저장 가능      CPU와 memory의 중간 성격      Effective Memory Access Time(유효 메모리 접근 시간)  → CPU가 주소를 내고, 메모리의 내용을 읽어오는데 걸리는 시간  → Tm: 메모리 내용을 읽는데 걸리는 시간  Tb: buffer를 읽는데 걸리는 시간  hit ratio(h): 주소에 해당하는 page table entry가 buffer에 존재할 확률  (buffer의 크기는 충분히 크지 않아서 entry 중 일부만 buffer에 있고 나머지는 memory에 존재)  (★ 중요 예제 ★)  Tm: 100ns, Tb: 20ns, hit ratio(h): 80% 일때, Teff=?  sol.) h(Tb+Tm) + (1-h)(Tb+Tm+Tm)  = (0.8*120ns) + (0.2)(220ns)  = 140ns  → Tm: 100ns인데 40%의 손실이 발생한 결과임  → 하지만, 실제 hit ratio는 95%이상이므로 손실은 아주 작음      ",
        "url": "/OS-contiguous-memory-allocation"
    }
    , 
    
    "python-django": {
        "title": "Python(1) - Django 설치",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    Python(1) - Django 설치1. Django 설치$ python -m pip install Django입력설치 끝나면, django-admin 명령을 쓸 수 있음→ $ django-admin 입력시 사용 가능한 서브 명령이 출력됨2. Project 시작2-1. project 생성$ django-admin startproject [project 이름]→ 현재 디렉터리에 project파일이 생성되고 그 안에 같은 이름의 project파일이 생김또는,$ django-admin startproject [project 이름] .→ 현재 디렉터리에 project파일이 생성됨2-2. project 파일 구성  myproject 폴더      myproject/      manage.py      myproject/          __init__.py          asgi.py          settings.py          urls.py          wsgi.py        urls.py파일  → 사용자가 접속하는 path에 따라 그 요청 처리를 지정(routing)  3. Django 실행3-1. manage.py를 이용$ python manage.py입력시 사용 가능한 서브 명령이 출력됨(※ 반드시 현재의 디렉터리가 project폴더인지 확인하기!)$ python manage.py runserver 입력→ 8000번 포트에서 서버가 성공적으로 열림(※ python 개발 서버는 기본적으로 8000번 포트에서 리스닝)3-2. 서버를 끄고 싶다면,ctrl + c 입력3-3. 포트 번호를 바꾸고 싶다면,$ python manage.py runserver [바꿀 포트 번호] 를 입력4. Application 설치4-1. django-admin startapp [app 이름]4-2. app 파일 구성  myapp 폴더      myapp/      migrations/          __init__.py      __init__.py      admin.py      apps.py      models.py      tests.py      views.py      5. Routing5-1. [project]/urls.py 설정→ 큰 틀의 라우팅은 [project]/urls.py 에서 지정  myproject/urls.py      from django.urls import include, path  urlpatterns = [      path('', include('myapp.urls'))  ]        → urlpatterns 정의(routing 관련 정보를 기록)  → path() 를 이용해 url을 넣어줌  path('접속 경로/', include('연결할 app.urls'))  → include(): import 필요  → user 접속시 myapp.urls 로 연결5-2. [app]/urls.py 생성 및 설정  myapp/urls.py      from django.urls import include, path  urlpatterns = [      path(''),      path('create/'),      path('read/1/')  ]        → user가 각 경로로 접속했을 때, views.py로 전달→ views.py: client로 정보를 전달할 함수 작성(index, create, read)    myapp/views.py      from django.http import HttpResponse  from django.shortcuts import render  # Create your views here.  def index(request):      return HttpResponse('Welcome!')  def create(request):      return HttpResponse('Create!')  def read(request):      return HttpResponse('Read!')      5-3. [app]/urls.py 수정→ 사용자가 기본 포트로 접속 시, myapp/views.py의 index 함수를 실행하도록 수정→ views.index import  myapp/urls.py      from django.urls import path  from myapp import views  urlpatterns = [      path('', views.index),      path('create/', view.create),      path('read/1/', view.read)  ]        cf.) path('read/1/', view.read) 에서 1이 바뀔 수 있는 숫자라면, &lt;&gt;를 이용해 작성          myapp/urls.py          path('read/&lt;id&gt;/', views.read)                → views.py의 read()가 해당 인자(id)를 받아서 처리            myapp/views.py          def read(request, id):      return HttpResponse('Read!'+id)                    &lt;routing 정리&gt;  user가 read/1 경로로 접속시  myproject/urls.py로 감     urlpatterns = [     path('', include('myapp.urls')) ]        myapp/urls.py로 위임     path('read/&lt;id&gt;/', views.read)        위 코드에 걸림    myapp/views.py로 위임     def read(request, id):     return HttpResponse('Read!'+id)        read() 함수실행  client에 반환 값 전송",
        "url": "/Python-django"
    }
    , 
    
    "os-main-memory-mgmt": {
        "title": "OS(10) - Main Memory Management",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation메모리 역사  Core memory  → 반지 모양의 철심에 자성 물질을 바른 뒤 전기 흘려 자기장이 발생해 순간적으로 자석이 되는 원리를 이용해 메모리를 만듦  진공관 메모리  → 1950s ~ 1960s, 손가락 3-4개 정도의 크기로 1bit 저장시 4-5개 필요  트랜지스터 메모리  → 1960s ~ 1970s, 반도체 칩 안의 소자로 손톱만한 크기  → 1bit 저장시 4-6개 필요  결국,  공간을 많이 차지해 큰 메모리를 저장하기가 힘듦  집적회로 메모리(현재)  → SRAM: 주로 캐시 메모리 만들 때 사용  → DRAM: 메인 메모리 만들 때 사용언제나 부족한 메모리      메모리 용량은 1970s(64KB)에서 현재(수GB)로 늘어났지만,프로그램의 크기도 증가해 메모리는 여전히 부족함→ 과거(1960s)의 메모리 관리가 여전히 중요한 이유        메모리의 효과적인 사용  → 메모리 낭비 없애기  → virtual memory(가상 메모리): 실제 물리적인 memory보다 크게 보이도록 하는 기술  프로그램을 메모리에 올리기      메모리 구조  → address: cpu가 읽고자하는 memory의 주소  → data: 해당 주소에 있는 내용을 cpu에 전송(양방향)    프로그램 개발          source file: high level language 또는 assembly language  → high level language로 코드 작성 → compiler가 compile하면 기계어로 번역됨 또는, → assembly language로 코드 작성 → assembler가 assemble하면 기계어로 번역됨      object file: compile 또는 assemble 결과 = 기계어 → 유용한 함수들을 모아놓은 library와 object file을 linker가 연결(link) = 실행 파일(exe file)      executable file: 실행 파일 → 하드 디스크에 들어감   → 프로그램을 실행하려면 loader가 main memory에 적재(load) → ‘code + data + stack’ 으로 구성 e.g.) ‘a와 b 중 더 큰 수를 구하라’에서 a, b는 data, 더 큰 수를 구하는 것은 code, 함수 호출시 돌아오는 주소 저장 또는 지역 변수를 저장하는 것은 stack        실행 파일을 메모리에 올릴 때,몇 번지의 메모리에 올릴지 → loader가 결정메인 메모리에 여러 process가 올라와 있다면 → 메모리 번지 변화 → MMU사용  MMU(Memory Management Unit)  → CPU와 memory 사이에 존재  → base, limit, relocation register 존재  → CPU에서 나온 address가 바로 memory로 가는 것을 방지(memory 보호)  → 실행 중인 process가 address를 침범하는지 수시로 감시  e.g.) main.exe가  0번지(→ logical address: CPU가 보내는 주소)에서 실행하도록 프로그래밍 되어있는데, 실행 가능한 메모리는 500번지(→ physical address: 실제 메인 메모리로 가는 주소)가 비어있다면,  OS가 MMU의 relocation register 값을 500으로 변경함  즉, CPU가 봤을 땐 0번지에서 실행, 실제로는 500번지에서 실행되도록 함  (→ address translation)메모리 낭비 방지1. Dynamic Loading(동적 적재)  현대 OS의 처리 방식  프로그램 실행에 반드시 필요한 routine/data만 메모리에 적재(load)  오류처리, 버퍼 용량, java의 class 등이 항상 다 사용되는 것 아님  ‘필요할 때’ 해당 부분을 메모리에 올림  과거에는 Static Loading(정적 적재)를 많이 했음2. Dynamic Linking(동적 연결)  여러 프로그램에 공통으로 사용되는 library를 메모리에 중복해 올리면 메모리 낭비 발생  과거의 Static linking(정적 연결)의 경우, compile후 실행 파일 만들기 전에 link가 일어나 memory 낭비가 있었음  Dynamic Linking(동적 연결)은 common library를 제외한 나머지 부분을 memory에 load 후, 실행할 때 lib를 load해 link  library routine 연결(link)을 실행(load)할 때로 미루는 방법임  → Linux: shared library 확장자 .so(shared object)파일  → Windows: Dyanamic Linking Library(DLL) 확장자 .dll파일3. Swapping  main memory에 적재되어 있지만, 현재는 사용하지 않고 있는 process image를 backing store로 몰아냄  backing store→ 하드 디스크의 일부분으로 실행파일이 저장되어있는 부분(→ file system)과는 다른 곳 → 대략 main memory 정도의 크기면 됨  swapping되어 backing store에 들어가면, 해당 main memory 공간은 비워지고 다른 process가 들어갈 수 있게 됨  backing store에서 main memory로 복귀시 이전과는 다른 자리에 들어가지만, relocation register를 사용하므로 적재 위치는 무관함",
        "url": "/OS-main-memory-mgmt"
    }
    , 
    
    "os-midterm": {
        "title": "OS(9) - Midterm",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation1.프로세스 P1, P2, P3 의 CPU burst time 은 각각 4, 2, 8 msec 이며,세 프로세스는 각각 다른 시간에 ready queue 에 도착했다.즉 P1 은 0 msec에, P2 는 1 msec에, P3 는 5 msec 에 각각 도착했다.CPU scheduling 에 대한 아래 물음에 답하라.(※ 각 경우마다 Gantt chart를 그리고 수식도 적어라.답은 계산하지 않아도 되지만, 반드시 단위는 기록해야 한다).→ 먼저, process별로 알아보기 쉽게 표를 작성            process      Arrival Time(msec)      Burst Time(msec)      Priority                  P1      0      4      3              P2      1      2      2              P3      5      8      1      (a) FCFS 스케쥴링을 사용하면 평균 대기시간(average waiting time)은 얼마인가?    → First Come First Served    → AWT = ( 0 + 3 + 1) / 3 = 4/3msec  P1P2P3 &nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14  (b) 선점형(preemptive) SJF 스케쥴링을 사용할 때 평균반환시간(average turnaround time)은 얼마인가?    → Shortest Job First    → P1의 burst time은 4로 P2보다 길지만 0msec에 P1만 도착해있으므로 P1부터 실행함    → 1msec에서 burst time이 짧은 것은 P2이므로 P2실행    → preemptive이므로 강제전환 가능    → ATT: 도착부터 서비스가 끝나서 나가기까지 걸리는 시간    → ATT = ( 6 + 2 + 9) / 3 = 17/3msec  P1P2P1P1P30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14   (c) Time quantum 이 무한대 (∞) 인 Round-Robin scheduling을 적용하면 평균반환시간은 얼마인가?    → Time quantum = ∞ 이므로 FCFS와 같은 scheduling 양상을 보임    → AWT = ( 4 + 5 + 9) / 3 = 18/3 = 6msec(d) 비선점형(nonpreemptive) 우선순위(priority) 스케쥴링을 사용하면 처리율(throughput)은 얼마인가? 단, 프로세스 P1, P2, P3 의 우선순위는 각각 3, 2, 1 이며, 숫자가 작을수록 우선순위가 높다.    → Priority scheduling이지만 non-preemptive이므로 강제전환 불가    → priority가 더 낮은 P1이 끝나야 P2실행 가능    → throughput: 단위 시간당 처리한 작업의 수    → throughput = 3/14 jobs/msec2.프로세스 P1, P2, P3 의 코드는 각각 다음과 같다. 세마포(semaphore)를 사용하여 아래 조건이 각각 만족되도록 프로세스의 코드를 수정하라. 세마포의 초기값도 나타내어야 한다. 세마포는 한 개 또는 여러 개를 사용할 수 있다.P1: S1P2: S2P3: S3(a) S1 이 끝나야 S2 나 S3 가 실행된다. S2, S3 의 순서는 상관없다.  sem.value = 0;  P1: S1; sem.release(); sem.release();  P2: sem.acquire(); S2;    P3: sem.acquire(); S3;(b) S1 과 S2 가 모두 끝나야만 S3 가 실행된다. S1, S2 의 순서는 상관없다.  semaphore 2개 쓰는 경우,  sem.value = 0;  sem2.value = 0;  P1: S1; sem.release();   P2: S2; sem2.release();    P3: sem.acquire(); sem2.acquire(); S3;  semaphore 1개 쓰는 경우,  sem.value = 0;  P1: S1; sem.release();   P2: S2; sem.release();    P3: sem.acquire(); sem.acquire(); S3;(c) S1, S2, S3 의 순서대로 실행된다. 즉 S1 → S2 → S3 의 순서를 따라야 한다.  sem.value = 0;  sem2.value = 0;  P1: S1; sem.release();  P2: sem.acquire(); S2; sem2.release();  P3: sem2.acquire(); S3;3.a) 프로세스 동기화(process synchronization)란 무엇을 의미하는가?    → 올바른 계산 결과가 나올 수 있도록 임계구역(Critical Section) 문제를 해결하는 것    → process의 실행 순서를 제어하는 것b) 세마포의 내부 구조를 그림으로 나타내고 간략히 설명하라.    → 어떤 process가 acquire()를 호출하면 value가 1감소하고 그 결괏값이 0보다 작으면 해당 process를 queue에 가둠    → 어떤 process가 release()를 호출하면 value가 1증가하고 그 결괏값이 0보다 작거나 같으면 queue에 갇혀있는 process를 깨움(= ready queue에 넣음)c) 어떤 세마포에 다섯 개의 프로세스가 블록(block)되어있다고 가정하자.이때 세마포 내부의 정수 값(value)은 얼마인가?    → 처음 sem.value = 0; 일때, 어떤 process가 acquire()를 호출하면 value = -1이 되고 block 됨. 이 원리로 5개의 process가 acquire()를 호출하면 value = -5가 되고 모두 block됨4.a) 시스템 콜(system call)과 소프트웨어 인터럽트(software interrupt)는 어떤 관련성이 있는가?    → 시스템 콜은 운영체제 서비스를 받기 위해 호출하며 s/w interrupt로 만듦b) 유닉스/리눅스 운영체제에서 fork() 시스템 콜은 어떤 용도로 사용되는가?    → 하나의 parent process에서 여러 개의 child process를 만드는 목적으로 사용함c) 자신이 알고 있는 유닉스/리눅스 시스템 콜의 종류를 세 가지 나열하고 간략히 설명하라.    → exit(): process 종료    → open(): file 열기    → close(): file 닫기    → read(): file 읽기    → write(): file 쓰기    → exec(): 생성된 process에 실행 파일을 복사해 넣음5.다음 용어의 의미를 간략히 설명하라.a) parent process          → process는 process에 의해 만들어지는데, 자신을 만든 process를 parent process라고 함b) command interpreter    → 사용자에게 명령을 받아 그 명령을 번역한 뒤 실행함. os에서는 shell이라고 함c) job scheduler    → job queue 안의 여러 process 중 어떤 것을 main memory로 올려보낼지 결정함.    long-term schedulerd) multi-level queue scheduling    → 여러 개의 queue가 존재. 각각의 queue에 절대적인 우선순위가 존재하거나 CPU time을 차등배분하여 독립된 scheduling 정책을 시행함6.생산자-소비자 문제는 mutex, empty, full 등 세 가지 세마포를 사용하여 해결할 수 있다. mutex 는 상호배타 목적, empty 와 full 은 각각 버퍼의 빈 공간 및 차있는 공간에 대한 접근목적으로 사용한다.a) 버퍼에서 데이터를 빼내어 소비하는 동작을 위 세마포를 포함한 코드로 작성하라.  full.acquire();mutex.acquire();bufcount–;mutex.release();empty.release();b) 생산자와 소비자는 프로세스, 각 세마포는 자원이라고 가정하자. 생산자는 버퍼에 대한 접근 허용을 기다리고 있고, 소비자는 버퍼에서 데이터를 빼내어 소비하는 상황을 나타내는 자원할당도(resource allocation graph)를 그려라. 단, 버퍼 크기는 10이고 그 중 8개가 차있다고 가정한다.    →7.a) 교착상태(deadlock)가 일어나기 위한 네 가지 필요조건 중 보유 및 대기(hold and wait) 란 무슨 의미인가?    → 한 가지 자원을 가지고 있으면서 또 다른 자원을 가지려고 대기하는 것b) 식사하는 철학자 문제(dining philosopher problem)에서 보유 및 대기 조건이 만족되지 않게 하려면 어떻게 해야 하는가?    → 1. 젓가락 두 개를 동시에 집도록 함    → 2. 한 젓가락을 집고, 다른 하나는 이미 사용 중이라면 가지고 있던 젓가락을 내려 놓음     (일부 자원만 이용가능하면 보유 자원을 모두 포기)cf.a) 교착상태(deadlock)가 일어나기 위한 네 가지 필요조건 중 환형대기(circular wait) 란 무슨 의미인가?    → 자원할당도 상에 원이 만들어짐b) 식사하는 철학자 문제(dining philosopher problem)에서 환형대기 조건이 만족되지 않게 하려면 어떻게 해야 하는가?    → 자원에 번호를 부여하고 오름(또는 내림) 차순으로 요청하기    → 짝수번 철학자는 왼쪽에서 오른쪽 순서로, 홀수번 철학자는 오른쪽에서 왼쪽 순서로 젓가락 들기8.아래 문제에서 변수 n, i, s 는 각 프로세스의 지역변수이며, value 는 모든 프로세스가 공통적으로 사용하는 전역변수이다. 프로세스 P1 과 P2 의 코드는 각각 다음과 같다.P1 while (true) {    value = value + n;    n++;    }P2 while (true) {    for (i = 0; i &lt; 100; i++)        s = s + i;        value = value - s;    }(a) 프로세스 동기화 문제에서 임계구역(critical section)이란 무엇을 의미하는가?→ 공통 변수(common variable)를 업데이트 하는 구간(b) 위 P2 프로세스의 코드 내용 중 임계구역에 해당되는 부분은 어디인가? 이유도 설명하라.→ value = value - s;→ 이유: 임계구역은 공통변수를 업데이트하는 구간임.value는 모든 프로세스가 공통 사용하는 공통변수(c) 세마포어(semaphore)를 사용하여 P1, P2  코드의 임계구역 문제를 해결하라. 세마포어의 초기 값도 나타내어라.sem.value = 1; // mutual exclusion용 semaphore  P1 while(true) {      sem.acquire();      value = value + n;  // Critical Section    sem.release();      n++;  }  P1 while(true) {      for(i = 0; i &lt; 100; i++)          s = s + i;          sem.acquire();          value = value - s;  // Critical Section        sem.release();  }(d) 프로세스 스케쥴링 방식과 관계없이 항상 P1 이 P2 보다 전역변수 value 값을 먼저 업데이트 하도록 세마포어를 사용하여 위 P1, P2 의 코드를 수정하여라. 세마포어의 초기 값도 나타내어라.sem.value = 1; // mutual exclusion용 semaphoresem2.value = 0; // ordering용 semaphoreP1 while(true) {    sem.acquire();     value = value + n; // Critical Section    sem.release();     sem2.release();    n++;}P1 while(true) {    for(i = 0; i &lt; 100; i++)        s = s + i;        sem.acquire();        sem2.acquire();        value = value - s; // Critical Section        sem.release();}9.프로세스(process)와 쓰레드(thread)의 유사점 및 차이점을 각각 설명하라.  process → 메모리 공간이 따로 존재  thread → 동일한 메모리 공간을 공유  유사점 → context switching이 일어남10.a) 프로세서(processor)의 이중모드(dual mode)란 무엇을 의미하는가?→ 한 컴퓨터를 여러 사람이 동시에 접속하거나, 한 사람이 여러 프로그램을 동시에 사용하는 환경에서 사용자 모드와 관리자 모드를 나누는 것. 관리자 모드에서만 특권명령과 하드웨어 접근이 가능함b) 이중모드를 사용한 입출력장치(i/o devices) 보호 방법에 대해 설명하여라.→ I/O 명령을 관리자(시스템)모드로 만들어 사용자 모드에서 I/O명령 사용시 SW interrupt가 발생해 해당 process를 종료함11.프로세스의 상태는 new, ready, running, waiting, terminated 등 다섯 종류로 나눌 수 있다.a) 프로세스 상태 변화를 보여주는 상태천이도(state transition diagram)를 그려라.→b) ready 와 waiting 상태는 어떻게 다른지 구분하여 설명하라.→ ready: CPU 서비스를 받기 위해 기다리는 것→ waiting: I/O 서비스를 받기 위해 기다리는 것",
        "url": "/OS-midterm"
    }
    , 
    
    "os-monitor": {
        "title": "OS(8) - Monitor",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationMonitor  semaphore 이후 process synchronization tool  semaphore(assembly 수준) 보다 고수준(high level language 수준) 개념  구조  → 공유자원(common variable) + 공유자원 접근함수  → 2개의 queues: 배타동기 + 조건동기  → 공유자원 접근함수에는 최대 1개의 thread만 진입(배타동기)       : mutual exclusion  → common variable에 접근한 method를 실행하고 있다면 다른 thread는 queue에 대기  → 진입 thread가 조건동기(wait())로 block되면 새 thread 진입가능      : conditional synchronization      : wait()을 부르면 실행중인 thread가 queue에 갇힘(= 새 thread 진입가능)  → 새 thread는 조건동기(notify())로 block된 thread를 깨울 수 있음  → 깨운 thread는 현재의 thread가 나가면 진입할 수 있음Java Monitor  Java의 모든 객체는 monitor가 될 수 있음  → 배타동기: synchronized 키워드 사용  → 조건동기: wait(), notify(), notifyAll() method사용일반적 사용(1): Mutual exclusion            synchronized {              Critical-Section              }      → synchronized 키워드만 사용하면 됨: 간단→ monitor는 초깃값 설정 없음→ semaphore는 semaphore import, 초깃값(= 1) 설정,    C.S. 앞뒤로 acquire(), release() 선언: 복잡일반적 사용(2): Ordering            p1      p2                     wait();              S1;      S2;              notify();             ",
        "url": "/OS-monitor"
    }
    , 
    
    "os-deadlock": {
        "title": "OS(7) - Deadlock",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationDeadlock  OS는 자원(Resources)을 Application에 잘 나누어주는 역할을 함  자원: CPU, memory, file, printer…  자원을 잘 못 나누어주면 deadlock에 빠지게 됨  Necessary Conditions For Deadlock   → 아래의 네 조건이 모두 만족되어야 deadlock 발생 가능성이 있음          Mutual exclution(상호배타)      Hold and wait(보유 및 점유)      No preemption(비선점)      Circular wait(환형대기)      Resources  동일 형식(type)의 자원이 여러 개 있을 수 있음 → instance  e.g.) 동일 CPU 2개, 동일 printer 3개 등  자원의 사용  [요청 → 사용 → 반납]  자원을 필요로하는 application이 OS에 해당 자원을 요청하면,  OS가 올바른 요청인지 확인 후 허용  application은 자원을 사용 후 OS에 반납  자원 할당도(Resource Allocation Graph)  → 자원은 사각형, 인스턴스는 사각형 안의 점, 프로세스는 원,  할당은 화살표로 표현  자원(R) → 프로세스(P): assign(할당)   프로세스(P) → 자원(R): request(요청)  자원 할당도 상에 원이 만들어지면 환형 대기 상태가 됨Deadlock 처리  Deadlock Prevention(교착상태 방지)  Deadlock Avoidance(교착상태 회피)  Deadlock Detection &amp; Recovery(교착상태 검출 및 복구)  Don’t Care(교착상태 무시)(1) 교착상태 방지  교착상태 필요조건 4가지 중 한 가지 이상 불만족  Mutual exclution(상호배타) 깨려면,  → 자원을 공유  → CPU의 경우 시간을 두고 switching은 가능하지만 동시에 사용 불가  → 원천적으로 불가한 조건  Hold and wait(보유 및 점유) 깨려면,  → 일부의 자원만 가지고 있을 경우, 다른 자원을 기다려야한다면 보유한 자원을 모두 포기  → 단점: 자원 활용율 저하, starvation(process가 진행을 못 함)  No preemption(비선점) 깨려면,  → 자원을 강제로 빼앗음  → CPU는 context switching해서 사용이 가능하나, printer는 불가능함  → 원천적으로 불가한 조건  Circular wait(환형대기) 깨려면,  → e.g.) 자원에 번호를 부여해 순서대로 자원을 요청  → 단점: 자원 활용율 저하(2) 교착상태 회피  deadlock을 자원 요청에 대한 잘못된 승인으로 해석  대출 전문 은행(Banker’s Algorithm)의 파산과 같다고 생각해 더이상 거래가 불가능한 상태로 인식  OS는 자원을 할당할 때 불안전한 할당(Unsafe allocation)이 되지 않도록 해야 함(3) 교착상태 검출 및 복구  hold and wait 되더라도 말리지 않고 원하는 대로 자원을 나눠주다보면 deadlock 발생할 수 있음  deadlock 발생을 허용하며 주기적으로 검사함  검사(detection)시 overhead 발생  → CPU 계산, memory  → 너무 자주하면 deadlock 발견은 빠르지만 overhead 발생 가능성 증가  복구(recovery)  → process 일부 강제 종료  → 자원 선점해 일부 process에 할당  → deadlock 발생 전으로 되돌리려면 주기적으로 현상태를 기억해야 하기에 memory필요(4) 교착상태 무시  deadlock은 실제로 잘 일어나지 않음  4개의 필요조건을 모두 만족하더라도 반드시 일어나는 것 아님  개인 PC의 경우 deadlock발생시 재부팅하면 해결됨  그래서 다른 방법을 시도하는 것 보다는 재부팅이 효율적일 수 있음",
        "url": "/OS-deadlock"
    }
    , 
    
    "os-classical-sync-problems": {
        "title": "OS(6) - Classical Synchronization Problems",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationProducer-Consumer Problem  producer(생산자)가 data를 생산하면 consumer(소비자)가 소비  e.g.) compiler(= producer)와 assembler(= consumer)의 경우,  compiler가 high level language를 low level language(assembly어)로 번역하면,  assembler가 번역된 assembly어를 기계어로 번역  e.g.) 파일 서버(= producer)와 클라이언트(= consumer)의 경우,  web browser가 요청을 보내면, server가 file안의 data를 처리해 응답하고, web brower가 web page형태로 보여줌  Bounded Buffer(유한 버퍼)  → 생산한 데이터는 버퍼에 우선 저장함  → buffer의 사이즈는 유한함  → producer는 buffer가 가득 차면 더이상 데이터를 넣을 수 없으며,  → consumer는 buffer가 비면 더이상 데이터를 뺄 수 없음  같은 수의 생산(insert)과 소비(remove)가 이루어졌다면, 결괏값은 0이 나와야 함  common variable인 count와 buf[]를 업데이트하는 C.S.(critical-section)에 동시 진입이 이루어져 최종 결괏값으로 0이 나오지 않음  solution  → mutual exclusion  → semaphore를 이용해 동시접근 방지  → number of permit = 1  Busy-wait  → producer: buffer가 가득차면 기다려야하며,  → consumer: buffer가 비면 기다려야 함  → OS의 ‘효율성 증가’의 목적에 위배됨  → semaphore를 사용해 busy-wait회피  → 무한 loop(while문)를 돌며 기다리지않고 semaphore에 가둠  → CPU 서비스를 받지 않고 block됨  → 빈공간이 생기면 producer를 깨우고, 데이터가 들어오면 consumer를 깨움Readers-Writers Problem  Reader: C.S.을 편집하지 않고 읽기만 함  Writer: C.S.를 읽고 편집함  Reader에 mutual exclusion을 적용하면 비효율적임  Reader가 들어왔는데 다른 Writer가 들어오려하면 block  Writer가 들어와 있으면 Reader는 block  Reader가 들어와 있는데 다른 Reader가 들어온다면 허용(효율성 제고)Dining Philosopher Problem  5명의 철학자와 5개의 젓가락이 서로 엇갈려 한 테이블에 존재  ‘생각 → 식사’의 반복  왼쪽 젓가락을 든 뒤, 오른쪽 젓가락을 듬  number of permit = 1 : 두 철학자 중 한 명만 젓가락 드는 것이 허용됨  결과: starvation: 모든 철학자들이 굶어 죽는 상황 발생  모두가 동시에 젓가락을 드는 상황이 있으면 deadlock에 빠짐",
        "url": "/OS-classical-sync-problems"
    }
    , 
    
    "os-thread": {
        "title": "OS(5) - Thread",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationThread  하나의 프로그램은 하나의 흐름/맥이 있음(single thread)  여러 흐름/맥이 있다면(multi threads)Multithreads  한 프로그램에 둘 이상의 흐름/맥이 있는 경우  짧은 시간 간격으로 흐름이 switching됨  → 여러 흐름/맥이 동시에 실행되는 것 같음(concurrent)  cf.) simultaneous - 실제로 동시에 여러 thread가 실행됨(불가능)Thread vs. Process  하나의 process에는 하나 이상의 thread가 존재(multi-thread program)  하나의 program은 code, data, stack으로 구성됨  thread는 process의 메모리 공간(code, data) 및 자원(file, I/O)을 공유  개별적인 program counter(PC), stack pointer(SP), registers, stack은 비공유  thread가 switching 될 때마다 PC, SP, registers값 모두 변화되므로 공유하지 않음  함수 호출시, stack에 return address, parameter 등을 저장함  현대의 context switching 단위는 process가 아닌 thread!java.lang.Thread  JAVA의 thread는 java.lang package 안에 있음  Thread.run() : thread가 시작되면 run() 메서드가 실행됨  run() 메서드를 override          class MyThread extends Thread {          public void run() {              // code          }      }      Process Synchronization(프로세스 동기화)  엄밀히 말하면 현대 OS는 context switching의 단위가 thread이므로 ‘thread synchronization’이 맞음  일반적으로, main memory에 올라간 process간에는 어떤 식으로든 영향을 주고 받음(cooperating process)  하나의 데이터베이스와 같은 공통된 자원(common resources)에 서로 접근하려 하기때문에 영향을 주고 받게 됨Bank Account Problem  parent는 deposit(입금), child는 withdraw(출금)을 진행  common variable인 balance(잔액)에 대해 동시 update가 발생함  코드를 읽어가다가 context switching이 일어날 경우, balance에 오류가 생김  high level language는 기계어(assembly어)로 변환되는 과정을 거침  한 줄의 코드가 여러 줄의 기계어로 번역될 때 context switching 일어나면 잘못된 결과가 발생  common variable update 진행 중에는 context switching 일어나면 안 됨  → common variable에 대해 한번에 하나의 thread만 update  → Critical-Section Problem (임계 구역 문제)Critical-Section Problem  Critical-Section (C.S.)  → multiple thread로 구성된 system  → common variable changing이 일어날 수 있는 구간  해결  → Mutual exclusion (상호 배타): 하나의 thread만 진입  → Progress (진행): 유한 시간 내에 C.S.에 누가 먼저 진입할 지 결정  → Bounded waiting (유한 대기): 유한 시간 내에 C.S.에 진입할 기회가 생김Synchronization Tools  Semaphores (세마포): 가장 전통적인 동기화 도구  Monitor (모니터): java에서 사용Semaphore  네덜란드의 Edsger Kijkstra가 제안  정수형 변수와 두 개의 동작(P, V)으로 구성  네덜란드어(Proberen, Verhogen)를 영어로 변환  P: acquire()  V: release()    class Semaphore {  int value;  Semaphore(int value) {      // code  }  void acquire() {      value--;      if (value &lt; 0) {          add this process/thread to list;          block;      }  }  void release() {      value++;      if (value &lt;= 0) {          remove a process P from list;          wakeup P;      }  }}        정수형 변수: number of permits  acquire()  → 정수값이 1감소  → 감소된 정수값이 0보다 작으면 호출한 process/thread를 queue안에 넣음      (block상태(= ready queue에 못 감))  → interrupted exception발생(try~catch)  release()  → 정수값이 1증가  → 증가된 정수값이 0보다 작거나 같으면(= queue에 block된 thread 존재) 호출한 process/thread를 queue에서 꺼냄(wake up)일반적 사용(1): Mutual exclusion      number of permits = 1  → C.S.에 하나의 process/thread만 들임                            acquire();                          Critical-Section                          release();                    일반적 사용(2): Ordering      number of permits = 1                            p1          p2                                     acquire();                          S1;          S2;                          release();                               ",
        "url": "/OS-thread"
    }
    , 
    
    "os-cpu-scheduling": {
        "title": "OS(4) - CPU Scheduling",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationCPU Scheduling  Preemptive(선점)  → CPU가 어떤 프로세스를 실행 중에 강제로 쫓아내고 다른 프로세스를 실행시킬 수 있는 scheduling 방식  Non-preemptive(비선점)  → CPU가 어떤 프로세스를 실행 중이라면 해당 프로세스가 I/O를 만나거나 종료되지 않은 상황에서는 절대 scheduling이 일어나지 않는 방식  CPU Utilization(CPU 이용률)  → CPU가 얼마나 열심히 일하고 있는가(%)  Throughput(처리율)  → 시간당 몇 개의 작업을 처리하는가(jobs/sec)  Turnaround time(반환시간)  → 어떤 작업이 ready queue에 들어가서 작업을 끝내고 나오는 시간(sec)  Waiting time(대기시간)  → ready queue에서 기다린 시간(sec)  Response time(응답시간)  → interactive system(대화형 시스템)에서 중요  → 첫 응답이 나오는 데까지 걸리는 시간CPU Scheduling Algorithms1. First-Come, First-Served(FCFS)  먼저 들어오면, 먼저 서비스 함  간단하며, 공평하지만 반드시 좋은 성능을 보장하지는 않음  Average Waiting Time(AWT): ready queue에서 기다리는 시간  단점: Convoy Effect(호위 효과)  → burst time이 긴 프로세스가 앞에 있으면 나머지 프로세스는 뒤에서 오래 기다리게 되는데 그 모양새를 왕을 호위하는 사람에 비유  Non-preeptive scheduling방식2. Shortest-Job-First(SJF)  실행 시간이 짧은 것을 먼저 서비스 함  대기 시간을 줄이는 최적의 방법  단점: 비현실적임(실제 CPU 사용 시간은 실행을 해보기 전에는 알 수 없음)      예측이 필수(과거를 기억하고 있어야 함)      → overhead 발생, 시간이 많이 걸림      → 현실적인 적용이 어려움  선점(preemptive)/비선점(non-preemptive) 두 가지 방식 가능  선점 방식의 경우 최소 잔여 시간 우선3. Priority Scheduling  우선 순위가 높은 것을 먼저 서비스 함  우선 순위 설정          integer number      내부적: 실행 시간 짧은, 메모리 작게 차지하는, I/O가 긴(=CPU가 짧은) 등      외부적: 비용을 많이 지불한 쪽, 정치적인 요소 등        선점 또는 비선점  문제점: starvation 돌입 가능 - 우선 순위에서 밀리면 아무리 기다려도 서비스를 받지 못 함  해결: aging - ready queue에서 오래 기다릴 수록 priority를 조금씩 상승시킴4. Round-Robin(RR)  time-sharing system에서 많이 사용  time quantum(시간 양자) = time slice = Δ  → 10 ~ 100msec: 1초당 10 ~ 100 번의 switching 발생  time quantum에 따라 성능이 달라짐  Δ → ∞ : FCFS  Δ → 0 : switching이 빈번해 여러 프로세스가 동시에 서비스 되는 것 같은 느낌을 줌Multilevel Queue Scheduling  process별로 queue를 달리해 서비스 함  여러 single ready queue의 묶음  queue마다 우선 순위는 다름  CPU time을 각 queue에 차등 배분함  queue별로 다른 scheduling 정책을 실행함Multilevel Feedback Queue Scheduling  여러 개의 queue  → multilevel queue scheduling과의 공통점  모든 process는 하나의 입구로 진입  너무 많은 CPU time 소비 시, 기아 상태가 우려될 시 다른 queue로 이동Process Creation  프로세스는 프로세스에 의해 만들어짐  → parent/child/sibling process, process tree  Process Identifier(PID)  → 사람의 주민등록번호와 같은 것  cf.) Parent Process Identifier(PPID)  system call          fork(): parent process 복사      exec(): 실행파일을 메모리로 가져오기      Process Termination  system call          exit(): 해당 프로세스의 자원 OS에 반환      ",
        "url": "/OS-cpu-scheduling"
    }
    , 
    
    "os-process-mgmt": {
        "title": "OS(3) - Process Management",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationProcess  실행 중인 프로그램  메인 메모리에 프로그램이 올라오면, text(code) + data + stack도 메인메모리에 생성됨  program vs. process  → 아무 일도 못하는 program, 살아 움직이는 process  상태: new, ready, running, waiting, terminated(출처: https://www.javatpoint.com/os-process-states)PCB(Process Control Block)  = Task Control Block(TCB)  C언어 구조체  OS의 process management 안에 존재  프로세스에 대한 모든 정보가 들어있음  process state(running, ready, waiting, …), program counter(PC, 몇 번째로 실행할지), MMU info(base, limit), CPU time(독점 방지용 시간 기록), process id(고유 번호), …  하나의 프로세스에 대해 하나의 PCB가 할당됨  CPU가 프로그램을 실행하다 I/O를 만나거나 time expired가 되어 다른 프로세스로 갈 때 이전까지 실행했던 정보들을 가지고 있어야 CPU 서비스를 다시 받을 때 이전 상태부터 이어서 받을 수 있음Queues  OS의 process management 안에 존재  각 queue마다 PCB들이 기다리고 있음  Job Queue          굉장히 더디며, 드물게 일어남      프로세스가 완전히 끝나 메모리가 비워져야 이 scheduling이 일어남        Ready Queue          아주 짧은 시간에 빈번하게 발생      프로세스 간의 이동이므로 switching이 빠름        Device Queue          특정 장치(I/O)를 사용하기 위해 대기      Multiprogramming  메인 메모리에 올려진 process의 수  I/O 관련 작업인지 CPU 사용 관련 계싼 작업인지 구분  midium-term scheduler  (※ Job scheduling: long term scheduler, CPU scheduling: short term scheduler)  context switching  → process간 전환  → dispatcher: scheculer가 선택한 process를 실행하도록 여러 값을 바꿔줌  → 자주 일어나면 overhead가 발생하므로 low level 언어로 코드를 구성해야 함",
        "url": "/OS-process-mgmt"
    }
    , 
    
    "os-interrupt-based-system": {
        "title": "OS(2) - Interrupt-Based System",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory AllocationInterruptinterrupt: v. 방해하다, 중단시키다→ 어떤 일을 하고 있는데 가로채서 다른 일을 함  현대 운영체제는 interrupt 기반 시스템          booting 완료 후, OS는 메모리에 상주함(resident)      마우스를 움직이면 전기신호(=interrupt)가 발생해 CPU의 interrupt선으로 감 &lt;HW interrupt&gt;      CPU는 하던 일을 중지하고 OS안의 마우스 Interrupt Service Routine(ISR)(코드)으로 점프      특정 icon을 더블클릭하면 interrupt가 걸리고, 더블클릭의 routine(코드)을 실행 &lt;SW interrupt&gt;      하드 디스크 속 특정 프로그램을 메인 메모리에 올림      바탕화면이 바뀌며 특정 프로그램의 화면이 나옴      IRS 종료후 다시 user program 또는 원래의 대기상태로 복귀      interrupt 기반 OS      OS는 여러 가지 code들의 모임  → 평소에는 작동하지 않고 interrupt에 의해 작동함        평소 OS는 대기상태          HW/SW/Internal(내부) interrupt에 의해 운영체제 코드(ISR)을 실행      Internal interrupt  e.g.) divide by zero:   결괏값이 무한대가 되어 컴퓨터에 저장 공간이 없음  → CPU가 내부적인 interrupt로 인식      이중 모드(Dual Mode)  사용 환경          한 컴퓨터(= 서버 컴퓨터)를 여러 사람이 동시에 사용하는 환경      또는 한 사람이 여러 프로그램을 동시에 사용하는 환경 (e.g.) pc, 스마트폰)      또는 한 사람이 특권 명령을 입력하는 경우        사용자 모드(User mode) vs. 관리자 모드(Supervisor mode)          CPU 동작 모드를 두 가지로 진행      OS 서비스가 실행될 때, HW/SW interrupt 발생할 때 관리자 모드 실행      사용자 프로그램이 실행될 때, OS 서비스가 끝나면 다시 사용자 모드 실행      사용자 모드에서는 CPU 중지 명령어(STOP, HALT, RESET 등)와 같은 치명적인 명령어를 사용하지 못하도록 함      관리자(supervisor) 모드 = 시스템(system) 모드 = 모니터(monitor)(감시자) 모드 = 특권(priviliged) 모드      레지스터에 mode를 나타내는 flag가 존재함                  register: 비트들의 모임          flags(carry, negative, zero, overflow)에 monitor 비트를 추가해 0과 1로 이중모드를 구현                      특권 명령(Privileged instruction)          특권 모드에서만 내릴 수 있는 명령어      STOP/HALT/RESET(CPU 중지 명령어), SET_TIMER(일반 유저가 시간을 바꾸면 안 됨), SET_HW(HW의 값을 바꿈)…            일반 User program은 하드 디스크에 접근이 불가함  즉, 서버 컴퓨터에 접속해 타인의 파일을 열람할 수 없다는 뜻(보안 문제)  그래서 OS에 SW interrupt를 걸어 ISR을 실행해 필요한 작업을 하게 함    일반적인 프로그램의 실행          power on      booting: 하드 디스크의 프로그램이 메인 메모리에 적재                  monitor 비트 = 1 : system mode라는 뜻          OS는 system mode에서 동작함          일반 user는 못 내리는 명령 수행 가능                    user mode &gt; (키보드, 마우스) HW interrupt &gt; system mode(ISR) &gt; user mode &gt; (모니터, 디스크, 프린터) &gt; system mode &gt; user mode                  만약, user mode에서 CPU에 STOP 명령을 내리면, CPU는 internal interrupt가 발생했다고 여겨 OS의 ISR로 점프해 해당 명령을 내린 프로그램을 강제 종료시켜 메모리에서 내림  → protection과 연관됨                    하드웨어 보호  입출력장치 보호 → 사용자가 input/output device에 바로 접근하는 것 불가, 반드시 OS를 거쳐야함  메모리 보호 → 자신에게 주어진 메모리 영역을 넘어서는 것을 막음  CPU 보호 → 한 컴퓨터를 여러 명이 쓴다면, CPU 역시 침범 대상이 될 수 있음(1) 입출력장치 보호  서로 다른 사용자들 간의 입출력 정보가 끼어들어 혼선이 생기는 것을 막기 위함  입출력 명령(IN OUT)을 특권 명령으로 지정함  SW interrupt(명령어: INT) &gt; OS에 요청(system mode로 전환) &gt; 입출력 실행 &gt; 다시 user mode로 복귀  이때, 올바른 요청인지 ISR의 초반에 확인하며, 그렇지 않다면 OS가 거부함  user mode에서 사용자가 직접 입출력 명령을 내린다면 ISR로 점프해 해당 프로그램을 종료시킴(privileged instruction violation, 특권 명령 침범)(2) 메모리 보호  다른 사용자의 메모리 혹은 OS영역의 메모리에 접근하는 것을 막기 위함  MMU(Memory Management Unit)를 두어 다른 메모리 영역 침범을 감시함  일종의 문지기로 base registar와 limit register 사이의 값만 통과시킴  Address bus에 base/limit register를 설정해두고 그 범위를 넘어서면 interrupt를 발생시킴  메모리에 잘못된 접근이 일어나면 ISR이 동작해 해당 프로그램을 강제 종료시킴(segment violation, 영역 침범)(3) CPU 보호  한 사용자의 CPU 시간 독점이 다른 사용자의 프로그램 실행을 방해하는 것을 막기 위함  TIMER를 두어 일정 시간 경과시 timer interrupt 발생  timer가 cpu에 주기적으로 interrupt를 걸어줌  interrupt가 발생 &gt; ISR로 jump &gt; ISR의 코드에 한 프로그램이 CPU시간을 독점하는지 감시하는 부분이 존재 &gt; 다른 프로그램으로 강제 전환OS 서비스  프로세스 관리 ★★          process: 메모리에서 실행 중인 program  (vs. program: 하드 디스크에 존재)      process의 생성, 소멸, 활동 일시 정지, 활동 재개, 통신, 동기화, 교착상태 처리 등        주기억장치 관리 ★          process에 메모리 공간 할당, process 종료시 메모리 회수, 가상 메모리        파일 관리          파일의 생성과 삭제, directory(folder))의 생성과 삭제, file 기본 동작, 백업        보조기억장치 관리          하드 디스크, 스마트 폰의 플래시 메모리 등      빈 공간 관리, 저장공간 할당, 디스크 스케줄링        입출력장치 관리          장치 드라이브, 입출력 장치의 성능 향상…      시스템 콜  OS 서비스를 받기 위한 호출(요청)  주요 시스템 콜          Process: end(종료), abort(강제 종료), load(하드 디스크의 프로그램을 메인 메로리로 가져오는 것), execute(실행), create(process 생성), terminate(종료(=end)), get/set attributes(속성)      Memory: allocate(새 객체 생성시 메모리가 필요해 OS에 요청), free(메모리를 다 쓰고 나서 돌려줌)      File: create(생성), delete(삭제)      ",
        "url": "/OS-interrupt-based-system"
    }
    , 
    
    "os-intro": {
        "title": "OS(1) - Introduction",
            "author": "ohoraming",
                "category": "",
                    "content": "OS 관련 포스팅    OS(1) - Introduction    OS(2) - Interrupt-Based System    OS(3) - Process Management    OS(4) - CPU Scheduling    OS(5) - Thread    OS(6) - Classical Synchronization Problems    OS(7) - Deadlock    OS(8) - Monitor    OS(9) - Midterm    OS(10) - Main Memory Management    OS(11) - Contiguous Memory Allocation운영체제(Operating System, OS)의 목적  컴퓨터 하드웨어를 잘 관리하여          HW: processor, memory, disk, keyboard, mouse, monitor…      OS가 메모리에 올라오면 User가 컴퓨터를 제어할 수 있게 됨        성능을 높이고          같은 HW라도 OS가 좋으면 성능이 향상됨        사용자에게 편의성을 제공          컴퓨터를 몇 번만 사용해보면 누구나 쉽게 사용할 수 있음      과거, 1940s-1950s에는 전문가(oprator)들만 컴퓨터를 사용할 수 있었음      부팅(Booting)boot: n. 목이 긴 신발, 부츠booting: 부츠를 끌어당겨 신는 것처럼 OS를 메인 메모리로 끌어당김  전원을 켜면  ROM의 code를 읽어와 실행          ROM: Read Only Memory      RAM: main memory의 대부분을 차지(수GB(10^9))        POST(Power-On Self-Test) 실행          전원을 켰을 때, 컴퓨터의 환경 설정이 제대로 되었는지 확인        Boot loader실행          load: v.적재하다      하드 디스크 안의 OS를 메인 메모리로 가져옴        OS가 메인 메모리(RAM)에 올라오면, 명령을 받아들일 준비를 마침          Windows의 경우 바탕화면이 뜨고, Linux의 경우 prompt 창이 뜸      OS = kernel + shell  Kernel          핵심      HW를 둘러싸며 이를 제어, 관리함      실제로 관리하는 프로그램        Shell          OS의 껍질 부분      명령어 해석기(command interpreter)      사용자로부터 명령을 받아 변역 후 해당 명령을 실행함      명령: 아이콘 더블 클릭(Windows), 텍스트 입력(Linux $ls(현 directory file 보여줌), $who(사용자 확인), $ds(디스크 용량 확인) 등)      OS의 위치  Application(App) ⊃ OS  ⊃ HW   정부(government)에 비유할 수 있음  주어진 자원을 할당(resource allocator)하고 관리함(resource manager)  OS가 직접 일을 하지 않고, 각 부서에 맞는 업무를 할당함  프로세스 관리와 메인 메모리 관리가 가장 중요한 업무역사  컴퓨터의 역사          1940s, OS가 없었음      programmer가 종이에 연필로 program을 작성해 전산실에 전달      전달받은대로 구멍(천공)을 뚫은 카드와 compiler 프로그램 카드를 카드 리더기에 올림      프로그램과 compiler가 메모리에 적재되고 기계어가 도출됨      처리기(processor)가 기계어를 실행하면      line printer가 망치로 두드려 결과를 인쇄        Batch processing system(일괄처리)          resident monitor: 최초의 OS      사람(operator)이 직접 compiler, linker, loading을 했음      이 일련의 과정을 메모리에 프로그램으로 넣어(=상주시켜) 자동으로 실행시킴        Multiprogramming system(다중 프로그래밍)          컴퓨터는 비싼 자원      CPU에 비해 i/o의 처리 속도는 느리며, i/o 처리 시간 동안 CPU는 idle상태(가동되지 않는)가 됨      i/o 처리시 다음 user의 연산을 처리      하나의 CPU를 여러 user(program)가 사용해 이용률을 증가시킴      user program의 효율적인 배치를 고민해야 함        Time-sharing system(시공유 시스템)          아주 짧은 시간(1/100초~1/1000초)동안 각 user의 작업을 나눠서 처리함      혼자서 CPU를 쓰는 느낌을 줄 수 있음      OS 기술 천이  컴퓨터 규모별 분류                  Supercomputer &gt; Mainframe &gt; Mini &gt; Micro  Supercomputer: 최강의 컴퓨터. 메모리 용량이 크고, CPU가 빠르며, 보조 기억장치가 뛰어남  Mainframe: 수백 대의 단말기를 연결한 형태  Mini: 수십 대의 단말기를 연결한 형태                    Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embeded  Handheld: 노트북, 태블릿, 스마트 폰  Embeded: 차나 가전에 내장된 형태              고성능 컴퓨터의 기능이 Handheld, Embeded까지 적용됨고등 운영체제(※대학원 과정)  다중 프로세서 시스템  분산 시스템  실시간 시스템",
        "url": "/OS-intro"
    }
    , 
    
    "javascript-promise": {
        "title": "JavaScript(10) - promise",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promisepromise  비동기(asynchronous)를 callback fn 대신 간편하게 처리하도록 도와주는 내장 object  정해진 장시간의 기능을 수행 후          정상적으로 기능이 수행이 되었다면, 성공 메시지와 처리된 결괏값을 전달해줌      만약 기능 수행 중 예상치 못한 문제가 발생하였다면, 에러를 전달해줌      포인트      State [상태] 이해 프로세스가 heavy한 명령을 수행하고 있는지, 기능 수행 완료 후 성공했는지, 실패했는지        Producer vs. Consumer Producer: 우리가 원하는 데이터를 제공하는 사람 Consumer: 제공된 데이터를 쓰는/필요로 하는 사람  State [promise의 상태]promise가 만들어져서,  지정한 operation을 수행하고 있는 중이라면 pending상태  operation을 성공적으로 끝내게 되면 fulfilled상태  file을 찾을 수 없거나 네트워크에 문제가 생기면 rejected상태Producer vs. Consumer  Producer  원하는 기능을 수행해 해당하는 데이터를 만들어내는 promise object  Consumer  원하는 데이터를 소비1. Producer  Promise 만들기  class라서 new 키워드를 이용해 object를 생성할 수 있음  promise 생성자를 보면 executor라는 callback fn을 전달해주어야 함          executor는 resolve (기능이 정상 수행되어 결괏값을 전달함)와  reject (기능 수행 중 문제가 생기면 호출함) 두 개의 callback fn으로 구성됨      var Promise: PromiseConstructor new &lt;any&gt;(executor: (resolve: (value: any) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; void) =&gt; Promise&lt;any&gt;const promise = new Promise((resolve, reject) =&gt; {// doing some heavy work(network, read files)console.log('doing something...');setTimeout(() =&gt; {    resolve('success!');}, 2000);});→ 어떤 일을 2000ms(=2sec)정도 하다가 잘 마무리 해서 resolve (callback fn)를 호출하여 ‘success!’라는 값을 전달하는 Promise  promise안에서는 다소 heavy한 일을 함  네트워크에서 데이터를 받아오거나 파일에서 큰 데이터를 읽어오는 과정은 시간이 꽤 걸림  시간이 많이 소요되는 과정들을 과정들을 동기적(synchronous)으로 처리하는 동안에 다음 라인의 코드는 실행되지 않게 됨  그래서 시간이 좀 걸리는 일들은 Promise를 만들어 비동기적으로 처리하는 것이 좋음※주의※ Promise를 만드는 순간, 우리가 만든 executor(callback fn)가 바로! 자동 실행됨2. Consumer  producer를 사용하는 주체      then, catch, finally 로 값을 받아옴      promise.then((value) =&gt; {      console.log(value);  })        ⇒ 위에서 만든 promise가 정상적으로 수행이 된다면(then),  value라는 parameter를 받아오는 callback fn을 수행하게 됨    ※ 여기서 value는 resolve(callback fn)으로 전달된 ‘success!’라는 값    Console  doing something…  success!resolve가 아닌 reject를 사용한다면?  reject는 주로 Error object를 통해 값을 전달함      Error object에는 어떤 error가 발생했는지 이유를 잘 명시해야함      const promise = new Promise((resolve, reject) =&gt; {      // doing some heavy work(network, read files)      console.log('doing something...');      setTimeout(() =&gt; {          // resolve('success!');          reject(new Error('no network'));      }, 2000);  });              Console      doing something…      ▶ Uncaught (in promise) Error: no network at promise.js:16:16        console장에 Uncaught (잡히지 않는)라고 뜨는 이유는 then 으로 성공적인 케이스만 다뤘기 때문임→ catch 를 이용해 error가 발생했을 때 어떻게 처리할 지 callback fn을 등록해주면 됨promise     .then((value) =&gt; {        console.log(value);    })    .catch(error =&gt; {        console.log(error);    });  Console  doing something…  Error: no network at promise.js:15:16⇒ catch의 등록으로 더는 error를 생성하지 않게 됨then과 catch를 chaining  promise의 then을 호출하면, 똑같은 Promise를 리턴함  리턴된 Promise에 catch를 호출할 수 있게 됨  (array에서 map, sort, join함수를 중첩 사용하는 것도 chaining)(method) Promise&lt;any&gt;.then&lt;void, never&gt;(onfulfilled?: (value: any) =&gt; void | PromiseLike&lt;void&gt;, onrejected?: (reason: any) =&gt; PromiseLike&lt;never&gt;): Promise&lt;void&gt;finally는 성패와 상관 없이 무조건 마지막에 호출됨const promise = new Promise((resolve, reject) =&gt; {    console.log('doing something...');    setTimeout(() =&gt; {        resolve('success!');        // reject(new Error('no network'));    }, 2000);});promise     .then((value) =&gt; {        console.log(value);    })    .catch(error =&gt; {        console.log(error);    })    .finally(() =&gt; {        console.log('finally!');    });  Console  doing something…  success!  finally!const promise = new Promise((resolve, reject) =&gt; {    console.log('doing something...');    setTimeout(() =&gt; {        // resolve('success!');        reject(new Error('no network'));    }, 2000);});promise     .then((value) =&gt; {        console.log(value);    })    .catch(error =&gt; {        console.log(error);    })    .finally(() =&gt; {        console.log('finally!');    });  Console  doing something…  Error: no network at promise.js:15:16  finally!3. Promise chainingconst fetchNumber = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(1), 1000); // 1 전달});fetchNumber.then(num =&gt; num * 2) // 1 * 2 = 2.then(num =&gt; num * 3) // 2 * 3 = 6.then(num =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; resolve(num -1), 1000);    }); // 6 - 1 = 5}).then(num =&gt; console.log(num)); // 5  Console  54. Error handlingOriginal codeconst getHen = () =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve('🐓'), 1000);});const getEgg = hen =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(`${hen} =&gt; 🥚`), 1000);});const cook = egg =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(`${egg} =&gt; 🍳`), 1000);});getHen().then(hen =&gt; getEgg(hen)).then(egg =&gt; cook(egg)).then(meal =&gt; console.log(meal));  Console  🐓 =&gt; 🥚 =&gt; 🍳tip.then에서 받아오는 value를 바로 callback fn의 parameter로 전달할 때, 중복되는 value는 생략이 가능함getHen().then(getEgg).then(cook).then(console.log)Error 발생const getHen = () =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve('🐓'), 1000);});const getEgg = hen =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; reject(new Error(`error! ${hen} =&gt; 🥚`)), 1000);});const cook = egg =&gt; new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(`${egg} =&gt; 🍳`), 1000);});  Console  ▶ Uncaught ReferenceError: Cannot access ‘getHen’ before initialization at promise.js:62:1Error를 .catch로 잡아주면,getHen().then(getEgg).then(cook).then(console.log).catch(console.log)  Console  Error: error! 🐓 =&gt; 🥚 at promise.js:71:29.then뒤에 .catch로 바로 error를 처리해주면 됨getHen().then(getEgg).catch(error =&gt; {    return '🥖';}).then(cook).then(console.log).catch(console.log)  Console  🥖 =&gt; 🍳  “자바스크립트 12. 프로미스 개념부터 활용까지 JavaScript Promise | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 28:09, 게시자 “드림코딩 by 엘리,” 2020년 6월 18일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-promise"
    }
    , 
    
    "javascript-callback": {
        "title": "JavaScript(9) - callback",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promiseSynchronous vs. AsynchronousSynchronous(동기적)  JavaScript는 synchronous(동기적)          hoisting이 된 이후부터, 코드 작성 순서에 맞추어 동기적으로 실행됨      hoisting이란?  var, function declararion 은 선언 지점과 상관 없이 JS engine에 의해 문서의 최상단으로 끌어올려짐          console.log('1');  console.log('2');  console.log('3');              Console      123      Asynchronous (비동기적)  언제 코드가 실행될 지 예측 불가  e.g.) setTimeout(): 지정한 시간이 지나면 전달한 callback fn을 호출함      function setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number          console.log('1');  setTimeout(function() {      console.log('2');  }, 1000);  console.log('3');        코드를 순차적으로 읽어감    → console.log(’1’); 실행  → setTimeout() 을 만나 1000ms(=1sec) 뒤 callback fn 실행 요청  → console.log(’3’) 실행  → 1초 뒤 console.log(’2’) 실행  (tip) 위의 callback fn는 arrow fn으로 바꿔 쓸 수 있음console.log('1');setTimeout(() =&gt; console.log('2'), 1000);console.log('3');Callback fn  나중에 다시(back) 부르는(call) 함수  synchronous와 asynchronous 두 가지가 존재함Synchronous callbackfunction printImmediately(print) {    print();}printImmediately(() =&gt; console.log('hello'));Asynchronous callbackfunction printWithDelay(print, timeout) {    setTimeout(print, timeout);}printWithDelay(()=&gt; console.log('async callback'), 2000);Resultconsole.log('1');setTimeout(() =&gt; console.log('2'), 1000);console.log('3');// Synchronous callbackfunction printImmediately(print) {    print();}printImmediately(() =&gt; console.log('hello'));// Asynchronous callbackfunction printWithDelay(print, timeout) {    setTimeout(print, timeout);}printWithDelay(()=&gt; console.log('async callback'), 2000);      코드 실행순으로 코드 나열을 다시 해보면,      function printImmediately(print) { // hoisting      print();  }  function printWithDelay(print, timeout) { // hoisting      setTimeout(print, timeout);  }  console.log('1'); // 동기  setTimeout(() =&gt; console.log('2'), 1000); // 비동기  console.log('3'); // 동기  printImmediately(() =&gt; console.log('hello')); // 동기  printWithDelay(()=&gt; console.log('async callback'), 2000); // 비동기        function declaration은 hoist되므로 코드 최상단으로 끌어올려짐  function printImmediately와 function printWithDelay가 상단으로 이동  이후 코드들을 순서대로 실행함  ‘1 → 3 → hello → 2 → async callback’ 순으로 console이 찍힘  Callback hell exampleclass UserStorage {    loginUser(id, password, onSuccess, onError) {        setTimeout(() =&gt; {            if((id === 'minji' &amp;&amp; password === 'pass') ||            (id === 'someone' &amp;&amp; password === 'pass too')            ) {                onSuccess(id);            } else {                onError(new Error('not found'));            }        }, 2000);    }    getRoles(user, onSuccess, onError) {        setTimeout(() =&gt; {            if(user === 'minji') {                onSuccess({ name: 'minji', role: 'admin' });            } else {                onError(new Error('no access'));            }        }, 1000);    }}  사용자에게 id와 password를 입력 받음  서버에 login  login이 성공적이라면 해당 id를 받아와 role 요청  role을 성공적으로 받아오면 name과 role이 있는 사용자의 object를 출력const userStorage = new UserStorage();const id = prompt('enter your id');const password = prompt('enter your password');userStorage.loginUser(    id,     password,     user =&gt; {        userStorage.getRoles(            user,            userWithRole =&gt; {                alert(`Hello ${userWithRole.name}, you have a ${userWithRole.role} role`);            },             error =&gt; {                console.log(error);            }             );    },     error =&gt; {console.log(error)});문제점  가독성이 떨어짐  error, debugging, 유지 보수가 어려움  “자바스크립트 11. 비동기 처리의 시작 콜백 이해하기, 콜백 지옥 체험 😱 JavaScript Callback | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 21:15, 게시자 “드림코딩 by 엘리,” 2020년 6월 9일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-callback"
    }
    , 
    
    "javascript-json": {
        "title": "JavaScript(8) - JSON",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promiseJSON  JavaScript Object Notation  ECMAScript 3rd 1999 Object { key : value } 에서 영감 받은 data format  data를 주고 받을 수 있는 가장 간단한 file format  text를 기반으로 해서 가벼움  읽기 쉬움  key와 value로 이루어진 file format  서버와 data를 주고 받을 때, data의 serialization과 전송을 위해 사용  프로그래밍 언어와 플랫폼에 상관 없이 사용 가능parse();parse(text: string, reviver?: (this: any, key: string, value: any) =&gt; any): any;  string data를 받아 object type으로 변환함  optional type의 reviver이라는 callbackfn을 이용하면 보다 세밀한 조건을 적용해 data를 object로 바꿀 수 있음stringify();stringify(value: any, replacer?: (this: any, key: string, value: any) =&gt; any, space?: string | number): string;  object를 받아 string으로 변환함  optional type의 replacer이라는 callbackfn을 이용하면 보다 세밀한 조건을 적용해 object를 string으로 바꿀 수 있음Object to JSONstringify(obj)      boolean / array를 JSON으로 변환     // boolean to JSON let json = JSON.stringify(true);  console.log(json); // array to JSON json = JSON.stringify(['apple', 'banana']);  console.log(json);              Console      true[“apple”, “banana”]        ※ array의 경우, [\"  \"] 형태로 출력        object를 JSON으로 변환     // object to JSON const rabbit = {      name: 'tokki',     color: 'white',     size: null,     birthDate: new Date(),     symbol: Symbol('id'),      jump: () =&gt; {          console.log(`${this.name} can jump!`);     }, }; json = JSON.stringify(rabbit); console.log(json);              Console      {“name”:”tokki”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}        ※ console에서 null은 출력되지만, Symbol과 function은 누락됨. 즉, JSON으로 변환 불가!    ⇒ boolean, array, object는 JSON으로 변환(serialize)가능 Symbol이나 함수는 JSON으로 변환 불가        (array 형태 callbackfn 사용) 원하는 property를 JSON으로 변환     json = JSON.stringify(rabbit, ['name', 'color']); console.log(json);              Console      {“name”:”tokki”,”color”:”white”}            (함수 형태 callbackfn 사용) property를 JSON으로 변환 + 조건 추가     json = JSON.stringify(rabbit, (key, value) =&gt; {     console.log(`key: ${key}, value: ${value}`);     return key === 'name' ? 'minji' : value; // 조건 추가 }); console.log(json);              Console      key: , value: [object Object]      key: name, value: tokki      key: color, value: white      key: size, value: null      key: birthDate, value: 2021-08-11T08:11:16.785Z      key: jump, value: () =&gt; {console.log(${this.name} can jump!);}      {“name”:”minji”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}      JSON to Objectparse(json)      object를 JSON으로 변환하면 string type이 됨    json = JSON.stringify(rabbit);console.log(json);console.log(typeof json);              Console      {“name”:”tokki”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}      string      ※주의※JSON을 다시 object로 만들 때 역시 함수가 포함되지 않는다!(serialize 할 때(object to JSON), 함수는 포함되지 않았음)json = JSON.stringify(rabbit);const obj = JSON.parse(json); console.log(obj);console.log(obj.birthDate.getDate()); // error!  Console  {“name”:”tokki”,”color”:”white”,”size”:null,”birthDate”:”2021-08-11T08:11:16.785Z”}※ object의 birthDate에 있던 Date()는 JSON으로 바뀌면서 string type이 되어 더이상 getDate();를 호출할 수 없게 됨      callbackfn을 이용해 object를 유의미하게 사용하기    const obj = JSON.parse(json, (key, value) =&gt; {    console.log(`key: ${key}, value: ${value}`);    return key === 'birthDate' ? new Date(value) : value;});console.log(obj);console.log(obj.birthDate.getDate());              Console      {name: ‘tokki’, color: ‘white’, size: null, birthDate: Thu Aug 12 2021 17:01:29 GMT+0900 (한국 표준시)}      12      tip) 유용한 사이트JSON Diff checker: http://www.jsondiff.com/JSON Beautifier/editor: https://jsonbeautifier.org/→ 정렬이 어그러진 JSON파일을 읽기 쉽게 정렬해줌JSON Parser: https://jsonparser.org/→ JSON을 object type으로 변환시켜 보여줌JSON Validator: https://tools.learningcontainer.com/j…→ JSON data 유효성 검사기  출처: “자바스크립트 10. JSON 개념 정리 와 활용방법 및 유용한 사이트 공유 JavaScript JSON | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 22:36, 게시자 “드림코딩 by 엘리,” 2020년 5월 31일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-json"
    }
    , 
    
    "javascript-array": {
        "title": "JavaScript(7) - array",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promiseDeclaration  new keyword 사용  [ ] 사용 ★★★★★    const arr1 = new Array();const arr2 = [1, 2];      Index position      array의 마지막 element를 찾을 때는 [array.length-1] 를 사용함    const fruits = ['🍦','🍉'];console.log(fruits);console.log(fruits[2]); // undefinedconsole.log(fruits[fruits.length-1]);              Console      (2) [‘🍦’, ‘🍉’]undefined🍉      Looping over an arraya. for loop  console.log(fruits);  for(let i = 0; i &lt; fruits.length; i++) {      console.log(fruits[i]);  }  Console  (2) [‘🍦’, ‘🍉’]🍦🍉b. for of  console.log(fruits);  for(let fruit of fruits){      console.log(fruit);  }  Console  (2) [‘🍦’, ‘🍉’]🍦🍉c. forEach  array에 들어있는 각 element마다 함수를 수행함      전달한 callback 함수를 value마다 호출    console.log(fruits);fruits.forEach(function (fruit, index, array) {    console.log(fruit, index, array);});        (※ 보통, forEach에서 array는 잘 받아오지 않음)          Console      (2) [‘🍦’, ‘🍉’]🍦 0 ▶ (2) [‘🍦’, ‘🍉’]🍉 1 ▶ (2) [‘🍦’, ‘🍉’]        console.log(fruit, index, array);              Console      🍦 0 ▶ (2) [‘🍦’, ‘🍉’]🍉 1 ▶ (2) [‘🍦’, ‘🍉’]        console.log(fruit, index);              Console      🍦 0🍉 1        console.log(fruit);              Console      🍦🍉        ※ Arrow function에서,logic이 한 줄이면 {} curly braces와 ; semicolon을 지울 수 있음    // Arrow functionfruits.forEach((fruit, index) =&gt; console.log(fruit, index));fruits.forEach((fruit) =&gt; console.log(fruit));      Addition, deletion and copya. push      배열의 마지막에 element를 더해줌    console.log(fruits);fruits.push('🍑', '🥝');console.log(fruits);              Console      (2) [‘🍦’, ‘🍉’]   (4) [‘🍦’, ‘🍉’, ‘🍑’, ‘🥝’]      b. pop  배열의 마지막 element를 제거    console.log(fruits);fruits.pop();fruits.pop();console.log(fruits);              Console      (4) [‘🍦’, ‘🍉’, ‘🍑’, ‘🥝’]  (2) [‘🍦’, ‘🍉’]      c. unshift  배열 시작에 element를 더함    console.log(fruits);fruits.unshift('🍌', '🍍');console.log(fruits);              Console      (2) [‘🍦’, ‘🍉’]   (4) [‘🍌’, ‘🍍,’🍦’, ‘🍉’]      d. shift      배열의 첫 element를 제거함    console.log(fruits);fruits.shift();console.log(fruits);              Console      (4) [‘🍌’, ‘🍍,’🍦’, ‘🍉’]  (3) [‘🍍,’🍦’, ‘🍉’]      배열의 ‘마지막’에 element를 넣고 빼는 push 와 pop 이 빠름배열의 ‘시작’에 element를 넣고 빼는 shift 와 unshift 는 느림⇒ 배열 시작 지점(index[0])에 item을 넣으려면 기존의 item들을 뒤로 이동 후 새 item을 넣어야 하며, 반대로 배열 시작 지점(index[0])의 item을 빼면, 이후의 item들을 앞으로 이동해야 하기에 시간이 오래 걸림e. splice  ( vs. slice : 배열 자체의 수정 없이 특정 부분 리턴 )  splice(index number) : 해당 index부터 끝까지 지움  splice(index number, 지우려는 개수) : 해당 index부터 개수 만큼 지움      splice(index number, 지우려는 개수, 'item1', 'item2') : 해당 index부터 개수만큼 지우고 item1, item2 추가    console.log(fruits);fruits.splice(4);console.log(fruits);fruits.splice(0, 2);console.log(fruits);fruits.splice(1, 1, '🍇', '🍏');console.log(fruits);              Console      (6) [‘🍍,’🍦’, ‘🍉’, ‘🍈’, ‘🥥’, ‘🍊’]  (4) [‘🍍,’🍦’, ‘🍉’, ‘🍈’](2) [‘🍉’, ‘🍈’](3) [‘🍉’, ‘🍇’, ‘🍏’]      f. slice  ( vs. splice : 기존 배열 자체를 수정함)  배열의 특정한 부분을 배열로 리턴      slice(시작 index, 끝나는 index);  ※ 이때, 끝나는 index는 배제됨(exclusive)!    const array = [1, 2, 3, 4, 5];const result = array.slice(2,5);console.log(result);console.log(array);              Console      (3) [3, 4, 5](5) [1, 2, 3, 4, 5]      g. concat      서로 다른 두 배열을 연결함  array이름.concat(연결할 array);      console.log(fruits);  const food = ['🍕', '🍔'];  const newFood = fruits.concat(food);  console.log(newFood);              Console      (3) [‘🍉’, ‘🍇’, ‘🍏’](5) [‘🍉’, ‘🍇’, ‘🍏’, ‘🍕’, ‘🍔’]      Searchinga. indexOf  array이름.indexOf('index를 알고 싶은 element', [검색을 시작할 index]);  배열 내에 item이 처음 등장하는 index 반환 (vs. lastIndexOf)      해당 array에 없는 item일 경우 -1 반환    console.log(fruits);console.log(fruits.indexOf('🍇'));              Console      (3) [‘🍉’, ‘🍇’, ‘🍏’]1            요소의 모든 index찾기    let indices = [];let array = ['a', 'b', 'a', 'c', 'a', 'd'];let element = 'a';let idx = array.indexOf(element);while (idx != -1) {  indices.push(idx);  idx = array.indexOf(element, idx + 1);}console.log(indices); // [0, 2, 4]        참고: Array.prototype.indexOf() - JavaScript | MDN  b. lastIndexOf  배열 내에 둘 이상의 같은 element가 있을 때, 마지막 element의 index를 반환함      array이름.lastIndexOf('index를 알고 싶은 element');    console.log(fruits);console.log('indexOf');console.log(fruits.indexOf('🍎'))console.log('lastIndexOf');console.log(fruits.lastIndexOf('🍎'));              Console      (5) [‘🍎’, ‘🍉’, ‘🍇’, ‘🍏’, ‘🍎’]04      c. includes  array이름.includes('element');  특정 element가 배열에 존재하는지 확인할 때      true/false 반환    console.log(fruits);console.log(fruits.includes('🍏')); // trueconsole.log(fruits.includes('🍤')); // false              Console      (5) [‘🍎’, ‘🍉’, ‘🍇’, ‘🍏’, ‘🍎’]truefalse      d. find  find&lt;S extends T&gt;(predicate: (this: void, value: T, index: number, obj: T[]) =&gt; value is S, thisArg?: any): S | undefined;  전달된 predicate(callbackfn)가 첫 번째로 true인 요소를 만나면 그 값을 반환(아니면 undefined 반환)하며 predicate는 종료됨      predicate(value, index, obj)는 배열의 각 요소마다 적용되며, boolean을 반환    class Student {  constructor(name, age, enrolled, score) {    this.name = name;    this.age = age;    this.enrolled = enrolled;    this.score = score;  }}const students = [  new Student('A', 29, true, 45),  new Student('B', 28, false, 80),  new Student('C', 30, true, 90),  new Student('D', 40, false, 66),  new Student('E', 18, true, 88),];const result = students.find((student)=&gt;student.score === 90);console.log(result);              Console      ▶ Student {name: ‘C’, age: 30, enrolled: true, score: 90}      e. filter  filter&lt;S extends T&gt;(predicate: (value: T, index: number, array: T[]) =&gt; value is S, thisArg?: any): S[];      predicate(callbackfn)를 전달해 이 함수가 true인 배열의 요소들만 모아 새 배열을 반환함    const result = students.filter((student)=&gt;student.enrolled === true);console.log(result);              Console      ▶ (3) [Student, Student, Student]      ▶ 0: Student {name: ‘A’, age: 29, enrolled: true, score: 45}      ▶ 1: Student {name: ‘C’, age: 30, enrolled: true, score: 90}      ▶ 2: Student {name: ‘E’, age: 18, enrolled: true, score: 88}      length: 3      ▶ [[Prototype]]: Array(0)      Stringa. join  join(separator?: string): string;  배열의 모든 요소들을 더해서 string으로 반환      (opt) 원하는 separator(구분자)를 넣어서 반환할 수 있음    const fruits = ['apple', 'banana', 'orange'];const result1 = fruits.join();const result2 = fruits.join('\\n');const result3 = fruits.join('|');console.log(result1);console.log(result2);console.log(result3);        result1: w/o separator          Console      apple, banana, orange        result2: separator \\n          Console      applebananaorange        result3: separator: |          Console      apple|banana|orange      b. splitsplit(separator: string | RegExp, limit?: number): string[];  separator(string 또는 정규표현식(RegExp))에 따라 여러 가지 문자열을 나눠 줌      (opt) limit에 반환할 배열의 크기를 지정할 수 있음    const fruits = '🍎, 🥝, 🍌, 🍒';const result1 = fruits.split(', ');const result2 = fruits.split(', ', 3);console.log(result1);console.log(result2);              Console      (4) [“🍎”, “🥝”, “🍌”, “🍒”](3) [“🍎”, “🥝”, “🍌”]      c. reversereverse(): T[];  배열의 순서를 거꾸로 만들어 리턴※ (주의) 배열 자체가 변화됨!    const array = [1, 2, 3, 4, 5];const result = array.reverse();console.log(result);console.log(array);              Console      (5) [5, 4, 3, 2, 1](5) [5, 4, 3, 2, 1]      d. sortsort(compareFn?: (a: T, b: T) =&gt; number): this;  compareFn(callbackfn)에 이전 값(a)과 현재 값(b)이 전달됨  a - b의 결과가 음수이면, a &lt; b 이므로 a, b 순서로 정렬됨  b, a 순서로 정렬하고 싶다면, b - a 를 리턴하게 하면 됨e. mapmap&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[];  배열 내의 각 요소들이 callbackfn에 의해 다른 값으로 mapping되어 반환  // students의 score만 배열로 반환  const result = students.map((student)=&gt;student.score);  console.log(result);  Console  (5) [45, 80, 90, 66, 88]f. somesome(predicate: (value: T, index: number, array: T[]) =&gt; unknown, thisArg?: any): boolean;  배열의 요소 중 predicate(callbackfn)를 만족하는 것이 하나라도 있는지 확인함      ( vs. every : 배열의 요소 전부가 predicate(callbackfn)를 만족하는지 확인)    // student의 score가 50점 미만인 요소가 있는지 확인const result = students.some((student) =&gt; student.score &lt; 50);console.log(result);              Console      true      g. reducereduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T): T;  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue: T): T;  원하는 시작부터 배열의 모든 요소의 값을 누적  return값 정의 필수  previousValue : 이전에 callbackfn에서 리턴한 값  currentValue : 배열의 요소를 순차적으로 전달 받은 값      initialValue를 지정할 수 있음    // student score의 평균 구하기const result = students.reduce((prev, curr) =&gt; prev + curr.score, 0);console.log(result/students.length);              Console      73.8      tip!      map, filter, join과 같이 배열 자체를 리턴하는 함수들은 서로 섞어서 사용이 가능    const result = students  .map((student) =&gt; student.score)  .filter((score) =&gt; score &gt; 50)  .join(', ');  console.log(result.toString());              Console      80, 90, 66, 88        출처: ‘자바스크립트 8. 배열 제대로 알고 쓰자. 자바스크립트 배열 개념과 APIs 총정리 | 프론트엔드 개발자 입문편 (JavaScript ES6 ),’ 유튜브 비디오, 32:07, 게시자 ‘드림코딩 by 엘리,’ 2020년 5월 17일, https://youtu.be/tJieVCgGzhs  출처: ‘자바스크립트 9. 유용한 10가지 배열 함수들. Array APIs 총정리 | 프론트엔드 개발자 입문편 ( JavaScript ES6),’ 유튜브 비디오, 37:13, 게시자 ‘드림코딩 by 엘리,’ 2020년 5월 24일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-array"
    }
    , 
    
    "javascript-object": {
        "title": "JavaScript(6) - object",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise※ 참고: Object - JavaScript | MDNLiterals and properties  object = { key : value }  → key와 value의 집합체    const obj1 = {}; // 'object literal' syntaxconst obj2 = new Object(); // 'object consrtuctor' syntaxconst minji = {name: 'minji', age: 4};        object literal syntax :  { } curly braces를 사용해서 생성  object constructor syntax : new keyword를 사용해서 생성  { } 안에 내용을 입력해서 생성Computed properties  perperty에 접근할 때(일반적으로 coding을 할 때)는 . 을 사용함  실시간으로(동적으로)  원하는 key의 값을 받아오고 싶을 때는 [] 을 사용함※ key는 반드시 string type으로 설정해야 함!console.log(minji.name);console.log(minji['name']);  Console  minji  minjifunction printValue(obj, key) {    console.log(obj[key]);}Property value shorthand  반복되는 object를 생성할 때는 constructor function을 사용함const person1 = {name: 'Bob', age: 2};const person2 = {name: 'Steve', age: 3};const person3 = {name: 'Dave', age: 4};// Constructor functionfunction Person(name, age) {    // this = {};    this.name = name;    this.age = age;    // return this;}const person4 = new Person('minji', 5);console.log(person4);  Console  person {name: “minji”, age: 5}in operator  in keyword를 이용해 해당 object 내에 key가 존재하는 지 확인함    console.log('name' in minji); // trueconsole.log('age' in minji); // trueconsole.log('random' in minji); // falseconsole.log(minji.random); // undefined              Console      true      true      false      undefined      for…in vs. for…of  특정 object 안의 key들을 모두 받아오려고 할 때, in 을 사용함    for (key in minji) {  console.log(key);}              Console      name      age        array나 list와 같은 data를 순차적으로 계산하거나 출력하려고 할 때, of 를 사용함    const array = [1, 2, 4, 5];for (value of array) {  console.log(value);}               Console      1      2      4      5      ※ 새로운 함수나 API를 쓰기 전에는 항상 parameter와 return값을 숙지할 것!Object.assign();참고: Object.assign() - Java Script | MDN→ 복사하고자 하는 target과 원문인 source를 parameter로 전달하면, 이 둘을 합쳐 return함const user4 = {}; // 비어있는 target 생성Object.assign(user4, user);// 또는const user4 = Object.assign({}, user);console.log(user4);  Console  {name: “minji”, age: “20”}const fruit1 = { color: 'red'};const fruit2 = { color: 'yellow', size: 'small' };const fruit3 = { color: 'green'};const mixed1 = Object.assign({}, fruit1, fruit2);const mixed2 = Object.assign({}, fruit1, fruit2, fruit3);console.log(mixed1.color); // yellowconsole.log(mixed2.color); // greenconsole.log(mixed2.size); // small  Console  yellow  green  small※ 주의! ※assign&lt;T, U, V&gt;(target: T, source1: U, source2: V): T &amp; U &amp; V; 를 적용할 때,나중에 나오는 source2는 먼저 있던 source1의 내용을 덮어 쓰게 됨  출처: “자바스크립트 7. 오브젝트 넌 뭐니? | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 23:03, 게시자 “드림코딩 by 엘리,” 2020년 5월 6일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-object"
    }
    , 
    
    "javascript-classobject": {
        "title": "JavaScript(5) - class vs. object",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promiseClass  ES6부터 도입됨  template (일종의 ‘틀’)  관련 있는 변수와 함수를 묶어 놓은 것  속성(field)과 method로 구성됨  한 번만 선언함  data가 들어있지 않아 메모리에 올라가지 않음  붕어빵 틀로 비유함class Person {    // constructor    constructor(name, age) {        // fields        this.name = name;        this.age = age;    }    // methods    speak() {        console.log(`${this.name}: hello!`);    }}const minji = new Person('minji', 20);console.log(minji.name);console.log(minji.age);minji.speak();  Console  minji  20  minji: hello!Object  class를 이용해 새로운 instance를 생성한 것  data를 넣어서 메모리에 올라감  여러 맛의 붕어빵들로 비유함Getter and settersclass User {    constructor(firstName, lastName, age) {        this.firstName = firstName;        this.lastName = lastName;        this.age = age;    }    // getter    get age() {        return this._age;    }    // setter    set age(value) {        // if(value &lt; 0) {        //     throw Error('age can not be negative');        // }        // this._age = value;        this._age = value &lt; 0 ? 0 : value;    }}const user1 = new User('Steve', 'Jobs', -1);console.log(user1.age);  age라는 getter를 정의하는 순간, this.age는 getter를 호출하게 됨.age라는 setter를 정의하는 순간, =age; 가 할당되며 setter를 호출하게 됨. 전달된 value는 setter안의 this._age에 할당되며, 메모리 값을 업데이트 함.  getter/setter에 쓰이는 변수의 이름(여기서는 _age)을 달리 사용해 call stack이 다 차는 것을 막을 수 있음public, private  too soon!  public: constructor(생성자)를 사용하지 않고 field를 정의하면  외부에서 접근이 가능함  private: # 기호를 붙이고 field를 정의하면 클래스 내부에서만 접근, 변경이 가능함class Experiment {    publicField = 2;    #privateField = 0;}const experiment = new Experiment();console.log(experiment.publicField);console.log(experiment.privateField);   Console  2  undefinedstatic  too soon!  class가 가진 고유의 값과 반복 사용하는 method들을 object와 상관없이 class이름을 이용해 호출함class Article {    static publisher = 'I am MINJI';    constructor(articleNumber) {        this.articleNumber = articleNumber;    }    static printPublisher() {        console.log(Article.publisher);    }}const article1 = new Article(1);const article2 = new Article(2);console.log(article1.publisher); // undefined -&gt; class로 호출해야 함console.log(Article.publisher);Article.printPublisher();  Console  undefined  I am MINJI  I am MINJIInheritance  extends 키워드를 사용하면 해당 클래스의 fields와 methods를 포함할 수 있음  overriding: 필요한 함수만 재정의 해서 사용함  overriding을 할 경우 부모의 함수는 더 이상 쓸 수 없게 됨. super. 를 사용해서 부모 함수를 호출해야 함.class Shape {    constructor(width, height, color) {        this.width = width;        this.height = height;        this.color = color;    }    draw() {        console.log(`drawing ${this.color} color!`);    }    getArea() {        return this.width * this.height;    }}class Rectangle extends Shape {}class Triangle extends Shape {    draw() {        super.draw();        console.log('🔺');    }    getArea() {        return (this.width * this.height) / 2;    }\t\ttoString() {        return `Triangle: color: ${this.color}`    }}const rectangle = new Rectangle(20, 20, 'blue');rectangle.draw();console.log(rectangle.getArea());const triangle = new Triangle(20, 20, 'red');triangle.draw();console.log(triangle.getArea());  Console  drawing blue color!  400  drawing red color!  🔺  200※ 참고: Inheritance in JavaScript - Web 개발 학습하기 | MDNinstanceOf  object instanceof class  왼쪽의 object가 오른쪽의 class의 instance인지 확인함  boolean 리턴console.log(rectangle instanceof Rectangle); // trueconsole.log(triangle instanceof Rectangle); // falseconsole.log(triangle instanceof Triangle); // trueconsole.log(triangle instanceof Shape); // trueconsole.log(triangle instanceof Object); // trueconsole.log(triangle.toString());  Console  true  false  true  true  true  Triangle: color: red※ JS에서 만든 모든 object class들은 JS의 Object를 상속함⇒ 어떤 object든 공통적으로 존재하는 함수들을 사용할 수 있다는 말!예시 코드의 Triangle class의 toString처럼 overriding해서 사용하면 됨Standard built-in objects⇒ 표준 내장 객체※ 참고: Standard built-in objects - JavaScript | MDN⇒ Value properties, Error objects, Indexed Collections, keyed collections, Promise, JSON 참고!  “자바스크립트 6. 클래스와 오브젝트의 차이점(class vs object), 객체지향 언어 클래스 정리 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 25:36, 게시자 “드림코딩 by 엘리,” 2020년 4월 27일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-classObject"
    }
    , 
    
    "javascript-function": {
        "title": "JavaScript(4) - function",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promiseFunction  구조          function key word를 사용함      전달받을 값은 ()안에 기입함      함수 안에서 동작할 코드는 {}(code block) 안에 작성         function name (param1, param2) {     logic...     return; }                      규칙          하나의 함수는 하나의 일을 하도록 만들어야 함      doSomething, command, verb 형태로 명명      JS에서 함수는 object        cf.) First-class function          → variable에 할당 가능          → 다른 함수의 parameter로 전달이 가능          → return 값으로 지정 가능    함수의 종류                  특정 기능을 수행하는 함수         function doSomething() {     console.log('hello!'); }                            계산을 수행한 뒤 특정 값을 전달하는 함수         function add(a, b) {     const sum = a + b;     return sum; }                      특징          program을 구성하는 기본적인 building block      subprogram이라 불리며 여러 번 재사용이 가능함      한 가지의 일(=기능 수행)을 하거나, 값을 계산/전달하기 위해 사용      Function declaration [함수 선언식]  hoist 가능: 함수가 선언되기 전에 호출이 가능함  (※ hoisting: 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림)※ 다른 언어와 다르게, JS에서는 parameter type과 return type을 명시하지 않음    ⇒ TypeScript로 보완// javascript 코드function log(message) {    console.log(message);    return 0;}// typescript 코드function log(message: string): number {    console.log(message);    return 0;}※참고: TS Playground - An online editor for exploring TypeScript and JavaScriptFunction expression [함수 표현식]  hoist 불가: 변수에 할당된 다음부터 호출이 가능함      const print = function () { // annonymous function      console.log('print');  }      Call a function [함수 호출]  함수를 선언만하고 호출하지 않으면 코드블럭 안의 코드가 실행되지 않음  방법          함수이름();으로 함수를 호출          print(); // 함수 호출                    변수();로 할당된 함수를 호출                  함수를 변수에 할당 가능함          ‘함수 이름’만 변수에 할당함 ()없이             const printAgain = print; // print함수를 printAgain 변수에 할당 printAgain(); // 호출                                          Parameters  함수 이름을 이용해 함수 자체를 인자로 전달할 수 있음  주의: 함수()형태로 쓰면 안 됨!      function doAnything(add) { // add 함수를 인자로 전달      console.log(add);      const result_add = add(3, 4);      console.log(result_add);  }  doAnything(add);      Default parameters  added in ES6  parameter= 옆에 원하는 default값을 지정할 수 있음      function showMessage(message, from = 'unknown') {      console.log(`${message} by ${from}`);  }  showMessage('Hi!');               Console      Hi! by unknown      Rest parameters  added in ES6      parameter 자리에 ... 을 입력하면 배열 형태로 전달      function printAll(...args) {      for (let i = 0; i &lt; args.length; i++) {          console.log(args[i]);      }  }  printAll('one', 'two', 'three');              Console      one      two      three      ※ 위의 for문을 보다 간단하게 나타내면,// 1.for (const arg of args) {    console.log(arg); }// 2.args.forEach((arg) =&gt; console.log(arg));Local scope  global variable vs. local variable          global variable: 함수의 바깥에 선언한 변수. 문서 전체에서 사용 가능함      local variable: 함수의 안에 선언한 변수. 함수 안에서만 사용 가능함 (block scope)  ※ 참고: Variable scope - JavaScript | MDN        밖에서는 안이 보이지 않고, 안에서만 밖을 볼 수 있다!          block 안에서는 global/local variable에 접근 가능,  block 밖에서는 local variable에 접근 불가              parent/child function에서도 동일하게 적용됨          let globalMessage = 'global'; // global variable  function printMessage() {      let message = 'hello'; // local variable      console.log(message);       console.log(globalMessage);  }  printMessage();  console.log(message); //error                          Console          hello          global                    Return a value  함수 내에 return;을 기술하지 않은 경우, return undefined; 가 생략된 것으로 간주함Tip: Early return, early exit  조건이 맞지 않을 때는 빨리 return 해서 함수를 종료 시킬 것!      필요한 logic들은 그 이후에 작성하는 것이 좋음      // bad  function upgradeUser(user) {      if(user.point &gt; 10) {          // long upgrade logic...      }  }  // good  function upgradeUser(user) {      if(user.point &lt;= 10) {          return;      }      // long upgrade logic...  }      Callback function      callback function이 parameter로 전달됨      function randomQuiz(answer, printYes, printNo) {      if (answer === 'love you') {          printYes();      } else {          printNo();      }  }  // annonymous function  const printYes = function() {       console.log('yes!');  };  // named function  const printNo = function print() {      console.log('no!');  };  randomQuiz('wrong', printYes, printNo);  randomQuiz('love you', printYes, printNo);              Console      no!      yes!        annonymous function: 이름 없는 함수      named function: 이름 있는 함수    ⇒ debugging할 때, stack trace에 함수 이름이 나오게 하기 위함  ⇒ 또는 recursion할 때 사용 ( ※ call stack )  Arrow function  항상 annonymous!      function 키워드, return 키워드, {}curly braces를 지운 뒤, 이 둘을 =&gt; 로 연결      // Annonymous function  const simplePrint = function() {      console.log(`simplePrint!`);      };  // Arrow function  const simplePrint = () =&gt; console.log('simplePrint!');            함수의 내용이 길어진다면, block을 설정하면 됨!이때, block을 설정했으므로 반드시 return 값을 기입해주어야 함!      const simpleMultiply = (a, b) =&gt; {      // do something more      return a * b;  };      IIFE  Immediately Invoked Function Expression  함수의 생성과 호출을 동시에 할 때 사용      (function)();형태로 사용      (function hello() {      console.log('IIFE');  })();              Console      IIFE        출처: “자바스크립트 5. Arrow Function은 무엇인가? 함수의 선언과 표현 | 프론트엔드 개발자 입문편(JavaScript ES6),” 유튜브 비디오, 25:01, 게시자 “드림코딩 by 엘리,” 2020년 4월 22일, https://youtu.be/tJieVCgGzhs  출처: “프로그래밍 포기 하지 마세요 (자바스크립트 함수 기본편),” 유튜브 비디오, 17:17, 게시자 “드림코딩 by 엘리,” 2020년 7월 10일, https://youtu.be/PuG2VW18O1E",
        "url": "/JavaScript-function"
    }
    , 
    
    "javascript-operator": {
        "title": "JavaScript(3) - operator",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise1. String concatenation```javascriptconsole.log('my' + ' cat');console.log('1' + 2);console.log(`string literals: 1 + 2 = ${1 + 2}`);console.log(`string literals: '''''3 + 4 = ${3 + 4}`);```&gt; **Console**  &gt; ###### my cat  &gt; ###### 12  &gt; ###### string literals: 1 + 2 = 3  &gt; ###### string literals:  &gt; ###### '''''  &gt;   &gt; ###### 3 + 4 = 7  - string literals의 경우, \\`(backtick)을 사용해 줄 바꿈과 **`'`** (single qoutation mark) 입력이 쉬움2. Logical operators:  ||(or), &amp;&amp;(and), !(not)      ||(or)  → 여러 조건 중 하나라도 true이면 true  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → true인 조건을 만나면 이후의 조건은 더 이상 읽지 않음        &amp;&amp;(and)  → 여러 조건 중 하나라도 false이면 false  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → false인 조건을 만나면 이후의 조건은 더 이상 읽지 않음  → null check할 때 유용하게 쓰임  3. Equalityconst stringFive = '5';const numberFive = 5;// == loose equality, with type conversionconsole.log(stringFive == numberFive); // trueconsole.log(stringFive != numberFive); // false// === strick equality, no type conversionconsole.log(stringFive === numberFive); // falseconsole.log(stringFive !== numberFive); // true  Console  true  false  false  true// object equality by referenceconst minji1 = { myname: 'minji'};const minji2 = { myname: 'minji'};const minji3 = minji1;console.log(minji1 == minji2); // falseconsole.log(minji1 === minji2); // falseconsole.log(minji1 === minji3); // true  Console  false  false  true→ object에는 object를 가리키는 reference를 저장함// equalityconsole.log(0 == false); // trueconsole.log(0 === false); // falseconsole.log('' == false); // trueconsole.log('' === false); // falseconsole.log(null == undefined); // trueconsole.log(null === undefined); // false⇒ 0, null, undefined, NaN, ‘’ 은 false로 간주함⇒ 0은 boolean type이 아니라서 strict equality를 적용하게 되면 0은 false가 아님⇒ null은 undefined로 간주되지만, null과 undefined는 다른 type4. Ternary operator  삼항연산자  condition?value1:value2;  조건이 간단한 경우에만 씀  조건이 복잡해질 경우에는 if나 switch를 사용하는 것이 좋음Switch statement  if, else if를 반복하게 된다면 switch를 쓰는 것이 더 나음      enum-like value check시 사용      const browser = 'IE';  switch (browser) {      case 'IE':          console.log('go away!');          break;      case 'Chrome':      case 'Firefox':          console.log('love you!'); // 'Chrome'과 'Firefox'의 결과 값이 같으므로 한번에 적어줌!          break;      default:          console.log('same all!');          break;  }      ※ 같은 결과 값을 요구한다면, case를 이어서 적어주면 됨Loopsnested loopsfor (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        console.log(`i:${i}, j:${j}`);    }}⇒ O(n^2)이므로 CPU에 좋지 않으므로 피하는 것이 좋음!continue/break// Q1. iterate from 0 to 10 and print only even numbers (use continue)for (let i = 0; i &lt; 11; i++) {    if (i % 2 !== 0) {        continue;    }    console.log(`q1. ${i}`);}// Q2. iterate from 0 to 10 and print numbers until reaching 8 (use break)for (let i = 0; i &lt; 11; i++) {    if (i &gt; 8) {        break;    }    console.log(`q2. ${i}`);}※ label은 다른 방식으로 코드를 바꿔 사용이 가능해 현업에서는 쓰지 않으니 참고!  출처: “자바스크립트 4. 코딩의 기본 operator, if, for loop 코드리뷰 팁 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 20:14, 게시자 “드림코딩 by 엘리,” 2020년 4월 15일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-operator"
    }
    , 
    
    "javascript-variable": {
        "title": "JavaScript(2) - strict mode, variable",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise1. Strict Mode  ES(ECMAScript) 5부터 추가됨  Valina JS 문서가 시작될 때, 'use strict'; 를 쓰면 strict mode로 시작  보다 상식적인 범위 내에서 코딩이 이루어 질 수 있도록 엄격한 잣대로 코드를 실행  JS engine이 보다 효율적으로 구동됨Strict mode - JavaScript | MDN2. Variable      Data types                  primitive, single item→ 더 이상 작게 쪼갤 수 없는 한 가지 아이템→ number, string, boolean, null, undefined, symbol→ 값(value) 자체가 메모리에 저장됨                    object, box container→ single item들을 묶어서 관리하는 것→ object를 가리키는 reference가 메모리에 저장됨                    function※ first-class function  → variable에 할당 가능  → 다른 함수의 parameter로 전달이 가능  → return 값으로 지정 가능                  Immutable/Mutable data types                  Immutable data types→ data 자체 변경 불가→ primitive types, frozen objects (i.e. object.freeze())                    Mutable data types→ data 변경 가능→ all objects by default are mutable in JS            let→ ES6에서 추가됨  → var는 이제 사용하지 말 것!  var hoisting변수의 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림→ var는 block scope가 적용되지 않음  → block 안에 있는 변수를 block 바깥에서도 부를 수 있는 상황이 발생함※참고:  Variable hoisting - JavaScript | MDN  {    age = 4;    var age;  }  console.log(age);  Console  4global variable vs. local variable  global variable → 함수의 바깥에 선언한 변수→ 문서 전체에서 사용 가능함  local variable → 함수의 안에 선언한 변수→ 함수 안에서만 사용 가능함 (block scope)※참고:  Variable scope - JavaScript | MDNnumber  JS에서는 숫자의 data type과 상관없이 number type으로 할당됨      const count = 17; // integer  const size = 17.1; // decimal number  console.log(`value: ${count}, type: ${typeof count}`);  console.log(`value: ${size}, type: ${typeof size}`);              Console      value: 17, type: number      value: 17.1, type: number        양수를 0으로 나누면 infinity음수를 0으로 나누면 negative infinity숫자가 아닌 것을 숫자로 나누면 NaN(not a number)string  글자는 수에 상관 없이 모두 string으로 할당됨  +기호를 사용해 다른 변수와 붙일 수 있음  const brendan = \"brendan\";  const greeting = \"hello \" + brendan;  console.log(`value: ${greeting}, type: ${typeof greeting}`);  Console  value: hello brendan, type: string      template literals (string literals)→ `(backtick)을 이용해 string과 ${variable} 을 써주면 결과 값이 붙여져 나옴→ ‘ ‘(quotes)와 +를 쓰는 것보다 편리함    const helloBob = `hi ${brendan}!`; // template literals (template string)console.log(`value: ${helloBob}, type: ${typeof helloBob}`);console.log(\"value: \" + helloBob + \", type: \" + typeof helloBob);              consol      value: hi brendan!, type: string      value: hi brendan!, type: string      boolean  false: 0, null, undefined, NaN, ‘ ‘      true: any other value    const canRead = true;const test = 3 &lt; 1; // falseconsole.log(`value: ${canRead}, type: ${typeof canRead}`);console.log(`value: ${test}, type: ${typeof test}`);        consol  value: true, type: boolean  value: false, type: booleannull / undefined  null로 할당하면 아무런 값도 없다는 것을 명시하는 것  undefined로 지정하거나 아무 것도 지정하지 않으면, 선언은 되었지만 값이 정해지지 않은 상황// nulllet nothing = null;console.log(`value: ${nothing}, type: ${typeof nothing}`);// undefinedlet x = undefined; // let x; 도 같은 뜻console.log(`value: ${x}, type: ${typeof x}`);  consol  value: null, type: object  value: undefined, type: undefinedsymbol// symbol, create unique identifiers for objectsconst symbol1 = Symbol(\"id\");const symbol2 = Symbol(\"id\");console.log(symbol1 === symbol2);const gSymbol1 = Symbol.for(\"id\");const gSymbol2 = Symbol.for(\"id\");console.log(gSymbol1 === gSymbol2); // true  consol  false  true※ .description을 이용해 string으로 변환한 뒤, 출력해야 함!console.log(`value: ${symbol1}, type: ${typeof symbol1}`); // error!console.log(`value: ${symbol1.description}, type: ${typeof symbol1}`);  console  Uncaught TypeError: Cannot convert a Symbol value to a string at ~  value: id, type: symbolobjectobject 문서 연결하기!3. Constantconst  가능하면 const로 선언하는 것이 좋음  block scope (like let)let은 mutable(변경 가능), const는 immutable(변경 불가) data type  reassignment(재할당)로 값이 바뀌거나, redeclare(재선언) 불가  장점          보안상 좋음      다양한 threads의 동시 접속으로 변수 값 변경이 일어나는 것을 방지      코드 변경시 실수를 줄여줌      4. Dynamic typing  JS = dynamically typed language→ run time 동안 할당된 값에 따라 data type 변화됨  C, JAVA = statically typed language→ 변수 선언시 data type 명시 필요    let text = \"hello\";console.log(text.charAt(0)); // hconsole.log(`value: ${text}, type: ${typeof text}`);text = 1;console.log(`value: ${text}, type: ${typeof text}`);text = \"7\" + 5;console.log(`value: ${text}, type: ${typeof text}`);text = \"8\" / \"2\";console.log(`value: ${text}, type: ${typeof text}`);console.log(text.charAt(0));              console      h      value: hello, type: string      value: 1, type: number      value: 75, type: string      value: 4, type: number      Uncaught TypeError: text.charAt is not a function at ~        → string과 숫자가 합쳐지면 string이 되고,숫자로 이루어진 string끼리의 연산이 이루어지면 number가 되는 오류 발생  (→ TS(typescript)가 나오게 되는 계기)    출처: “자바스크립트 3. 데이터타입, data types, let vs var, hoisting 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 27:58, 게시자 “드림코딩 by 엘리,” 2020년 4월 11일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-variable"
    }
    , 
    
    "javascript-asyncdefer": {
        "title": "JavaScript(1) - async vs. defer",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array    JavaScript(8) - JSON    JavaScript(9) - callback    JavaScript(10) - promise1. &lt;head&gt;tag내에서 &lt;script src=”main.js”&gt;&lt;/script&gt; 선언할 때  parsing HTML : HTML 문서를 한 줄 씩 읽어 내려가다가  &lt;script&gt; tag를 만나면 parsing을 멈추고, fetching js, executing js : js파일을 다운 받아서 실행함.  2번이 끝나면, 다시 parsing HTML을 이어서 마무리 함⇒ 단점: 사용자가 웹사이트를 보기까지 시간이 많이 걸림2. &lt;body&gt;tag 가장 아랫 부분에 &lt;script&gt;tag를 넣는 경우⇒ 장점: 사용자가 HTML 컨텐츠를 빠르게 볼 수 있음⇒ 단점: js의 영향력이 큰 페이지라면 사용자가 온전한 페이지를 접하기까지 오래 걸림3. &lt;head&gt;tag 내에 &lt;script async src=”main.js”&gt;를 선언하는 경우  HTML parsing을 하다가 async를 만나면 js문서의 다운로드를 병렬로 진행하다가  js의 다운로드가 끝나면, parsing을 멈추고 다운로드 된 js를 실행시킴  실행이 끝나면 나머지 HTML을 parsing함⇒ 장점: js의 다운로드 시간을 절약할 수 있음⇒ 단점: js가 적용되는 HTML문서의 parsing에 따른 시간 차이로 인해 오류가 생길 수 있으며, 여전히 온전한 페이지 로딩에 시간이 많이 걸림4. &lt;head&gt;tag내에 &lt;script defer src=”main.js”&gt;를 선언하는 경우★★★★★  HTML parsing 하다가 defer를 만나면 js문서의 다운로드를 병렬로 진행하다가  HTML parsing이 끝나면 사용자에게 페이지를 보여줌  다운로드 된 js를 실행시킴5. async vs. deferasync의 경우,여러 개의 js문서가 적용 순서와 상관없이 fetching이 완료된 순서로 실행이 됨→ 실행 순서가 중요하다면 오류가 생길 수 있음defer의 경우,parsing하는 동안 js가 모두 다운로드 되므로 순서대로 실행이 됨※ 그러므로, &lt;head&gt;tag 내에 &lt;script defer src=”main.js”&gt;&lt;/script&gt;로 선언하는 것이 가장 효율적이며, 안전함!  출처: “자바스크립트 2. 콘솔에 출력, script async 와 defer의 차이점 및 앞으로 자바스크립트 공부 방향 | 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 17:43, 게시자 “드림코딩 by 엘리,” 2020년 4월 7일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-asyncDefer"
    }
    , 
    
    "java-simpledateformatclass": {
        "title": "JAVA - SimpleDateFormat, Calendar 클래스",
            "author": "ohoraming",
                "category": "",
                    "content": "      SimpleDateFormat class  import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatTest {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\tSimpleDateFormat dateForm1 = new SimpleDateFormat(\"yyyy년 MM월 dd일 hh시 mm분 ss초\");\t\tSimpleDateFormat dateForm2 = new SimpleDateFormat(\"E요일\");\t\t\t\tSystem.out.println(today);\t\tSystem.out.println(dateForm1.format(today));\t\tSystem.out.println(dateForm2.format(today));\t}}  ConsoleFri Jun 18 16:59:44 KST 20212021년 06월 18일 04시 59분 44초금요일c.f.) 변화되는 시간/날짜는 시스템에서 시간 정보를 얻어오는 Calendar 클래스를 이용함      Calendar class    시스템에서 시간 정보를 얻어 오기 때문에, 반드시 getInstance() 메서드로 생성하기!!  import java.util.Calendar;public class CalendarTest {\tpublic static void main(String[] args) {\t\tCalendar now = Calendar.getInstance(); // 반드시 getInstance() 메서드로 생성!!\t\t\t\tint hour = now.get(Calendar.HOUR);\t\tint min = now.get(Calendar.MINUTE);\t\tint year = now.get(Calendar.YEAR);\t\tint month = now.get(Calendar.MONTH);\t\tint date = now.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"현재 시간은 \" + hour + \"시 \" + min + \"분입니다.\");\t\tSystem.out.println(\"오늘은 \" + year + \"년 \" + month + \"월\" + date + \"일입니다.\");\t\t\t}}  Console현재 시간은 5시 6분입니다.오늘은 2021년 5월18일입니다.  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-simpleDateFormatClass"
    }
    , 
    
    "java-overloadingoverriding": {
        "title": "JAVA - Overloading/Overriding",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding      Overloading    : C언어와는 다르게 JAVA의 경우, 인수의 개수나 종류가 다르면, 같은 이름의 메서드를 정의할 수 있음      public class OverloadTest {      \tpublic static int max(int x, int y)  \t{  \t\tif(x &gt; y) {  \t\t\treturn x;  \t\t} else {  \t\t\treturn y;  \t\t}  \t}    \t  \tpublic static double max(double x, double y)  \t{  \t\tif(x &gt; y) {  \t\t\treturn x;  \t\t} else {  \t\t\treturn y;  \t\t}  \t}      \tpublic static void main(String[] args)   \t{  \t\tint a = 10;  \t\tint b = 20;  \t\tSystem.out.println(max(a, b));    \t\t  \t\tdouble c = 10.5;  \t\tdouble d = 20.5;  \t\tSystem.out.println(max(c, d));  \t}  }        Console2020.5      Overriding    : 참고자료                  Overriding in Java - GeeksforGeeks                    Overloading in Java - GeeksforGeeks              : 다형성(Polymorphism) 의 한 종류 - 클래스로 객체를 생성할 때 호출될 메서드가 결정됨    : 객체 지향 기법의 3요소: 클래스, 상속, 다형성    : 메서드 이름, 매개 변수 동일 (overloading의 경우 매개 변수가 다름)    “Overriding in Java.” GeeksforGeeks. 2021년 6월 28일 수정, 2021년 7월 19일 접속, https://www.geeksforgeeks.org/overriding-in-java/.  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-overloadingOverriding"
    }
    , 
    
    "java-recursivemethodcall": {
        "title": "JAVA - Recursive Method Call [재귀적 메서드 호출]",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overridingpublic class RecursiveCall {\tpublic static int power(int x, int y)\t{\t\tif(y&lt;=0) {\t\t\treturn 1;\t\t} else {\t\t\treturn x * power(x, y-1);\t\t}\t}\t\tpublic static void main(String[] args) \t{\t\tSystem.out.println(\"power(2,1) : \" + power(2,1));\t\tSystem.out.println(\"power(2,2) : \" + power(2,2));\t\tSystem.out.println(\"power(2,3) : \" + power(2,3));\t\tSystem.out.println(\"power(2,4) : \" + power(2,4));\t\tSystem.out.println(\"power(2,5) : \" + power(2,5));\t}}  Consolepower(2,1) : 2power(2,2) : 4power(2,3) : 8power(2,4) : 16power(2,5) : 32      재귀적 메서드 호출(Recursive Call) 은메모리 요구가 크고, 수행 시간이 오래 걸림    예를 들어, 100개의 int형 배열을 포함한 메서드가 자기 자신을 100번 부른다면    int형 4byte * 100개 * 100번 = 40,000byte 의 메모리가 필요함.        이를 반복문(Loop Call) 으로 바꾼다면,    int형 4byte * 100개 = 400byte의 메모리가 필요함      public class LoopCall   {  \tpublic static int power (int x, int y)  \t{  \t\tint sum = 1;    \t\t  \t\twhile(y &gt; 0)  \t\t{  \t\t\tsum *= x;  \t\t\ty--;  \t\t}  \t\treturn sum;  \t}    \t  \tpublic static void main(String[] args)   \t{  \t\tSystem.out.println(\"power(2,1) : \" + power(2,1));  \t\tSystem.out.println(\"power(2,2) : \" + power(2,2));  \t\tSystem.out.println(\"power(2,3) : \" + power(2,3));  \t\tSystem.out.println(\"power(2,4) : \" + power(2,4));  \t\tSystem.out.println(\"power(2,5) : \" + power(2,5));  \t}  }        Consolepower(2,1) : 2power(2,2) : 4power(2,3) : 8power(2,4) : 16power(2,5) : 32  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-recursiveMethodCall"
    }
    , 
    
    "java-callbyvalue": {
        "title": "JAVA - Call by Value",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding인수(argument)로 매개 변수(parameter)를 전달하는 두 가지 방식  인수가 기본 데이터형(primitive type)일 경우 → Call by Value          주어진 값을 복사하여 처리하는 방식      메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않음        Class의 객체(Object)의 경우 → Call by Reference          매게 변수의 원래 주소에 값을 저장하는 방식      메서드의 실행에 따라 인수로 전달한 변수의 값이 영항을 받음⇒ Side effect : 다른 메서드에서 현재 메서드 내의 변수 값을 바꾸는 현상메서드 간 값 전달은 쉽지만, 값이 변화할 경우 심각한 문제 유발 가능성 큼(위험)⇒ 클래스 객체를 인수로 전달하는 경우에만 사용함      public class CallByValueTest {\tpublic static void swap(int x, int y) //x와 y의 값을 바꾸는 메서드\t{\t\tint temp = x;\t\tx = y;\t\ty = temp;\t\tSystem.out.println(\"swap() 메서드 내의 x = \" + x + \", y = \" + y);\t}\tpublic static void main(String[] args)\t{\t\tint a = 10;\t\tint b = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + a + \", \" + b);\t\tswap(a, b);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + a + \", \" + b);\t}}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 내의 x = 20, y = 10swap() 메서드 호출 후: 10, 20  main() 메서드의 a와 b는 swap() 메서드 내의 x와 y에 각각 값이 복사되고, x와 y의 값을 바꿈.하지만 main() 메서드의 a와 b에는 아무 영향을 미치지 않음.  main() 메서드의 a와 b의 값을 바꾸고 싶다면Call by Reference를 사용하거나, a와 b를 전역변수로 선언하여 사용하면 됨public class CallByValueTest2{\tstatic int a; //전역변수로 선언된 a와 b\tstatic int b;\tpublic static void swap() //x와 y의 값을 바꾸는 메서드\t{\t\tint temp = a;\t\ta = b;\t\tb = temp;\t\tSystem.out.println(\"swap() 메서드 내의 x = \" + a+ \", y = \" + b);\t}\tpublic static void main(String[] args)\t{\t\ta = 10;\t\tb = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + a + \", \" + b);\t\tswap();\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + a + \", \" + b);\t}}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 내의 x = 20, y = 10swap() 메서드 호출 후: 20, 10  swap(a, b); 이 아닌 swap(); 으로 호출했기에 값의 전달은 일어나지 않으며, swap() 메서드에서도 인수를 받지 않음하지만, 전역변수로 값을 바로 저장하기 때문에, 전역변수 a와 b를 사용하는 모든 메서드에 영향을 미치게 됨  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-callByValue"
    }
    , 
    
    "java-callbyreference": {
        "title": "JAVA - Call by Reference",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding인수(argument)로 매개 변수(parameter)를 전달하는 두 가지 방식  인수가 기본 데이터형(primitive type)일 경우 → Call by Value          주어진 값을 복사하여 처리하는 방식      메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않음        Class의 객체(Object)의 경우 → Call by Reference          매게 변수의 원래 주소에 값을 저장하는 방식      메서드의 실행에 따라 인수로 전달한 변수의 값이 영항을 받음⇒ Side effect : 다른 메서드에서 현재 메서드 내의 변수 값을 바꾸는 현상메서드 간 값 전달은 쉽지만, 값이 변화할 경우 심각한 문제 유발 가능성 큼(위험)⇒ 클래스 객체를 인수로 전달하는 경우에만 사용함      public class CallByReferenceTest {\tpublic static void swap(Number z)\t{\t\tint temp = z.x;\t\tz.x = z.y;\t\tz.y = temp;\t}\tpublic static void main(String[] args)\t{\t\tNumber n = new Number();\t\tn.x = 10;\t\tn.y = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + n.x + \", \" + n.y);\t\tswap(n);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + n.x + \", \" + n.y);\t}}class Number{\tpublic int x;\tpublic int y;}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 호출 후: 20, 10⇒ 여기서 class Number 는 독립적인 클래스!!⇒ 또는, 하위 클래스로 설정하되, static으로 class Number를 정의하면 됨public class CallByReferenceTest {\tpublic static void swap(Number z)\t{\t\tint temp = z.x;\t\tz.x = z.y;\t\tz.y = temp;\t}\tpublic static void main(String[] args)\t{\t\tNumber n = new Number();\t\tn.x = 13;\t\tn.y = 42;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + n.x + \", \" + n.y);\t\tswap(n);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + n.x + \", \" + n.y);\t}\tstatic class Number\t{\t\tpublic int x;\t\tpublic int y;\t}}  Consoleswap() 메서드 호출 전: 13, 42swap() 메서드 호출 후: 42, 13  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-callByReference"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ohoraming.github.io/">예비 개발자의 노트</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a>
                </section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">예비 개발자의 노트</h1>
            <p class="subscribe-overlay-description">게시글 검색</p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm" />
    <input class="location" type="hidden" name="location" />
    <input class="referrer" type="hidden" name="referrer" />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"
            placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if (event.code == 'Enter') {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function () {
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });
        });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
        </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
    <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>

</html>