<!DOCTYPE html>
<html>

<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- syntax.css 추가-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- 웹폰트(나눔 고딕) 추가 -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"> -->

    <!-- font awesome 추가 -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
        integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

    <style>
        .hljs {
            background: none;
        }

        /* web font 추가 */
        @font-face {
            font-family: 'MaruBuri-Regular';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-10-21@1.0/MaruBuri-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
    </style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="배움을 기록합니다" />
    <link rel="shortcut icon" href="https://ohoraming.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ohoraming.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="예비 개발자의 노트" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="배움을 기록합니다" />
    <meta property="og:url" content="https://ohoraming.github.io/search" />
    <meta property="og:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="배움을 기록합니다" />
    <meta name="twitter:url" content="https://ohoraming.github.io/" />
    <meta name="twitter:image" content="https://ohoraming.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="예비 개발자의 노트" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "예비 개발자의 노트",
        "logo": "https://ohoraming.github.io/"
    },
    "url": "https://ohoraming.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://ohoraming.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ohoraming.github.io/search"
    },
    "description": "배움을 기록합니다"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>

<body
    class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
        
        <a class="site-nav-logo" href="https://ohoraming.github.io/">예비 개발자의 노트</a>
        
        
        
        <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!-- About: blog에 대한 기본적인 소개-->
    <!-- C:\myblog\about\index.md에서 세부설정 -->
    <!-- href: C:\myblog\_data\authors\tags.yml에서 설정한 tag명 tag/다음에 넣음 -->
    <li class="nav-about" role="menuitem"><a href="/about/">Portfolio</a></li>

    <li class="nav-archive" role="menuitem"><a href="/tag/JAVA/">JAVA</a></li>
    <li class="nav-archive" role="menuitem"><a href="/tag/JavaScript/">JavaScript</a></li>
    <li class="nav-archive" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-archive" role="menuitem"><a href="/author_archive.html">All Tags</a></li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
        <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>
    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "javascript-array": {
        "title": "JavaScript(7) - array",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - arrayDeclaration  new keyword 사용  [ ] 사용 ★★★★★    const arr1 = new Array();const arr2 = [1, 2];        Index position    array의 마지막 element를 찾을 때는 [array.length-1] 를 사용함    const fruits = ['🍦','🍉'];console.log(fruits);console.log(fruits[2]); // undefinedconsole.log(fruits[fruits.length-1]);              Console      (2) [“🍦”, “🍉”]      0: “🍦”      1: “🍉”      length: 2      {[Prototype]}: Array(0)      undefined      🍉      Looping over an arrayfor loopfor(let i = 0; i &lt; fruits.length; i++) {    console.log(fruits[i]);}for offor(let fruit of fruits){    console.log(fruit);}forEach  forEach()  → array에 들어있는 각 element마다 함수를 수행함  → 전달한 callback 함수를 value마다 호출fruits.forEach(function (fruit, index, array) {    console.log(fruit, index, array);});// Arrow functionfruits.forEach((fruit, index) =&gt; console.log(fruit, index));fruits.forEach((fruit) =&gt; console.log(fruit));※ Arrow function에서 logic이 한 줄이면 {} curly braces와 ; semicolon을 지울 수 있음console.log(fruit, index, array);  Console  🍦 0 ▶ (2) [“🍦”, “🍉”]  🍉 1 ▶ (2) [“🍦”, “🍉”]※ 보통, forEach에서 array는 잘 받아오지 않음console.log(fruit, index);  Console  🍦 0  🍉 1console.log(fruit);  Console  🍦  🍉Addition, deletion and copypush  배열의 마지막에 element를 더해줌console.log(fruits);fruits.push('🍑', '🥝');console.log(fruits);  Console  (2) [“🍦”, “🍉”]  (4) [“🍦”, “🍉”, “🍑”, “🥝”]pop  배열의 마지막 element를 제거console.log(fruits);fruits.pop();fruits.pop();console.log(fruits);  Console  (4) [“🍦”, “🍉”, “🍑”, “🥝”]  (2) [“🍦”, “🍉”]unshift  배열 시작에 element를 더함console.log(fruits);fruits.unshift('🍌', '🍍');console.log(fruits);  Console  (2) [“🍦”, “🍉”]  (4) [“🍌”, “🍍,”🍦”, “🍉”]shift  배열의 첫 element를 제거함console.log(fruits);fruits.shift();console.log(fruits);  Console  (4) [“🍌”, “🍍,”🍦”, “🍉”]  (3) [“🍍,”🍦”, “🍉”]※ 배열에서, ‘마지막’에 element를 넣고 빼는 push와 pop이 빠름※ 배열의 ‘시작’에 element를 넣고 빼는 shift와 unshift는 느림⇒ 배열 시작 지점(index[0])에 item을 넣으려면 기존의 item들을 뒤로 이동 후 새 item을 넣어야 하며, 반대로 배열 시작 지점(index[0])의 item을 빼면, 이후의 item들을 앞으로 이동해야 하기에 시간이 오래 걸림splice  vs. slice : 배열 자체의 수정 없이 특정 부분 리턴  splice(index number, 지우려는 개수) : 해당 index부터 개수 만큼 지움  splice(index number) : 해당 index부터 끝까지 지움  splice(index number, 지우려는 개수, 'item1', 'item2') : 해당 index부터 개수만큼 지우고 ‘item1’과 ‘item2’ 추가console.log(fruits);fruits.splice(4);console.log(fruits);fruits.splice(0, 2);console.log(fruits);fruits.splice(1, 1, '🍇', '🍏');console.log(fruits);slice  vs. splice : 배열 자체를 수정함  배열의 특정한 부분을 배열로 리턴      slice(시작 index, 끝나는 index);    ※ 이때, 끝나는 index는 배제됨(exclusive)!  const array = [1, 2, 3, 4, 5];const result = array.slice(2,5);console.log(result);console.log(array);concat      서로 다른 두 배열을 연결함    array이름.concat(연결할 array);  console.log(fruits);const food = ['🍕', '🍔'];const newFood = fruits.concat(food);console.log(newFood);SearchingindexOf  array이름.indexOf('index를 알고 싶은 element', [검색을 시작할 index]);  배열 내에 item이 처음 등장하는 index 반환 (vs. lastIndexOf)  해당 array에 없는 item일 경우 -1 반환console.log(fruits);console.log(fruits.indexOf('🍇'));  요소의 모든 index찾기let indices = [];let array = ['a', 'b', 'a', 'c', 'a', 'd'];let element = 'a';let idx = array.indexOf(element);while (idx != -1) {  indices.push(idx);  idx = array.indexOf(element, idx + 1);}console.log(indices); // [0, 2, 4]            [Array.prototype.indexOf() - JavaScript      MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)      lastIndexOf  배열 내에 같은 element가 두 개 이상 있을 때, 마지막 element index를 반환함  array이름.lastIndexOf('index를 알고 싶은 element');console.log(fruits);console.log('indexOf');console.log(fruits.indexOf('🍎'))console.log('lastIndexOf');console.log(fruits.lastIndexOf('🍎'));includes  array이름.includes('element');  특정 element가 배열에 존재하는지 확인할 때  true/false 반환find  전달된 predicate(callbackfn)가 첫 번째로 true인 요소를 만나면 그 값을 반환(아니면  undefined 반환)하며 predicate는 종료됨  predicate(value, index, obj)는 배열의 각 요소마다 적용되며, boolean을 반환해야 함class Student {  constructor(name, age, enrolled, score) {    this.name = name;    this.age = age;    this.enrolled = enrolled;    this.score = score;  }}const students = [  new Student('A', 29, true, 45),  new Student('B', 28, false, 80),  new Student('C', 30, true, 90),  new Student('D', 40, false, 66),  new Student('E', 18, true, 88),];const result = students.find((student)=&gt;student.score === 90);console.log(result);filter  predicate(callbackfn)를 전달해 이 함수가 true인 배열의 요소들만 모아서 새 배열을 반환함const result = students.filter((student)=&gt;student.enrolled === true);console.log(result);Stringjoin  배열의 모든 요소들을 더해서 string으로 반환  (opt) 원하는 separator(구분자)를 넣어서 반환할 수 있음const fruits = ['apple', 'banana', 'orange'];const result1 = fruits.join();const result2 = fruits.join('\\n');const result3 = fruits.join('|');console.log(result1);console.log(result2);console.log(result3);      w/o separator            separator : \\n                                    separator:                        split                              separator(string          정규표현식)에 따라 여러 가지 문자열을 나눠 줌                      (opt) limit로 반환할 배열의 크기를 지정할 수 있음const fruits = '🍎, 🥝, 🍌, 🍒';const result1 = fruits.split(', ');const result2 = fruits.split(', ', 3);console.log(result1);console.log(result2);reverse      배열의 순서를 거꾸로 만들어 리턴    ※ (주의) 배열 자체가 변화됨!  const array = [1, 2, 3, 4, 5];const result = array.reverse();console.log(result);console.log(array);sort  compareFn(callbackfn)에 이전 값(a)과 현재 값(b)가 전달이 됨  a - b의 결과가 음수이면, a &lt; b 이므로 a, b 순서로 정렬됨  b, a 순서로 정렬하고 싶다면, b - a 를 리턴하게 하면 됨map  배열 내의 각 요소들이 callbackfn에 의해 다른 값으로 mapping해 반환// students의 score만 배열로 반환const result = students.map((student)=&gt;student.score);console.log(result);some  배열의 요소 중 predicate(callbackfn)를 만족하는 것이 하나라도 있는지 확인함  vs. every : 배열의 요소 전부가 predicate(callbackfn)를 만족하는지 확인함// student의 score가 50점 미만인 요소가 있는지 확인const result = students.some((student) =&gt; student.score &lt; 50);console.log(result);reduce  원하는 시작부터 배열의 모든 요소의 값을 누적  return값의 정의 필수  previousValue : 이전에 callbackfn에서 리턴한 값  currentValue : 배열의 요소를 순차적으로 전달 받은 값  initialValue를 지정할 수 있음// student score의 평균 구하기const result = students.reduce((prev, curr) =&gt; prev + curr.score, 0);console.log(result/students.length);tip!  map, filter, join과 같이 배열 자체를 리턴하는 함수들은 서로 섞어서 사용이 가능함const result = students  .map((student) =&gt; student.score)  .filter((score) =&gt; score &gt; 50)  .join(', ');  console.log(result.toString());  “자바스크립트 8. 배열 제대로 알고 쓰자. 자바스크립트 배열 개념과 APIs 총정리 | 프론트엔드 개발자 입문편 (JavaScript ES6 ),” 유튜브 비디오, 32:07, 게시자 “드림코딩 by 엘리,” 2020년 5월 17일, https://youtu.be/tJieVCgGzhs  “자바스크립트 9. 유용한 10가지 배열 함수들. Array APIs 총정리 | 프론트엔드 개발자 입문편 ( JavaScript ES6),” 유튜브 비디오, 37:13, 게시자 “드림코딩 by 엘리,” 2020년 5월 24일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-array"
    }
    , 
    
    "javascript-object": {
        "title": "JavaScript(6) - object",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array※ 참고:Object - JavaScript | MDNLiterals and properties  object = { key : value }  → key와 value의 집합체    const obj1 = {}; // 'object literal' syntaxconst obj2 = new Object(); // 'object consrtuctor' syntaxconst minji = {name: 'minji', age: 4};        object literal syntax :  { } curly braces를 사용해서 생성  object constructor syntax : new keyword를 사용해서 생성  { } 안에 내용을 입력해서 생성Computed properties  perperty에 접근할 때(일반적으로 coding을 할 때)는 . 을 사용함  실시간으로(동적으로)  원하는 key의 값을 받아오고 싶을 때는 [] 을 사용함※ key는 반드시 string type으로 설정해야 함!console.log(minji.name);console.log(minji['name']);  Console  minji  minjifunction printValue(obj, key) {    console.log(obj[key]);}Property value shorthand  반복되는 object를 생성할 때는 constructor function을 사용함const person1 = {name: 'Bob', age: 2};const person2 = {name: 'Steve', age: 3};const person3 = {name: 'Dave', age: 4};// Constructor functionfunction Person(name, age) {    // this = {};    this.name = name;    this.age = age;    // return this;}const person4 = new Person('minji', 5);console.log(person4);  Console  person {name: “minji”, age: 5}in operator  in keyword를 이용해 해당 object 내에 key가 존재하는 지 확인함    console.log('name' in minji); // trueconsole.log('age' in minji); // trueconsole.log('random' in minji); // falseconsole.log(minji.random); // undefined              Console      true      true      false      undefined      for…in vs. for…of  특정 object 안의 key들을 모두 받아오려고 할 때, in 을 사용함    for (key in minji) {  console.log(key);}              Console      name      age        array나 list와 같은 data를 순차적으로 계산하거나 출력하려고 할 때, of 를 사용함    const array = [1, 2, 4, 5];for (value of array) {  console.log(value);}               Console      1      2      4      5      ※ 새로운 함수나 API를 쓰기 전에는 항상 parameter와 return값을 숙지할 것!Object.assign();참고: Object.assign() - Java Script | MDN→ 복사하고자 하는 target과 원문인 source를 parameter로 전달하면, 이 둘을 합쳐 return함const user4 = {}; // 비어있는 target 생성Object.assign(user4, user);// 또는const user4 = Object.assign({}, user);console.log(user4);  Console  {name: “minji”, age: “20”}const fruit1 = { color: 'red'};const fruit2 = { color: 'yellow', size: 'small' };const fruit3 = { color: 'green'};const mixed1 = Object.assign({}, fruit1, fruit2);const mixed2 = Object.assign({}, fruit1, fruit2, fruit3);console.log(mixed1.color); // yellowconsole.log(mixed2.color); // greenconsole.log(mixed2.size); // small  Console  yellow  green  small※ 주의! ※assign&lt;T, U, V&gt;(target: T, source1: U, source2: V): T &amp; U &amp; V; 를 적용할 때,나중에 나오는 source2는 먼저 있던 source1의 내용을 덮어 쓰게 됨  “자바스크립트 7. 오브젝트 넌 뭐니? | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 23:03, 게시자 “드림코딩 by 엘리,” 2020년 5월 6일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-object"
    }
    , 
    
    "javascript-classobject": {
        "title": "JavaScript(5) - class vs. object",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - arrayClass  ES6부터 도입됨  template (일종의 ‘틀’)  관련 있는 변수와 함수를 묶어 놓은 것  속성(field)과 method로 구성됨  한 번만 선언함  data가 들어있지 않아 메모리에 올라가지 않음  붕어빵 틀로 비유함class Person {    // constructor    constructor(name, age) {        // fields        this.name = name;        this.age = age;    }    // methods    speak() {        console.log(`${this.name}: hello!`);    }}const minji = new Person('minji', 20);console.log(minji.name);console.log(minji.age);minji.speak();  Console  minji  20  minji: hello!Object  class를 이용해 새로운 instance를 생성한 것  data를 넣어서 메모리에 올라감  여러 맛의 붕어빵들로 비유함Getter and settersclass User {    constructor(firstName, lastName, age) {        this.firstName = firstName;        this.lastName = lastName;        this.age = age;    }    // getter    get age() {        return this._age;    }    // setter    set age(value) {        // if(value &lt; 0) {        //     throw Error('age can not be negative');        // }        // this._age = value;        this._age = value &lt; 0 ? 0 : value;    }}const user1 = new User('Steve', 'Jobs', -1);console.log(user1.age);  age라는 getter를 정의하는 순간, this.age는 getter를 호출하게 됨.age라는 setter를 정의하는 순간, =age; 가 할당되며 setter를 호출하게 됨. 전달된 value는 setter안의 this._age에 할당되며, 메모리 값을 업데이트 함.  getter/setter에 쓰이는 변수의 이름(여기서는 _age)을 달리 사용해 call stack이 다 차는 것을 막을 수 있음public, private  too soon!  public: constructor(생성자)를 사용하지 않고 field를 정의하면  외부에서 접근이 가능함  private: # 기호를 붙이고 field를 정의하면 클래스 내부에서만 접근, 변경이 가능함class Experiment {    publicField = 2;    #privateField = 0;}const experiment = new Experiment();console.log(experiment.publicField);console.log(experiment.privateField);   Console  2  undefinedstatic  too soon!  class가 가진 고유의 값과 반복 사용하는 method들을 object와 상관없이 class이름을 이용해 호출함class Article {    static publisher = 'I am MINJI';    constructor(articleNumber) {        this.articleNumber = articleNumber;    }    static printPublisher() {        console.log(Article.publisher);    }}const article1 = new Article(1);const article2 = new Article(2);console.log(article1.publisher); // undefined -&gt; class로 호출해야 함console.log(Article.publisher);Article.printPublisher();  Console  undefined  I am MINJI  I am MINJIInheritance  extends 키워드를 사용하면 해당 클래스의 fields와 methods를 포함할 수 있음  overriding: 필요한 함수만 재정의 해서 사용함  overriding을 할 경우 부모의 함수는 더 이상 쓸 수 없게 됨. super. 를 사용해서 부모 함수를 호출해야 함.class Shape {    constructor(width, height, color) {        this.width = width;        this.height = height;        this.color = color;    }    draw() {        console.log(`drawing ${this.color} color!`);    }    getArea() {        return this.width * this.height;    }}class Rectangle extends Shape {}class Triangle extends Shape {    draw() {        super.draw();        console.log('🔺');    }    getArea() {        return (this.width * this.height) / 2;    }\t\ttoString() {        return `Triangle: color: ${this.color}`    }}const rectangle = new Rectangle(20, 20, 'blue');rectangle.draw();console.log(rectangle.getArea());const triangle = new Triangle(20, 20, 'red');triangle.draw();console.log(triangle.getArea());  Console  drawing blue color!  400  drawing red color!  🔺  200※ 참고: Inheritance in JavaScript - Web 개발 학습하기 | MDNinstanceOf  object instanceof class  왼쪽의 object가 오른쪽의 class의 instance인지 확인함  boolean 리턴console.log(rectangle instanceof Rectangle); // trueconsole.log(triangle instanceof Rectangle); // falseconsole.log(triangle instanceof Triangle); // trueconsole.log(triangle instanceof Shape); // trueconsole.log(triangle instanceof Object); // trueconsole.log(triangle.toString());  Console  true  false  true  true  true  Triangle: color: red※ JS에서 만든 모든 object class들은 JS의 Object를 상속함⇒ 어떤 object든 공통적으로 존재하는 함수들을 사용할 수 있다는 말!예시 코드의 Triangle class의 toString처럼 overriding해서 사용하면 됨Standard built-in objects⇒ 표준 내장 객체※ 참고: Standard built-in objects - JavaScript | MDN⇒ Value properties, Error objects, Indexed Collections, keyed collections, Promise, JSON 참고!  “자바스크립트 6. 클래스와 오브젝트의 차이점(class vs object), 객체지향 언어 클래스 정리 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 25:36, 게시자 “드림코딩 by 엘리,” 2020년 4월 27일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-classObject"
    }
    , 
    
    "javascript-function": {
        "title": "JavaScript(4) - function",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - arrayFunction  특징          program을 구성하는 기본적인 building block      subprogram이라 불리며 여러 번 재사용이 가능함      한 가지의 일을 하거나, 값을 계산하기 위해 사용됨        구조    function name (param1, param2) {  logic...  return;}        규칙          하나의 함수는 하나의 일을 하도록 만들어야 함      doSomething, command, verb 형태로 명명      JS에서 함수는 object임      cf.) First-class function        → variable에 할당 가능        → 다른 함수의 parameter로 전달이 가능        → return 값으로 지정 가능Function declaration  hoist 가능: 함수가 선언되기 전에 호출이 가능함  (※ hoisting: 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림)※ JS에서는 parameter type과 return type을 명시하지 않음    ⇒ TypeScript로 보완// javascript 코드function log(message) {    console.log(message);    return 0;}// typescript 코드function log(message: string): number {    console.log(message);    return 0;}※참고: TS Playground - An online editor for exploring TypeScript and JavaScriptFunction expression  변수에 할당된 다음부터 호출이 가능함 (hoist 불가)    const print = function () { // annonymous function  console.log('print');}print(); // 함수 호출const printAgain = print;printAgain(); // 함수 호출        이름 없는 함수 ⇒ annonymous function (cf.) named function)  변수(); 의 형태로 할당된 함수를 호출할 수 있게 됨Default parameters  added in ES6  parameter 옆에 원하는 default값을 지정할 수 있음    function showMessage(message, from = 'unknown') {  console.log(`${message} by ${from}`);}showMessage('Hi!');               Console      Hi! by unknown      Rest parameters  added in ES6  parameter 자리에 ... 을 입력하면 배열 형태로 전달function printAll(...args) {    for (let i = 0; i &lt; args.length; i++) {        console.log(args[i]);    }}printAll('one', 'two', 'three');  Console  one  two  three※ 위의 for문을 보다 간단하게 나타내면,// 1.for (const arg of args) {    console.log(arg); }// 2.args.forEach((arg) =&gt; console.log(arg));Local scope  global variable vs. local variable          global variable: 함수의 바깥에 선언한 변수. 문서 전체에서 사용 가능함      local variable: 함수의 안에 선언한 변수. 함수 안에서만 사용 가능함 (block scope)  ※ 참고: Variable scope - JavaScript | MDN      ⇒ 밖에서는 안이 보이지 않고, 안에서만 밖을 볼 수 있다!  block 안에서는 global/local variable에 접근 가능,  block 밖에서는 local variable에 접근 불가  parent/child function에서도 동일하게 적용됨let globalMessage = 'global'; // global variablefunction printMessage() {    let message = 'hello';    console.log(message); // local variable    console.log(globalMessage);}printMessage();// console.log(message); //error  Console  hello  globalReturn a value  함수 내에서 return;을 기술하지 않은 경우, return undefined; 가 생략된 것으로 간주함📌Tip: Early return, early exit  조건이 맞지 않을 때는 빨리 return 해서 함수를 종료 시킬 것!  필요한 logic들은 그 이후에 작성하는 것이 좋음// badfunction upgradeUser(user) {    if(user.point &gt; 10) {        // long upgrade logic...    }}// goodfunction upgradeUser(user) {    if(user.point &lt;= 10) {        return;    }    // long upgrade logic...}Callback function  callback function이 parameter로 전달됨function randomQuiz(answer, printYes, printNo) {    if (answer === 'love you') {        printYes();    } else {        printNo();    }}// annonymous functionconst printYes = function() {     console.log('yes!');};// named functionconst printNo = function print() {    console.log('no!');};randomQuiz('wrong', printYes, printNo);randomQuiz('love you', printYes, printNo);  Console  no!  yes!  annonymous function: 이름 없는 함수      named function: 이름 있는 함수    ⇒ debugging할 때, stack trace에 함수 이름이 나오게 하기 위함    ⇒ 또는 recursion할 때 사용 ( ※ call stack )  Arrow function  항상 annonymous!  function 키워드, return 키워드, curly braces를 지운 뒤, 이 둘을 =&gt; 로 연결// Annonymous functionconst simplePrint = function() {    console.log(`simplePrint!`);    };// Arrow functionconst simplePrint = () =&gt; console.log('simplePrint!');  함수의 내용이 길어진다면, block을 설정하면 됨!이때, block을 설정했으므로 반드시 return 값을 기입해주어야 함!const simpleMultiply = (a, b) =&gt; {    // do something more    return a * b;};📌Tip: IIFE  Immediately Invoked Function Expression  함수의 생성과 호출을 동시에 할 때 사용  (function)();(function hello() {    console.log('IIFE');})();  Console  IIFE  출처: “자바스크립트 5. Arrow Function은 무엇인가? 함수의 선언과 표현 | 프론트엔드 개발자 입문편(JavaScript ES6),” 유튜브 비디오, 25:01, 게시자 “드림코딩 by 엘리,” 2020년 4월 22일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-function"
    }
    , 
    
    "javascript-operator": {
        "title": "JavaScript(3) - operator",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array1. String concatenationconsole.log('my' + ' cat');console.log('1' + 2);console.log(`string literals: 1 + 2 = ${1 + 2}`);console.log(`string literals: '''''3 + 4 = ${3 + 4}`);  Console  my cat  12  string literals: 1 + 2 = 3  string literals:  ’’’’’  3 + 4 = 7  string literals의 경우, `(backtick)을 사용해 줄 바꿈과 ' (single qoutation mark) 입력이 쉬움2. Logical operators:  ||(or), &amp;&amp;(and), !(not)      ||(or)  → 여러 조건 중 하나라도 true이면 true  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → true인 조건을 만나면 이후의 조건은 더 이상 읽지 않음        &amp;&amp;(and)  → 여러 조건 중 하나라도 false이면 false  → 조건을 나열할 때, 연산이 많은 것일수록 뒤에 선언하는 것이 좋음  → false인 조건을 만나면 이후의 조건은 더 이상 읽지 않음  → null check할 때 유용하게 쓰임  3. Equalityconst stringFive = '5';const numberFive = 5;// == loose equality, with type conversionconsole.log(stringFive == numberFive); // trueconsole.log(stringFive != numberFive); // false// === strick equality, no type conversionconsole.log(stringFive === numberFive); // falseconsole.log(stringFive !== numberFive); // true  Console  true  false  false  true// object equality by referenceconst minji1 = { myname: 'minji'};const minji2 = { myname: 'minji'};const minji3 = minji1;console.log(minji1 == minji2); // falseconsole.log(minji1 === minji2); // falseconsole.log(minji1 === minji3); // true  Console  false  false  true→ object에는 object를 가리키는 reference를 저장함// equalityconsole.log(0 == false); // trueconsole.log(0 === false); // falseconsole.log('' == false); // trueconsole.log('' === false); // falseconsole.log(null == undefined); // trueconsole.log(null === undefined); // false⇒ 0, null, undefined, NaN, ‘’ 은 false로 간주함⇒ 0은 boolean type이 아니라서 strict equality를 적용하게 되면 0은 false가 아님⇒ null은 undefined로 간주되지만, null과 undefined는 다른 type4. Ternary operator  삼항연산자  condition?value1:value2;  조건이 간단한 경우에만 씀  조건이 복잡해질 경우에는 if나 switch를 사용하는 것이 좋음Switch statement  if, else if를 반복하게 된다면 switch를 쓰는 것이 더 나음  enum-like value check시 사용const browser = 'IE';switch (browser) {    case 'IE':        console.log('go away!');        break;    case 'Chrome':    case 'Firefox':        console.log('love you!'); // 'Chrome'과 'Firefox'의 결과 값이 같으므로 한번에 적어줌!        break;    default:        console.log('same all!');        break;}※ 같은 결과 값을 요구한다면, case를 이어서 적어주면 됨Loopsnested loopsfor (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        console.log(`i:${i}, j:${j}`);    }}⇒ O(n^2)이므로 CPU에 좋지 않으므로 피하는 것이 좋음!continue/break// Q1. iterate from 0 to 10 and print only even numbers (use continue)for (let i = 0; i &lt; 11; i++) {    if (i % 2 !== 0) {        continue;    }    console.log(`q1. ${i}`);}// Q2. iterate from 0 to 10 and print numbers until reaching 8 (use break)for (let i = 0; i &lt; 11; i++) {    if (i &gt; 8) {        break;    }    console.log(`q2. ${i}`);}※ label은 다른 방식으로 코드를 바꿔 사용이 가능해 현업에서는 쓰지 않으니 참고!  출처: “자바스크립트 4. 코딩의 기본 operator, if, for loop 코드리뷰 팁 | 프론트엔드 개발자 입문편 (JavaScript ES6),” 유튜브 비디오, 20:14, 게시자 “드림코딩 by 엘리,” 2020년 4월 15일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-operator"
    }
    , 
    
    "javascript-variable": {
        "title": "JavaScript(2) - strict mode, variable",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array1. Strict Mode  ES(ECMAScript) 5부터 추가됨  Valina JS 문서가 시작될 때, 'use strict'; 를 쓰면 strict mode로 시작  보다 상식적인 범위 내에서 코딩이 이루어 질 수 있도록 엄격한 잣대로 코드를 실행  JS engine이 보다 효율적으로 구동됨Strict mode - JavaScript | MDN2. Variable      Data types                  primitive, single item→ 더 이상 작게 쪼갤 수 없는 한 가지 아이템→ number, string, boolean, null, undefined, symbol→ 값(value) 자체가 메모리에 저장됨                    object, box container→ single item들을 묶어서 관리하는 것→ object를 가리키는 reference가 메모리에 저장됨                    function※ first-class function  → variable에 할당 가능  → 다른 함수의 parameter로 전달이 가능  → return 값으로 지정 가능                  Immutable/Mutable data types                  Immutable data types→ data 자체 변경 불가→ primitive types, frozen objects (i.e. object.freeze())                    Mutable data types→ data 변경 가능→ all objects by default are mutable in JS            let→ ES6에서 추가됨  → var는 이제 사용하지 말 것!  var hoisting변수의 선언 지점과 상관없이, JS engine이 선언을 맨 위로 끌어올림→ var는 block scope가 적용되지 않음  → block 안에 있는 변수를 block 바깥에서도 부를 수 있는 상황이 발생함※참고:  Variable hoisting - JavaScript | MDN  {    age = 4;    var age;  }  console.log(age);  Console  4global variable vs. local variable  global variable → 함수의 바깥에 선언한 변수→ 문서 전체에서 사용 가능함  local variable → 함수의 안에 선언한 변수→ 함수 안에서만 사용 가능함 (block scope)※참고:  Variable scope - JavaScript | MDNnumber  JS에서는 숫자의 data type과 상관없이 number type으로 할당됨      const count = 17; // integer  const size = 17.1; // decimal number  console.log(`value: ${count}, type: ${typeof count}`);  console.log(`value: ${size}, type: ${typeof size}`);              Console      value: 17, type: number      value: 17.1, type: number        양수를 0으로 나누면 infinity음수를 0으로 나누면 negative infinity숫자가 아닌 것을 숫자로 나누면 NaN(not a number)string  글자는 수에 상관 없이 모두 string으로 할당됨  +기호를 사용해 다른 변수와 붙일 수 있음  const brendan = \"brendan\";  const greeting = \"hello \" + brendan;  console.log(`value: ${greeting}, type: ${typeof greeting}`);  Console  value: hello brendan, type: string      template literals (string literals)→ `(backtick)을 이용해 string과 ${variable} 을 써주면 결과 값이 붙여져 나옴→ ‘ ‘(quotes)와 +를 쓰는 것보다 편리함    const helloBob = `hi ${brendan}!`; // template literals (template string)console.log(`value: ${helloBob}, type: ${typeof helloBob}`);console.log(\"value: \" + helloBob + \", type: \" + typeof helloBob);              consol      value: hi brendan!, type: string      value: hi brendan!, type: string      boolean  false: 0, null, undefined, NaN, ‘ ‘      true: any other value    const canRead = true;const test = 3 &lt; 1; // falseconsole.log(`value: ${canRead}, type: ${typeof canRead}`);console.log(`value: ${test}, type: ${typeof test}`);        consol  value: true, type: boolean  value: false, type: booleannull / undefined  null로 할당하면 아무런 값도 없다는 것을 명시하는 것  undefined로 지정하거나 아무 것도 지정하지 않으면, 선언은 되었지만 값이 정해지지 않은 상황// nulllet nothing = null;console.log(`value: ${nothing}, type: ${typeof nothing}`);// undefinedlet x = undefined; // let x; 도 같은 뜻console.log(`value: ${x}, type: ${typeof x}`);  consol  value: null, type: object  value: undefined, type: undefinedsymbol// symbol, create unique identifiers for objectsconst symbol1 = Symbol(\"id\");const symbol2 = Symbol(\"id\");console.log(symbol1 === symbol2);const gSymbol1 = Symbol.for(\"id\");const gSymbol2 = Symbol.for(\"id\");console.log(gSymbol1 === gSymbol2); // true  consol  false  true※ .description을 이용해 string으로 변환한 뒤, 출력해야 함!console.log(`value: ${symbol1}, type: ${typeof symbol1}`); // error!console.log(`value: ${symbol1.description}, type: ${typeof symbol1}`);  console  Uncaught TypeError: Cannot convert a Symbol value to a string at ~  value: id, type: symbolobjectobject 문서 연결하기!3. Constantconst  가능하면 const로 선언하는 것이 좋음  block scope (like let)let은 mutable(변경 가능), const는 immutable(변경 불가) data type  reassignment(재할당)로 값이 바뀌거나, redeclare(재선언) 불가  장점          보안상 좋음      다양한 threads의 동시 접속으로 변수 값 변경이 일어나는 것을 방지      코드 변경시 실수를 줄여줌      4. Dynamic typing  JS = dynamically typed language→ run time 동안 할당된 값에 따라 data type 변화됨  C, JAVA = statically typed language→ 변수 선언시 data type 명시 필요    let text = \"hello\";console.log(text.charAt(0)); // hconsole.log(`value: ${text}, type: ${typeof text}`);text = 1;console.log(`value: ${text}, type: ${typeof text}`);text = \"7\" + 5;console.log(`value: ${text}, type: ${typeof text}`);text = \"8\" / \"2\";console.log(`value: ${text}, type: ${typeof text}`);console.log(text.charAt(0));              console      h      value: hello, type: string      value: 1, type: number      value: 75, type: string      value: 4, type: number      Uncaught TypeError: text.charAt is not a function at ~        → string과 숫자가 합쳐지면 string이 되고,숫자로 이루어진 string끼리의 연산이 이루어지면 number가 되는 오류 발생  (→ TS(typescript)가 나오게 되는 계기)    출처: “자바스크립트 3. 데이터타입, data types, let vs var, hoisting 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 27:58, 게시자 “드림코딩 by 엘리,” 2020년 4월 11일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-variable"
    }
    , 
    
    "javascript-asyncdefer": {
        "title": "JavaScript(1) - async vs. defer",
            "author": "ohoraming",
                "category": "",
                    "content": "JavaScript 관련 포스팅    JavaScript(1) - async vs. defer    JavaScript(2) - variable    JavaScript(3) - operator    JavaScript(4) - function    JavaScript(5) - class vs. object    JavaScript(6) - object    JavaScript(7) - array1. &lt;head&gt;tag내에서 &lt;script src=”main.js”&gt;&lt;/script&gt; 선언할 때  parsing HTML : HTML 문서를 한 줄 씩 읽어 내려가다가  &lt;script&gt; tag를 만나면 parsing을 멈추고, fetching js, executing js : js파일을 다운 받아서 실행함.  2번이 끝나면, 다시 parsing HTML을 이어서 마무리 함⇒ 단점: 사용자가 웹사이트를 보기까지 시간이 많이 걸림2. &lt;body&gt;tag 가장 아랫 부분에 &lt;script&gt;tag를 넣는 경우⇒ 장점: 사용자가 HTML 컨텐츠를 빠르게 볼 수 있음⇒ 단점: js의 영향력이 큰 페이지라면 사용자가 온전한 페이지를 접하기까지 오래 걸림3. &lt;head&gt;tag 내에 &lt;script async src=”main.js”&gt;를 선언하는 경우  HTML parsing을 하다가 async를 만나면 js문서의 다운로드를 병렬로 진행하다가  js의 다운로드가 끝나면, parsing을 멈추고 다운로드 된 js를 실행시킴  실행이 끝나면 나머지 HTML을 parsing함⇒ 장점: js의 다운로드 시간을 절약할 수 있음⇒ 단점: js가 적용되는 HTML문서의 parsing에 따른 시간 차이로 인해 오류가 생길 수 있으며, 여전히 온전한 페이지 로딩에 시간이 많이 걸림4. &lt;head&gt;tag내에 &lt;script defer src=”main.js”&gt;를 선언하는 경우★★★★★  HTML parsing 하다가 defer를 만나면 js문서의 다운로드를 병렬로 진행하다가  HTML parsing이 끝나면 사용자에게 페이지를 보여줌  다운로드 된 js를 실행시킴5. async vs. deferasync의 경우,여러 개의 js문서가 적용 순서와 상관없이 fetching이 완료된 순서로 실행이 됨→ 실행 순서가 중요하다면 오류가 생길 수 있음defer의 경우,parsing하는 동안 js가 모두 다운로드 되므로 순서대로 실행이 됨※ 그러므로, &lt;head&gt;tag 내에 &lt;script defer src=”main.js”&gt;&lt;/script&gt;로 선언하는 것이 가장 효율적이며, 안전함!  “자바스크립트 2. 콘솔에 출력, script async 와 defer의 차이점 및 앞으로 자바스크립트 공부 방향 | 프론트엔드 개발자 입문편 (JavaScript ES5+),” 유튜브 비디오, 17:43, 게시자 “드림코딩 by 엘리,” 2020년 4월 7일, https://youtu.be/tJieVCgGzhs",
        "url": "/JavaScript-asyncDefer"
    }
    , 
    
    "java-simpledateformatclass": {
        "title": "JAVA - SimpleDateFormat, Calendar 클래스",
            "author": "ohoraming",
                "category": "",
                    "content": "      SimpleDateFormat class  import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatTest {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\tSimpleDateFormat dateForm1 = new SimpleDateFormat(\"yyyy년 MM월 dd일 hh시 mm분 ss초\");\t\tSimpleDateFormat dateForm2 = new SimpleDateFormat(\"E요일\");\t\t\t\tSystem.out.println(today);\t\tSystem.out.println(dateForm1.format(today));\t\tSystem.out.println(dateForm2.format(today));\t}}  ConsoleFri Jun 18 16:59:44 KST 20212021년 06월 18일 04시 59분 44초금요일c.f.) 변화되는 시간/날짜는 시스템에서 시간 정보를 얻어오는 Calendar 클래스를 이용함      Calendar class    시스템에서 시간 정보를 얻어 오기 때문에, 반드시 getInstance() 메서드로 생성하기!!  import java.util.Calendar;public class CalendarTest {\tpublic static void main(String[] args) {\t\tCalendar now = Calendar.getInstance(); // 반드시 getInstance() 메서드로 생성!!\t\t\t\tint hour = now.get(Calendar.HOUR);\t\tint min = now.get(Calendar.MINUTE);\t\tint year = now.get(Calendar.YEAR);\t\tint month = now.get(Calendar.MONTH);\t\tint date = now.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"현재 시간은 \" + hour + \"시 \" + min + \"분입니다.\");\t\tSystem.out.println(\"오늘은 \" + year + \"년 \" + month + \"월\" + date + \"일입니다.\");\t\t\t}}  Console현재 시간은 5시 6분입니다.오늘은 2021년 5월18일입니다.  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-simpleDateFormatClass"
    }
    , 
    
    "java-overloadingoverriding": {
        "title": "JAVA - Overloading/Overriding",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding      Overloading    : C언어와는 다르게 JAVA의 경우, 인수의 개수나 종류가 다르면, 같은 이름의 메서드를 정의할 수 있음      public class OverloadTest {      \tpublic static int max(int x, int y)  \t{  \t\tif(x &gt; y) {  \t\t\treturn x;  \t\t} else {  \t\t\treturn y;  \t\t}  \t}    \t  \tpublic static double max(double x, double y)  \t{  \t\tif(x &gt; y) {  \t\t\treturn x;  \t\t} else {  \t\t\treturn y;  \t\t}  \t}      \tpublic static void main(String[] args)   \t{  \t\tint a = 10;  \t\tint b = 20;  \t\tSystem.out.println(max(a, b));    \t\t  \t\tdouble c = 10.5;  \t\tdouble d = 20.5;  \t\tSystem.out.println(max(c, d));  \t}  }        Console2020.5      Overriding    : 참고자료                  Overriding in Java - GeeksforGeeks                    Overloading in Java - GeeksforGeeks              : 다형성(Polymorphism) 의 한 종류 - 클래스로 객체를 생성할 때 호출될 메서드가 결정됨    : 객체 지향 기법의 3요소: 클래스, 상속, 다형성    : 메서드 이름, 매개 변수 동일 (overloading의 경우 매개 변수가 다름)    “Overriding in Java.” GeeksforGeeks. 2021년 6월 28일 수정, 2021년 7월 19일 접속, https://www.geeksforgeeks.org/overriding-in-java/.  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-overloadingOverriding"
    }
    , 
    
    "java-recursivemethodcall": {
        "title": "JAVA - Recursive Method Call [재귀적 메서드 호출]",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overridingpublic class RecursiveCall {\tpublic static int power(int x, int y)\t{\t\tif(y&lt;=0) {\t\t\treturn 1;\t\t} else {\t\t\treturn x * power(x, y-1);\t\t}\t}\t\tpublic static void main(String[] args) \t{\t\tSystem.out.println(\"power(2,1) : \" + power(2,1));\t\tSystem.out.println(\"power(2,2) : \" + power(2,2));\t\tSystem.out.println(\"power(2,3) : \" + power(2,3));\t\tSystem.out.println(\"power(2,4) : \" + power(2,4));\t\tSystem.out.println(\"power(2,5) : \" + power(2,5));\t}}  Consolepower(2,1) : 2power(2,2) : 4power(2,3) : 8power(2,4) : 16power(2,5) : 32      재귀적 메서드 호출(Recursive Call) 은메모리 요구가 크고, 수행 시간이 오래 걸림    예를 들어, 100개의 int형 배열을 포함한 메서드가 자기 자신을 100번 부른다면    int형 4byte * 100개 * 100번 = 40,000byte 의 메모리가 필요함.        이를 반복문(Loop Call) 으로 바꾼다면,    int형 4byte * 100개 = 400byte의 메모리가 필요함      public class LoopCall   {  \tpublic static int power (int x, int y)  \t{  \t\tint sum = 1;    \t\t  \t\twhile(y &gt; 0)  \t\t{  \t\t\tsum *= x;  \t\t\ty--;  \t\t}  \t\treturn sum;  \t}    \t  \tpublic static void main(String[] args)   \t{  \t\tSystem.out.println(\"power(2,1) : \" + power(2,1));  \t\tSystem.out.println(\"power(2,2) : \" + power(2,2));  \t\tSystem.out.println(\"power(2,3) : \" + power(2,3));  \t\tSystem.out.println(\"power(2,4) : \" + power(2,4));  \t\tSystem.out.println(\"power(2,5) : \" + power(2,5));  \t}  }        Consolepower(2,1) : 2power(2,2) : 4power(2,3) : 8power(2,4) : 16power(2,5) : 32  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-recursiveMethodCall"
    }
    , 
    
    "java-callbyvalue": {
        "title": "JAVA - Call by Value",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding인수(argument)로 매개 변수(parameter)를 전달하는 두 가지 방식  인수가 기본 데이터형(primitive type)일 경우 → Call by Value          주어진 값을 복사하여 처리하는 방식      메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않음        Class의 객체(Object)의 경우 → Call by Reference          매게 변수의 원래 주소에 값을 저장하는 방식      메서드의 실행에 따라 인수로 전달한 변수의 값이 영항을 받음⇒ Side effect : 다른 메서드에서 현재 메서드 내의 변수 값을 바꾸는 현상메서드 간 값 전달은 쉽지만, 값이 변화할 경우 심각한 문제 유발 가능성 큼(위험)⇒ 클래스 객체를 인수로 전달하는 경우에만 사용함      public class CallByValueTest {\tpublic static void swap(int x, int y) //x와 y의 값을 바꾸는 메서드\t{\t\tint temp = x;\t\tx = y;\t\ty = temp;\t\tSystem.out.println(\"swap() 메서드 내의 x = \" + x + \", y = \" + y);\t}\tpublic static void main(String[] args)\t{\t\tint a = 10;\t\tint b = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + a + \", \" + b);\t\tswap(a, b);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + a + \", \" + b);\t}}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 내의 x = 20, y = 10swap() 메서드 호출 후: 10, 20  main() 메서드의 a와 b는 swap() 메서드 내의 x와 y에 각각 값이 복사되고, x와 y의 값을 바꿈.하지만 main() 메서드의 a와 b에는 아무 영향을 미치지 않음.  main() 메서드의 a와 b의 값을 바꾸고 싶다면Call by Reference를 사용하거나, a와 b를 전역변수로 선언하여 사용하면 됨public class CallByValueTest2{\tstatic int a; //전역변수로 선언된 a와 b\tstatic int b;\tpublic static void swap() //x와 y의 값을 바꾸는 메서드\t{\t\tint temp = a;\t\ta = b;\t\tb = temp;\t\tSystem.out.println(\"swap() 메서드 내의 x = \" + a+ \", y = \" + b);\t}\tpublic static void main(String[] args)\t{\t\ta = 10;\t\tb = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + a + \", \" + b);\t\tswap();\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + a + \", \" + b);\t}}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 내의 x = 20, y = 10swap() 메서드 호출 후: 20, 10  swap(a, b); 이 아닌 swap(); 으로 호출했기에 값의 전달은 일어나지 않으며, swap() 메서드에서도 인수를 받지 않음하지만, 전역변수로 값을 바로 저장하기 때문에, 전역변수 a와 b를 사용하는 모든 메서드에 영향을 미치게 됨  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-callByValue"
    }
    , 
    
    "java-callbyreference": {
        "title": "JAVA - Call by Reference",
            "author": "ohoraming",
                "category": "",
                    "content": "JAVA call 관련 포스팅    JAVA - Call by Value    JAVA - Call by Reference    JAVA - Recursive Method Call [재귀적 메서드 호출]    JAVA - Overloading/Overriding인수(argument)로 매개 변수(parameter)를 전달하는 두 가지 방식  인수가 기본 데이터형(primitive type)일 경우 → Call by Value          주어진 값을 복사하여 처리하는 방식      메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않음        Class의 객체(Object)의 경우 → Call by Reference          매게 변수의 원래 주소에 값을 저장하는 방식      메서드의 실행에 따라 인수로 전달한 변수의 값이 영항을 받음⇒ Side effect : 다른 메서드에서 현재 메서드 내의 변수 값을 바꾸는 현상메서드 간 값 전달은 쉽지만, 값이 변화할 경우 심각한 문제 유발 가능성 큼(위험)⇒ 클래스 객체를 인수로 전달하는 경우에만 사용함      public class CallByReferenceTest {\tpublic static void swap(Number z)\t{\t\tint temp = z.x;\t\tz.x = z.y;\t\tz.y = temp;\t}\tpublic static void main(String[] args)\t{\t\tNumber n = new Number();\t\tn.x = 10;\t\tn.y = 20;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + n.x + \", \" + n.y);\t\tswap(n);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + n.x + \", \" + n.y);\t}}class Number{\tpublic int x;\tpublic int y;}  Consoleswap() 메서드 호출 전: 10, 20swap() 메서드 호출 후: 20, 10⇒ 여기서 class Number 는 독립적인 클래스!!⇒ 또는, 하위 클래스로 설정하되, static으로 class Number를 정의하면 됨public class CallByReferenceTest {\tpublic static void swap(Number z)\t{\t\tint temp = z.x;\t\tz.x = z.y;\t\tz.y = temp;\t}\tpublic static void main(String[] args)\t{\t\tNumber n = new Number();\t\tn.x = 13;\t\tn.y = 42;\t\tSystem.out.println(\"swap() 메서드 호출 전: \" + n.x + \", \" + n.y);\t\tswap(n);\t\tSystem.out.println(\"swap() 메서드 호출 후: \" + n.x + \", \" + n.y);\t}\tstatic class Number\t{\t\tpublic int x;\t\tpublic int y;\t}}  Consoleswap() 메서드 호출 전: 13, 42swap() 메서드 호출 후: 42, 13  임동혁, 게임을 만들면서 배우는 What’s up JAVA (서울: 북스홀릭퍼블리싱), 2018",
        "url": "/JAVA-callByReference"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ohoraming.github.io/">예비 개발자의 노트</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a>
                </section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">예비 개발자의 노트</h1>
            <p class="subscribe-overlay-description">게시글 검색</p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm" />
    <input class="location" type="hidden" name="location" />
    <input class="referrer" type="hidden" name="referrer" />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"
            placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if (event.code == 'Enter') {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function () {
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });
        });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
        </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
    <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>

</html>