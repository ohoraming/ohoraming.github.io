<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://ohoraming.github.io/tag/os/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://ohoraming.github.io/" rel="alternate" type="text/html" />
  <updated>2022-01-25T23:23:11+09:00</updated>
  <id>https://ohoraming.github.io/tag/os/feed.xml</id>

  
  
  

  
    <title type="html">예비 개발자의 노트 | </title>
  

  
    <subtitle>배움을 기록합니다</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">OS(2) - Interrupt-Based System</title>
      <link href="https://ohoraming.github.io/OS-interrupt" rel="alternate" type="text/html" title="OS(2) - Interrupt-Based System" />
      <published>2021-01-18T01:18:00+09:00</published>
      <updated>2021-01-18T01:18:00+09:00</updated>
      <id>https://ohoraming.github.io/OS-interrupt</id>
      <content type="html" xml:base="https://ohoraming.github.io/OS-interrupt">&lt;!-- 글 작성하기 --&gt;

&lt;!-- 글이 시작될 때 관련 시리즈를 리스트로 보여줌 --&gt;
&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;OS 관련 포스팅&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./OS-intro&quot;&gt;OS(1) - Introduction&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./OS-interrupt&quot;&gt;OS(2) - Interrupt-Based System&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interrupt&quot;&gt;Interrupt&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;interrupt: v. 방해하다, 중단시키다&lt;/em&gt;&lt;br /&gt;
→ 어떤 일을 하고 있는데 &lt;strong&gt;가로채서&lt;/strong&gt; 다른 일을 함&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;현대 운영체제는 interrupt 기반 시스템
    &lt;ul&gt;
      &lt;li&gt;booting 완료 후, OS는 메모리에 상주함(resident)&lt;/li&gt;
      &lt;li&gt;마우스를 움직이면 전기신호(=interrupt)가 발생해 CPU의 interrupt선으로 감 &amp;lt;HW interrupt&amp;gt;&lt;/li&gt;
      &lt;li&gt;CPU는 하던 일을 중지하고 OS안의 마우스 Interrupt Service Routine(ISR)(코드)으로 점프&lt;/li&gt;
      &lt;li&gt;특정 icon을 더블클릭하면 interrupt가 걸리고, 더블클릭의 routine(코드)을 실행 &amp;lt;SW interrupt&amp;gt;&lt;/li&gt;
      &lt;li&gt;하드 디스크 속 특정 프로그램을 메인 메모리에 올림&lt;/li&gt;
      &lt;li&gt;바탕화면이 바뀌며 특정 프로그램의 화면이 나옴&lt;/li&gt;
      &lt;li&gt;IRS 종료후 다시 user program 또는 원래의 대기상태로 복귀&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interrupt-기반-os&quot;&gt;interrupt 기반 OS&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;OS는 여러 가지 code들의 모임&lt;br /&gt;
  → 평소에는 작동하지 않고 interrupt에 의해 작동함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;평소 OS는 대기상태&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;HW/SW/Internal(내부) interrupt에 의해 운영체제 코드(ISR)을 실행&lt;/li&gt;
      &lt;li&gt;Internal interrupt&lt;br /&gt;
  e.g.) divide by zero: 
  결괏값이 무한대가 되어 컴퓨터에 저장 공간이 없음&lt;br /&gt;
  → CPU가 내부적인 interrupt로 인식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이중-모드dual-mode&quot;&gt;이중 모드(Dual Mode)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;사용 환경
    &lt;ul&gt;
      &lt;li&gt;한 컴퓨터(= 서버 컴퓨터)를 여러 사람이 동시에 사용하는 환경&lt;/li&gt;
      &lt;li&gt;또는 한 사람이 여러 프로그램을 동시에 사용하는 환경 (e.g.) pc, 스마트폰)&lt;/li&gt;
      &lt;li&gt;또는 한 사람이 특권 명령을 입력하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 모드(User mode) vs. 관리자 모드(Supervisor mode)
    &lt;ul&gt;
      &lt;li&gt;CPU 동작 모드를 &lt;strong&gt;두 가지&lt;/strong&gt;로 진행&lt;/li&gt;
      &lt;li&gt;OS 서비스가 실행될 때, HW/SW interrupt 발생할 때 &lt;strong&gt;관리자 모드&lt;/strong&gt; 실행&lt;/li&gt;
      &lt;li&gt;사용자 프로그램이 실행될 때, OS 서비스가 끝나면 다시 &lt;strong&gt;사용자 모드&lt;/strong&gt; 실행&lt;/li&gt;
      &lt;li&gt;사용자 모드에서는 CPU 중지 명령어(STOP, HALT, RESET 등)와 같은 치명적인 명령어를 사용하지 못하도록 함&lt;/li&gt;
      &lt;li&gt;관리자(supervisor) 모드 = 시스템(system) 모드 = 모니터(monitor)(감시자) 모드 = 특권(priviliged) 모드&lt;/li&gt;
      &lt;li&gt;레지스터에 mode를 나타내는 flag가 존재함
        &lt;ul&gt;
          &lt;li&gt;register: 비트들의 모임&lt;/li&gt;
          &lt;li&gt;flags(carry, negative, zero, overflow)에 monitor 비트를 추가해 0과 1로 이중모드를 구현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특권 명령(Privileged instruction)
    &lt;ul&gt;
      &lt;li&gt;특권 모드에서만 내릴 수 있는 명령어&lt;/li&gt;
      &lt;li&gt;STOP/HALT/RESET(CPU 중지 명령어), SET_TIMER(일반 유저가 시간을 바꾸면 안 됨), SET_HW(HW의 값을 바꿈)…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일반 User program은 하드 디스크에 접근이 불가함&lt;br /&gt;
  즉, 서버 컴퓨터에 접속해 타인의 파일을 열람할 수 없다는 뜻(보안 문제)&lt;br /&gt;
  그래서 OS에 SW interrupt를 걸어 ISR을 실행해 필요한 작업을 하게 함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;일반적인 프로그램의 실행
    &lt;ol&gt;
      &lt;li&gt;power on&lt;/li&gt;
      &lt;li&gt;booting: 하드 디스크의 프로그램이 메인 메모리에 적재
        &lt;ul&gt;
          &lt;li&gt;monitor 비트 = 1 : system mode라는 뜻&lt;/li&gt;
          &lt;li&gt;OS는 system mode에서 동작함&lt;/li&gt;
          &lt;li&gt;일반 user는 못 내리는 명령 수행 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;user mode &amp;gt; (키보드, 마우스) HW interrupt &amp;gt; system mode(ISR) &amp;gt; user mode &amp;gt; (모니터, 디스크, 프린터) &amp;gt; system mode &amp;gt; user mode
        &lt;ul&gt;
          &lt;li&gt;만약, user mode에서 CPU에 STOP 명령을 내리면,&lt;br /&gt;
 CPU는 internal interrupt가 발생했다고 여겨 OS의 ISR로 점프해&lt;br /&gt;
 해당 명령을 내린 프로그램을 강제 종료시켜 메모리에서 내림&lt;br /&gt;
  → protection과 연관됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;하드웨어 보호
    &lt;ol&gt;
      &lt;li&gt;입출력장치 보호
        &lt;ul&gt;
          &lt;li&gt;사용자가 input/output device에 바로 접근하는 것 불가, 반드시 OS를 거쳐야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리 보호
        &lt;ul&gt;
          &lt;li&gt;자신에게 주어진 메모리 영역을 넘어서는 것을 막음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CPU 보호
        &lt;ul&gt;
          &lt;li&gt;한 컴퓨터를 여러 명이 쓴다면, CPU 역시 침범 대상이 될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;(1) 입출력장치 보호
    &lt;ul&gt;
      &lt;li&gt;서로 다른 사용자들 간의 입출력 정보가 끼어들어 혼선이 생기는 것을 막기 위함&lt;/li&gt;
      &lt;li&gt;입출력 명령(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN OUT&lt;/code&gt;)을 &lt;strong&gt;특권 명령&lt;/strong&gt;으로 지정함&lt;/li&gt;
      &lt;li&gt;SW interrupt(명령어: INT) &amp;gt; OS에 요청(system mode로 전환) &amp;gt; 입출력 실행 &amp;gt; 다시 user mode로 복귀&lt;/li&gt;
      &lt;li&gt;이때, 올바른 요청인지 ISR의 초반에 확인하며, 그렇지 않다면 OS가 거부함&lt;/li&gt;
      &lt;li&gt;user mode에서 사용자가 직접 입출력 명령을 내린다면 ISR로 점프해 해당 프로그램을 종료시킴(privileged instruction violation, 특권 명령 침범)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(2) 메모리 보호
    &lt;ul&gt;
      &lt;li&gt;다른 사용자의 메모리 혹은 OS영역의 메모리에 접근하는 것을 막기 위함&lt;/li&gt;
      &lt;li&gt;MMU(&lt;strong&gt;M&lt;/strong&gt;emory &lt;strong&gt;M&lt;/strong&gt;anagement &lt;strong&gt;U&lt;/strong&gt;nit)를 두어 다른 메모리 영역 침범을 감시함&lt;/li&gt;
      &lt;li&gt;일종의 문지기로 &lt;strong&gt;base registar&lt;/strong&gt;와 &lt;strong&gt;limit register&lt;/strong&gt; 사이의 값만 통과시킴&lt;/li&gt;
      &lt;li&gt;Address bus에 base/limit register를 설정해두고 그 범위를 넘어서면 interrupt를 발생시킴&lt;/li&gt;
      &lt;li&gt;메모리에 잘못된 접근이 일어나면 ISR이 동작해 해당 프로그램을 강제 종료시킴(segment violation, 영역 침범)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(3) CPU 보호
    &lt;ul&gt;
      &lt;li&gt;한 사용자의 CPU 시간 독점이 다른 사용자의 프로그램 실행을 방해하는 것을 막기 위함&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TIMER&lt;/strong&gt;를 두어 일정 시간 경과시 timer interrupt 발생&lt;/li&gt;
      &lt;li&gt;timer가 cpu에 주기적으로 interrupt를 걸어줌&lt;/li&gt;
      &lt;li&gt;interrupt가 발생 &amp;gt; ISR로 jump &amp;gt; ISR의 코드에 한 프로그램이 CPU시간을 독점하는지 감시하는 부분이 존재 &amp;gt; 다른 프로그램으로 강제 전환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>ohoraming</name>
        
        
      </author>

      

      
        <category term="OS" />
      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">OS(1) - Introduction</title>
      <link href="https://ohoraming.github.io/OS-intro" rel="alternate" type="text/html" title="OS(1) - Introduction" />
      <published>2021-01-12T22:06:00+09:00</published>
      <updated>2021-01-12T22:06:00+09:00</updated>
      <id>https://ohoraming.github.io/OS-intro</id>
      <content type="html" xml:base="https://ohoraming.github.io/OS-intro">&lt;!-- 글 작성하기 --&gt;

&lt;!-- 글이 시작될 때 관련 시리즈를 리스트로 보여줌 --&gt;
&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;OS 관련 포스팅&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./OS-intro&quot;&gt;OS(1) - Introduction&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./OS-interrupt&quot;&gt;OS(2) - Interrupt-Based System&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;운영체제operating-system-os의-목적&quot;&gt;운영체제(Operating System, OS)의 목적&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;컴퓨터 &lt;strong&gt;하드웨어를 잘 관리&lt;/strong&gt;하여
    &lt;ul&gt;
      &lt;li&gt;HW: processor, memory, disk, keyboard, mouse, monitor…&lt;/li&gt;
      &lt;li&gt;OS가 메모리에 올라오면 User가 컴퓨터를 제어할 수 있게 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능&lt;/strong&gt;을 높이고
    &lt;ul&gt;
      &lt;li&gt;같은 HW라도 OS가 좋으면 성능이 향상됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자에게 &lt;strong&gt;편의성&lt;/strong&gt;을 제공
    &lt;ul&gt;
      &lt;li&gt;컴퓨터를 몇 번만 사용해보면 누구나 쉽게 사용할 수 있음&lt;/li&gt;
      &lt;li&gt;과거, 1940s-1950s에는 전문가(oprator)들만 컴퓨터를 사용할 수 있었음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;부팅booting&quot;&gt;부팅(Booting)&lt;/h2&gt;
&lt;p&gt;boot: &lt;em&gt;n. 목이 긴 신발, 부츠&lt;/em&gt;&lt;br /&gt;
booting: 부츠를 끌어당겨 신는 것처럼 OS를 메인 메모리로 끌어당김&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전원을 켜면&lt;/li&gt;
  &lt;li&gt;ROM의 code를 읽어와 실행
    &lt;ul&gt;
      &lt;li&gt;ROM: Read Only Memory&lt;/li&gt;
      &lt;li&gt;RAM: main memory의 대부분을 차지(수GB(10^9))&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;POST(Power-On Self-Test) 실행
    &lt;ul&gt;
      &lt;li&gt;전원을 켰을 때, 컴퓨터의 환경 설정이 제대로 되었는지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Boot loader실행
    &lt;ul&gt;
      &lt;li&gt;load: v.적재하다&lt;/li&gt;
      &lt;li&gt;하드 디스크 안의 OS를 메인 메모리로 가져옴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OS가 메인 메모리(RAM)에 올라오면, 명령을 받아들일 준비를 마침
    &lt;ul&gt;
      &lt;li&gt;Windows의 경우 바탕화면이 뜨고, Linux의 경우 prompt 창이 뜸&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;os--kernel--shell&quot;&gt;OS = kernel + shell&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Kernel
    &lt;ul&gt;
      &lt;li&gt;핵심&lt;/li&gt;
      &lt;li&gt;HW를 둘러싸며 이를 제어, 관리함&lt;/li&gt;
      &lt;li&gt;실제로 관리하는 프로그램&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shell
    &lt;ul&gt;
      &lt;li&gt;OS의 껍질 부분&lt;/li&gt;
      &lt;li&gt;명령어 해석기(command interpreter)&lt;/li&gt;
      &lt;li&gt;사용자로부터 명령을 받아 변역 후 해당 명령을 실행함&lt;/li&gt;
      &lt;li&gt;명령: 아이콘 더블 클릭(Windows), 텍스트 입력(Linux &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ls&lt;/code&gt;(현 directory file 보여줌), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$who&lt;/code&gt;(사용자 확인), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ds&lt;/code&gt;(디스크 용량 확인) 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;os의-위치&quot;&gt;OS의 위치&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Application(App) ⊃ OS  ⊃ HW 
&lt;a href=&quot;https://www.ssla.co.uk/wp-content/uploads/2020/07/linux-operating-system-600x493.png&quot;&gt;&lt;img src=&quot;https://www.ssla.co.uk/wp-content/uploads/2020/07/linux-operating-system-600x493.png&quot; alt=&quot;os diagram&quot; width=&quot;50%&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;정부(government)에 비유할 수 있음&lt;/li&gt;
  &lt;li&gt;주어진 자원을 &lt;strong&gt;할당&lt;/strong&gt;(resource allocator)하고 &lt;strong&gt;관리&lt;/strong&gt;함(resource manager)&lt;/li&gt;
  &lt;li&gt;OS가 직접 일을 하지 않고, 각 부서에 맞는 업무를 할당함&lt;/li&gt;
  &lt;li&gt;프로세스 관리와 메인 메모리 관리가 가장 중요한 업무&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;역사&quot;&gt;역사&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;컴퓨터의 역사
    &lt;ul&gt;
      &lt;li&gt;1940s, &lt;strong&gt;OS가 없었음&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;programmer가 &lt;strong&gt;종이&lt;/strong&gt;에 연필로 program을 작성해 전산실에 전달&lt;/li&gt;
      &lt;li&gt;전달받은대로 구멍(천공)을 뚫은 카드와 compiler 프로그램 카드를 &lt;strong&gt;카드 리더기&lt;/strong&gt;에 올림&lt;/li&gt;
      &lt;li&gt;프로그램과 compiler가 &lt;strong&gt;메모리&lt;/strong&gt;에 적재되고 기계어가 도출됨&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;처리기(processor)&lt;/strong&gt;가 기계어를 실행하면&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;line printer&lt;/strong&gt;가 망치로 두드려 결과를 인쇄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Batch processing system(일괄처리)
    &lt;ul&gt;
      &lt;li&gt;resident monitor: &lt;strong&gt;최초의 OS&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;사람(operator)이 직접 compiler, linker, loading을 했음&lt;/li&gt;
      &lt;li&gt;이 일련의 과정을 메모리에 프로그램으로 넣어(=&lt;strong&gt;상주&lt;/strong&gt;시켜) &lt;strong&gt;자동으로 실행&lt;/strong&gt;시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multiprogramming system(다중 프로그래밍)
    &lt;ul&gt;
      &lt;li&gt;컴퓨터는 비싼 자원&lt;/li&gt;
      &lt;li&gt;CPU에 비해 i/o의 처리 속도는 느리며, i/o 처리 시간 동안 CPU는 idle상태(가동되지 않는)가 됨&lt;/li&gt;
      &lt;li&gt;i/o 처리시 다음 user의 연산을 처리&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;하나의 CPU를 여러 user(program)가 사용&lt;/strong&gt;해 이용률을 증가시킴&lt;/li&gt;
      &lt;li&gt;user program의 효율적인 배치를 고민해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Time-sharing system(시공유 시스템)
    &lt;ul&gt;
      &lt;li&gt;아주 &lt;strong&gt;짧은 시간(1/100초~1/1000초)동안 각 user의 작업을 나눠서 처리&lt;/strong&gt;함&lt;/li&gt;
      &lt;li&gt;혼자서 CPU를 쓰는 느낌을 줄 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;os-기술-천이&quot;&gt;OS 기술 천이&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 규모별 분류
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Supercomputer &amp;gt; Mainframe &amp;gt; Mini &amp;gt; Micro&lt;/strong&gt;&lt;br /&gt;
  Supercomputer: 최강의 컴퓨터. 메모리 용량이 크고, CPU가 빠르며, 보조 기억장치가 뛰어남&lt;br /&gt;
  Mainframe: 수백 대의 단말기를 연결한 형태&lt;br /&gt;
  Mini: 수십 대의 단말기를 연결한 형태&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Supercomputer &amp;gt; Server &amp;gt; Workstation &amp;gt; PC &amp;gt; Handheld &amp;gt; Embeded&lt;/strong&gt;&lt;br /&gt;
  Handheld: 노트북, 태블릿, 스마트 폰&lt;br /&gt;
  Embeded: 차나 가전에 내장된 형태&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;고성능 컴퓨터의 기능이 Handheld, Embeded까지 적용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;고등-운영체제&quot;&gt;고등 운영체제&lt;/h2&gt;
&lt;p&gt;(※대학원 과정)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다중 프로세서 시스템&lt;/li&gt;
  &lt;li&gt;분산 시스템&lt;/li&gt;
  &lt;li&gt;실시간 시스템&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>ohoraming</name>
        
        
      </author>

      

      
        <category term="OS" />
      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
</feed>
